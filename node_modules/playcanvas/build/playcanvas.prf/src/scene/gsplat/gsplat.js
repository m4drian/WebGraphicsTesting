import { FloatPacking } from '../../core/math/float-packing.js';
import { math } from '../../core/math/math.js';
import { Quat } from '../../core/math/quat.js';
import { Vec2 } from '../../core/math/vec2.js';
import { Vec3 } from '../../core/math/vec3.js';
import { Vec4 } from '../../core/math/vec4.js';
import { Mat3 } from '../../core/math/mat3.js';
import { PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_R16F, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';
import { Texture } from '../../platform/graphics/texture.js';
import { BoundingBox } from '../../core/shape/bounding-box.js';
import { createGSplatMaterial } from './gsplat-material.js';

const _tmpVecA = new Vec3();
const _tmpVecB = new Vec3();
const _tmpVecC = new Vec3();
const _m0 = new Vec3();
const _m1 = new Vec3();
const _m2 = new Vec3();
class GSplat {
	constructor(device, gsplatData) {
		this.device = void 0;
		this.numSplats = void 0;
		this.centers = void 0;
		this.aabb = void 0;
		this.colorTexture = void 0;
		this.transformATexture = void 0;
		this.transformBTexture = void 0;
		this.transformCTexture = void 0;
		const numSplats = gsplatData.numSplats;
		this.device = device;
		this.numSplats = numSplats;
		this.centers = new Float32Array(gsplatData.numSplats * 3);
		gsplatData.getCenters(this.centers);
		this.aabb = new BoundingBox();
		gsplatData.calcAabb(this.aabb);
		const size = this.evalTextureSize(numSplats);
		this.colorTexture = this.createTexture('splatColor', PIXELFORMAT_RGBA8, size);
		this.transformATexture = this.createTexture('transformA', PIXELFORMAT_RGBA32F, size);
		this.transformBTexture = this.createTexture('transformB', PIXELFORMAT_RGBA16F, size);
		this.transformCTexture = this.createTexture('transformC', PIXELFORMAT_R16F, size);
		this.updateColorData(gsplatData);
		this.updateTransformData(gsplatData);
	}
	destroy() {
		var _this$colorTexture, _this$transformATextu, _this$transformBTextu, _this$transformCTextu;
		(_this$colorTexture = this.colorTexture) == null || _this$colorTexture.destroy();
		(_this$transformATextu = this.transformATexture) == null || _this$transformATextu.destroy();
		(_this$transformBTextu = this.transformBTexture) == null || _this$transformBTextu.destroy();
		(_this$transformCTextu = this.transformCTexture) == null || _this$transformCTextu.destroy();
	}
	createMaterial(options) {
		const result = createGSplatMaterial(options);
		result.setParameter('splatColor', this.colorTexture);
		result.setParameter('transformA', this.transformATexture);
		result.setParameter('transformB', this.transformBTexture);
		result.setParameter('transformC', this.transformCTexture);
		result.setParameter('tex_params', new Float32Array([this.colorTexture.width, this.numSplats]));
		return result;
	}
	evalTextureSize(count) {
		const width = Math.ceil(Math.sqrt(count));
		const height = Math.ceil(count / width);
		return new Vec2(width, height);
	}
	createTexture(name, format, size) {
		return new Texture(this.device, {
			name: name,
			width: size.x,
			height: size.y,
			format: format,
			cubemap: false,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
	}
	getTextureFormat(device, preferHighPrecision) {
		if (device.isWebGL1) preferHighPrecision = false;
		const halfSupported = device.extTextureHalfFloat && device.textureHalfFloatUpdatable;
		const floatSupported = device.extTextureFloat;
		let halfFormat;
		if (preferHighPrecision) {
			if (floatSupported) {
				halfFormat = false;
			} else if (halfSupported) {
				halfFormat = true;
			}
		} else {
			if (halfSupported) {
				halfFormat = true;
			} else if (floatSupported) {
				halfFormat = false;
			}
		}
		return halfFormat;
	}
	updateColorData(gsplatData) {
		const texture = this.colorTexture;
		if (!texture) return;
		const data = texture.lock();
		const c = new Vec4();
		const iter = gsplatData.createIter(null, null, null, c);
		for (let i = 0; i < this.numSplats; ++i) {
			iter.read(i);
			data[i * 4 + 0] = math.clamp(c.x * 255, 0, 255);
			data[i * 4 + 1] = math.clamp(c.y * 255, 0, 255);
			data[i * 4 + 2] = math.clamp(c.z * 255, 0, 255);
			data[i * 4 + 3] = math.clamp(c.w * 255, 0, 255);
		}
		texture.unlock();
	}
	updateTransformData(gsplatData) {
		const float2Half = FloatPacking.float2Half;
		if (!this.transformATexture) return;
		const dataA = this.transformATexture.lock();
		const dataB = this.transformBTexture.lock();
		const dataC = this.transformCTexture.lock();
		const p = new Vec3();
		const r = new Quat();
		const s = new Vec3();
		const iter = gsplatData.createIter(p, r, s);
		const mat = new Mat3();
		const cA = new Vec3();
		const cB = new Vec3();
		for (let i = 0; i < this.numSplats; i++) {
			iter.read(i);
			r.normalize();
			mat.setFromQuat(r);
			this.computeCov3d(mat, s, cA, cB);
			dataA[i * 4 + 0] = p.x;
			dataA[i * 4 + 1] = p.y;
			dataA[i * 4 + 2] = p.z;
			dataA[i * 4 + 3] = cB.x;
			dataB[i * 4 + 0] = float2Half(cA.x);
			dataB[i * 4 + 1] = float2Half(cA.y);
			dataB[i * 4 + 2] = float2Half(cA.z);
			dataB[i * 4 + 3] = float2Half(cB.y);
			dataC[i] = float2Half(cB.z);
		}
		this.transformATexture.unlock();
		this.transformBTexture.unlock();
		this.transformCTexture.unlock();
	}
	computeCov3d(rot, scale, covA, covB) {
		const r0 = rot.getX(_tmpVecA).mulScalar(scale.x);
		const r1 = rot.getY(_tmpVecB).mulScalar(scale.y);
		const r2 = rot.getZ(_tmpVecC).mulScalar(scale.z);
		_m0.set(r0.x, r1.x, r2.x);
		_m1.set(r0.y, r1.y, r2.y);
		_m2.set(r0.z, r1.z, r2.z);
		covA.set(_m0.dot(_m0), _m0.dot(_m1), _m0.dot(_m2));
		covB.set(_m1.dot(_m1), _m1.dot(_m2), _m2.dot(_m2));
	}
}

export { GSplat };
