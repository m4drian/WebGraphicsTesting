/**
 * The forward renderer renders {@link Scene}s.
 *
 * @ignore
 */
export class ForwardRenderer extends Renderer {
    static skipRenderCamera: any;
    static _skipRenderCounter: number;
    static skipRenderAfter: number;
    _forwardDrawCalls: number;
    _materialSwitches: number;
    _depthMapTime: number;
    _forwardTime: number;
    _sortTime: number;
    fogColorId: import("../../index.js").ScopeId;
    fogStartId: import("../../index.js").ScopeId;
    fogEndId: import("../../index.js").ScopeId;
    fogDensityId: import("../../index.js").ScopeId;
    ambientId: import("../../index.js").ScopeId;
    skyboxIntensityId: import("../../index.js").ScopeId;
    cubeMapRotationMatrixId: import("../../index.js").ScopeId;
    pcssDiskSamplesId: import("../../index.js").ScopeId;
    pcssSphereSamplesId: import("../../index.js").ScopeId;
    lightColorId: any[];
    lightDir: any[];
    lightDirId: any[];
    lightShadowMapId: any[];
    lightShadowMatrixId: any[];
    lightShadowParamsId: any[];
    lightShadowIntensity: any[];
    lightRadiusId: any[];
    lightPos: any[];
    lightPosId: any[];
    lightWidth: any[];
    lightWidthId: any[];
    lightHeight: any[];
    lightHeightId: any[];
    lightInAngleId: any[];
    lightOutAngleId: any[];
    lightCookieId: any[];
    lightCookieIntId: any[];
    lightCookieMatrixId: any[];
    lightCookieOffsetId: any[];
    lightShadowSearchAreaId: any[];
    lightCameraParamsId: any[];
    shadowMatrixPaletteId: any[];
    shadowCascadeDistancesId: any[];
    shadowCascadeCountId: any[];
    screenSizeId: import("../../index.js").ScopeId;
    _screenSize: Float32Array;
    fogColor: Float32Array;
    ambientColor: Float32Array;
    pcssDiskSamples: number[];
    pcssSphereSamples: number[];
    /**
     * @param {import('../scene.js').Scene} scene - The scene.
     */
    dispatchGlobalLights(scene: import('../scene.js').Scene): void;
    _resolveLight(scope: any, i: any): void;
    setLTCDirectionalLight(wtm: any, cnt: any, dir: any, campos: any, far: any): void;
    dispatchDirectLights(dirs: any, scene: any, mask: any, camera: any): number;
    setLTCPositionalLight(wtm: any, cnt: any): void;
    dispatchOmniLight(scene: any, scope: any, omni: any, cnt: any): void;
    dispatchSpotLight(scene: any, scope: any, spot: any, cnt: any): void;
    dispatchLocalLights(sortedLights: any, scene: any, mask: any, usedDirLights: any): void;
    renderForwardPrepareMaterials(camera: any, drawCalls: any, sortedLights: any, layer: any, pass: any): {
        drawCalls: any[];
        shaderInstances: any[];
        isNewMaterial: any[];
        lightMaskChanged: any[];
        clear: () => void;
    };
    renderForwardInternal(camera: any, preparedCalls: any, sortedLights: any, pass: any, drawCallback: any, flipFaces: any): void;
    renderForward(camera: any, allDrawCalls: any, sortedLights: any, pass: any, drawCallback: any, layer: any, flipFaces: any): void;
    /**
     * Forward render mesh instances on a specified layer, using a camera and a render target.
     * Shaders used are based on the shaderPass provided, with optional clustered lighting support.
     *
     * @param {import('../camera.js').Camera} camera - The
     * camera.
     * @param {import('../../platform/graphics/render-target.js').RenderTarget|undefined} renderTarget - The
     * render target.
     * @param {import('../layer.js').Layer} layer - The layer.
     * @param {boolean} transparent - True if transparent sublayer should be rendered, opaque
     * otherwise.
     * @param {number} shaderPass - A type of shader to use during rendering.
     * @param {import('../../platform/graphics/bind-group.js').BindGroup[]} viewBindGroups - An array
     * storing the view level bing groups (can be empty array, and this function populates if per
     * view).
     * @param {object} [options] - Object for passing optional arguments.
     * @param {boolean} [options.clearColor] - True if the color buffer should be cleared.
     * @param {boolean} [options.clearDepth] - True if the depth buffer should be cleared.
     * @param {boolean} [options.clearStencil] - True if the stencil buffer should be cleared.
     * @param {import('../lighting/world-clusters.js').WorldClusters} [options.lightClusters] - The
     * world clusters object to be used for clustered lighting.
     * @param {import('../mesh-instance.js').MeshInstance[]} [options.meshInstances] - The mesh
     * instances to be rendered. Use when layer is not provided.
     * @param {object} [options.splitLights] - The split lights to be used for clustered lighting.
     */
    renderForwardLayer(camera: import('../camera.js').Camera, renderTarget: import('../../platform/graphics/render-target.js').RenderTarget | undefined, layer: import('../layer.js').Layer, transparent: boolean, shaderPass: number, viewBindGroups: import('../../platform/graphics/bind-group.js').BindGroup[], options?: {
        clearColor?: boolean;
        clearDepth?: boolean;
        clearStencil?: boolean;
        lightClusters?: import('../lighting/world-clusters.js').WorldClusters;
        meshInstances?: import('../mesh-instance.js').MeshInstance[];
        splitLights?: object;
    }): void;
    setSceneConstants(): void;
    /**
     * Builds a frame graph for the rendering of the whole frame.
     *
     * @param {import('../frame-graph.js').FrameGraph} frameGraph - The frame-graph that is built.
     * @param {import('../composition/layer-composition.js').LayerComposition} layerComposition - The
     * layer composition used to build the frame graph.
     * @ignore
     */
    buildFrameGraph(frameGraph: import('../frame-graph.js').FrameGraph, layerComposition: import('../composition/layer-composition.js').LayerComposition): void;
    /**
     * @param {import('../frame-graph.js').FrameGraph} frameGraph - The frame graph.
     * @param {import('../composition/layer-composition.js').LayerComposition} layerComposition - The
     * layer composition.
     */
    addMainRenderPass(frameGraph: import('../frame-graph.js').FrameGraph, layerComposition: import('../composition/layer-composition.js').LayerComposition, renderTarget: any, startIndex: any, endIndex: any): void;
    /**
     * @param {import('../composition/layer-composition.js').LayerComposition} comp - The layer
     * composition.
     */
    update(comp: import('../composition/layer-composition.js').LayerComposition): void;
}
import { Renderer } from './renderer.js';
