/**
 * The base renderer functionality to allow implementation of specialized renderers.
 *
 * @ignore
 */
export class Renderer {
    /**
     * Create a new instance.
     *
     * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} graphicsDevice - The
     * graphics device used by the renderer.
     */
    constructor(graphicsDevice: import('../../platform/graphics/graphics-device.js').GraphicsDevice);
    /** @type {boolean} */
    clustersDebugRendered: boolean;
    /**
     * A set of visible mesh instances which need further processing before being rendered, e.g.
     * skinning or morphing. Extracted during culling.
     *
     * @type {Set<import('../mesh-instance.js').MeshInstance>}
     * @private
     */
    private processingMeshInstances;
    /**
     * @type {WorldClustersAllocator}
     * @ignore
     */
    worldClustersAllocator: WorldClustersAllocator;
    /**
     * A list of all unique lights in the layer composition.
     *
     * @type {import('../light.js').Light[]}
     */
    lights: import('../light.js').Light[];
    /**
     * A list of all unique local lights (spot & omni) in the layer composition.
     *
     * @type {import('../light.js').Light[]}
     */
    localLights: import('../light.js').Light[];
    /**
     * A list of unique directional shadow casting lights for each enabled camera. This is generated
     * each frame during light culling.
     *
     * @type {Map<import('../camera.js').Camera, Array<import('../light.js').Light>>}
     */
    cameraDirShadowLights: Map<import('../camera.js').Camera, Array<import('../light.js').Light>>;
    /**
     * A mapping of a directional light to a camera, for which the shadow is currently valid. This
     * is cleared each frame, and updated each time a directional light shadow is rendered for a
     * camera, and allows us to manually schedule shadow passes when a new camera needs a shadow.
     *
     * @type {Map<import('../light.js').Light, import('../camera.js').Camera>}
     */
    dirLightShadows: Map<import('../light.js').Light, import('../camera.js').Camera>;
    blueNoise: BlueNoise;
    device: import("../../platform/graphics/graphics-device.js").GraphicsDevice;
    /** @type {import('../scene.js').Scene|null} */
    scene: import('../scene.js').Scene | null;
    lightTextureAtlas: LightTextureAtlas;
    shadowMapCache: ShadowMapCache;
    shadowRenderer: ShadowRenderer;
    _shadowRendererLocal: ShadowRendererLocal;
    _shadowRendererDirectional: ShadowRendererDirectional;
    _renderPassUpdateClustered: RenderPassUpdateClustered;
    viewUniformFormat: UniformBufferFormat;
    viewBindGroupFormat: BindGroupFormat;
    _skinTime: number;
    _morphTime: number;
    _cullTime: number;
    _shadowMapTime: number;
    _lightClustersTime: number;
    _layerCompositionUpdateTime: number;
    _shadowDrawCalls: number;
    _skinDrawCalls: number;
    _instancedDrawCalls: number;
    _shadowMapUpdates: number;
    _numDrawCallsCulled: number;
    _camerasRendered: number;
    _lightClusters: number;
    boneTextureId: import("../../index.js").ScopeId;
    boneTextureSizeId: import("../../index.js").ScopeId;
    poseMatrixId: import("../../index.js").ScopeId;
    modelMatrixId: import("../../index.js").ScopeId;
    normalMatrixId: import("../../index.js").ScopeId;
    viewInvId: import("../../index.js").ScopeId;
    viewPos: Float32Array;
    viewPosId: import("../../index.js").ScopeId;
    projId: import("../../index.js").ScopeId;
    projSkyboxId: import("../../index.js").ScopeId;
    viewId: import("../../index.js").ScopeId;
    viewId3: import("../../index.js").ScopeId;
    viewProjId: import("../../index.js").ScopeId;
    flipYId: import("../../index.js").ScopeId;
    tbnBasis: import("../../index.js").ScopeId;
    nearClipId: import("../../index.js").ScopeId;
    farClipId: import("../../index.js").ScopeId;
    cameraParams: Float32Array;
    cameraParamsId: import("../../index.js").ScopeId;
    viewIndexId: import("../../index.js").ScopeId;
    blueNoiseJitterVersion: number;
    blueNoiseJitterVec: Vec4;
    blueNoiseJitterData: Float32Array;
    blueNoiseJitterId: import("../../index.js").ScopeId;
    blueNoiseTextureId: import("../../index.js").ScopeId;
    alphaTestId: import("../../index.js").ScopeId;
    opacityMapId: import("../../index.js").ScopeId;
    exposureId: import("../../index.js").ScopeId;
    twoSidedLightingNegScaleFactorId: import("../../index.js").ScopeId;
    morphWeightsA: import("../../index.js").ScopeId;
    morphWeightsB: import("../../index.js").ScopeId;
    morphPositionTex: import("../../index.js").ScopeId;
    morphNormalTex: import("../../index.js").ScopeId;
    morphTexParams: import("../../index.js").ScopeId;
    lightCube: LightCube;
    constantLightCube: import("../../index.js").ScopeId;
    destroy(): void;
    sortCompare(drawCallA: any, drawCallB: any): number;
    sortCompareMesh(drawCallA: any, drawCallB: any): number;
    sortCompareDepth(drawCallA: any, drawCallB: any): number;
    /**
     * Set up the viewport and the scissor for camera rendering.
     *
     * @param {import('../camera.js').Camera} camera - The camera containing the viewport
     * information.
     * @param {import('../../platform/graphics/render-target.js').RenderTarget} [renderTarget] - The
     * render target. NULL for the default one.
     */
    setupViewport(camera: import('../camera.js').Camera, renderTarget?: import('../../platform/graphics/render-target.js').RenderTarget): void;
    setCameraUniforms(camera: any, target: any): number;
    /**
     * Clears the active render target. If the viewport is already set up, only its area is cleared.
     *
     * @param {import('../camera.js').Camera} camera - The camera supplying the value to clear to.
     * @param {boolean} [clearColor] - True if the color buffer should be cleared. Uses the value
     * from the camera if not supplied.
     * @param {boolean} [clearDepth] - True if the depth buffer should be cleared. Uses the value
     * from the camera if not supplied.
     * @param {boolean} [clearStencil] - True if the stencil buffer should be cleared. Uses the
     * value from the camera if not supplied.
     */
    clear(camera: import('../camera.js').Camera, clearColor?: boolean, clearDepth?: boolean, clearStencil?: boolean): void;
    setCamera(camera: any, target: any, clear: any, renderAction?: any): void;
    clearView(camera: any, target: any, clear: any, forceWrite: any): void;
    setupCullMode(cullFaces: any, flipFactor: any, drawCall: any): void;
    updateCameraFrustum(camera: any): void;
    setBaseConstants(device: any, material: any): void;
    updateCpuSkinMatrices(drawCalls: any): void;
    /**
     * Update skin matrices ahead of rendering.
     *
     * @param {import('../mesh-instance.js').MeshInstance[]|Set<import('../mesh-instance.js').MeshInstance>} drawCalls - MeshInstances
     * containing skinInstance.
     * @ignore
     */
    updateGpuSkinMatrices(drawCalls: import('../mesh-instance.js').MeshInstance[] | Set<import('../mesh-instance.js').MeshInstance>): void;
    /**
     * Update morphing ahead of rendering.
     *
     * @param {import('../mesh-instance.js').MeshInstance[]|Set<import('../mesh-instance.js').MeshInstance>} drawCalls - MeshInstances
     * containing morphInstance.
     * @ignore
     */
    updateMorphing(drawCalls: import('../mesh-instance.js').MeshInstance[] | Set<import('../mesh-instance.js').MeshInstance>): void;
    /**
     * Update gsplats ahead of rendering.
     *
     * @param {import('../mesh-instance.js').MeshInstance[]|Set<import('../mesh-instance.js').MeshInstance>} drawCalls - MeshInstances
     * containing gsplatInstances.
     * @ignore
     */
    updateGSplats(drawCalls: import('../mesh-instance.js').MeshInstance[] | Set<import('../mesh-instance.js').MeshInstance>): void;
    /**
     * Update draw calls ahead of rendering.
     *
     * @param {import('../mesh-instance.js').MeshInstance[]|Set<import('../mesh-instance.js').MeshInstance>} drawCalls - MeshInstances
     * requiring updates.
     * @ignore
     */
    gpuUpdate(drawCalls: import('../mesh-instance.js').MeshInstance[] | Set<import('../mesh-instance.js').MeshInstance>): void;
    setVertexBuffers(device: any, mesh: any): void;
    setMorphing(device: any, morphInstance: any): void;
    setSkinning(device: any, meshInstance: any): void;
    dispatchViewPos(position: any): void;
    initViewBindGroupFormat(isClustered: any): void;
    setupViewUniformBuffers(viewBindGroups: any, viewUniformFormat: any, viewBindGroupFormat: any, viewCount: any): void;
    setupMeshUniformBuffers(shaderInstance: any, meshInstance: any): void;
    drawInstance(device: any, meshInstance: any, mesh: any, style: any, normal: any): void;
    drawInstance2(device: any, meshInstance: any, mesh: any, style: any): void;
    /**
     * @param {import('../camera.js').Camera} camera - The camera used for culling.
     * @param {import('../mesh-instance.js').MeshInstance[]} drawCalls - Draw calls to cull.
     * @param {import('../layer.js').CulledInstances} culledInstances - Stores culled instances.
     */
    cull(camera: import('../camera.js').Camera, drawCalls: import('../mesh-instance.js').MeshInstance[], culledInstances: import('../layer.js').CulledInstances): void;
    collectLights(comp: any): void;
    cullLights(camera: any, lights: any): void;
    /**
     * Shadow map culling for directional and visible local lights
     * visible meshInstances are collected into light._renderData, and are marked as visible
     * for directional lights also shadow camera matrix is set up
     *
     * @param {import('../composition/layer-composition.js').LayerComposition} comp - The layer
     * composition.
     */
    cullShadowmaps(comp: import('../composition/layer-composition.js').LayerComposition): void;
    /**
     * visibility culling of lights, meshInstances, shadows casters
     * Also applies meshInstance.visible
     *
     * @param {import('../composition/layer-composition.js').LayerComposition} comp - The layer
     * composition.
     */
    cullComposition(comp: import('../composition/layer-composition.js').LayerComposition): void;
    /**
     * @param {import('../mesh-instance.js').MeshInstance[]} drawCalls - Mesh instances.
     * @param {boolean} onlyLitShaders - Limits the update to shaders affected by lighting.
     */
    updateShaders(drawCalls: import('../mesh-instance.js').MeshInstance[], onlyLitShaders: boolean): void;
    updateFrameUniforms(): void;
    /**
     * @param {import('../composition/layer-composition.js').LayerComposition} comp - The layer
     * composition to update.
     */
    beginFrame(comp: import('../composition/layer-composition.js').LayerComposition): void;
    updateLightTextureAtlas(): void;
    /**
     * Updates the layer composition for rendering.
     *
     * @param {import('../composition/layer-composition.js').LayerComposition} comp - The layer
     * composition to update.
     */
    updateLayerComposition(comp: import('../composition/layer-composition.js').LayerComposition): void;
    frameUpdate(): void;
}
import { WorldClustersAllocator } from './world-clusters-allocator.js';
import { BlueNoise } from '../../core/math/blue-noise.js';
import { LightTextureAtlas } from '../lighting/light-texture-atlas.js';
import { ShadowMapCache } from './shadow-map-cache.js';
import { ShadowRenderer } from './shadow-renderer.js';
import { ShadowRendererLocal } from './shadow-renderer-local.js';
import { ShadowRendererDirectional } from './shadow-renderer-directional.js';
import { RenderPassUpdateClustered } from './render-pass-update-clustered.js';
import { UniformBufferFormat } from '../../platform/graphics/uniform-buffer-format.js';
import { BindGroupFormat } from '../../platform/graphics/bind-group-format.js';
import { Vec4 } from '../../core/math/vec4.js';
import { LightCube } from '../graphics/light-cube.js';
