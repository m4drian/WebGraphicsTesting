/**
 * Callback used by {@link Layer } to calculate the "sort distance" for a {@link MeshInstance },
 * which determines its place in the render order.
 */
export type CalculateSortDistanceCallback = (meshInstance: MeshInstance, cameraPosition: import('../core/math/vec3.js').Vec3, cameraForward: import('../core/math/vec3.js').Vec3) => any;
/**
 * Callback used by {@link Layer} to calculate the "sort distance" for a {@link MeshInstance},
 * which determines its place in the render order.
 *
 * @callback CalculateSortDistanceCallback
 * @param {MeshInstance} meshInstance - The mesh instance.
 * @param {import('../core/math/vec3.js').Vec3} cameraPosition - The position of the camera.
 * @param {import('../core/math/vec3.js').Vec3} cameraForward - The forward vector of the camera.
 */
/**
 * An instance of a {@link Mesh}. A single mesh can be referenced by many mesh instances that can
 * have different transforms and materials.
 *
 * @category Graphics
 */
export class MeshInstance {
    static lightmapParamNames: string[];
    static _prepareRenderStyleForArray(meshInstances: any, renderStyle: any): void;
    /**
     * Create a new MeshInstance instance.
     *
     * @param {import('./mesh.js').Mesh} mesh - The graphics mesh to instance.
     * @param {import('./materials/material.js').Material} material - The material to use for this
     * mesh instance.
     * @param {GraphNode} [node] - The graph node defining the transform for this instance. This
     * parameter is optional when used with {@link RenderComponent} and will use the node the
     * component is attached to.
     * @example
     * // Create a mesh instance pointing to a 1x1x1 'cube' mesh
     * const mesh = pc.Mesh.fromGeometry(app.graphicsDevice, new pc.BoxGeometry());
     * const material = new pc.StandardMaterial();
     *
     * const meshInstance = new pc.MeshInstance(mesh, material);
     *
     * const entity = new pc.Entity();
     * entity.addComponent('render', {
     *     meshInstances: [meshInstance]
     * });
     *
     * // Add the entity to the scene hierarchy
     * this.app.scene.root.addChild(entity);
     */
    constructor(mesh: import('./mesh.js').Mesh, material: import('./materials/material.js').Material, node?: GraphNode);
    /**
     * Enable rendering for this mesh instance. Use visible property to enable/disable
     * rendering without overhead of removing from scene. But note that the mesh instance is
     * still in the hierarchy and still in the draw call list.
     *
     * @type {boolean}
     */
    visible: boolean;
    /**
     * Enable shadow casting for this mesh instance. Use this property to enable/disable
     * shadow casting without overhead of removing from scene. Note that this property does not
     * add the mesh instance to appropriate list of shadow casters on a {@link Layer}, but
     * allows mesh to be skipped from shadow casting while it is in the list already. Defaults to
     * false.
     *
     * @type {boolean}
     */
    castShadow: boolean;
    /**
     * True if the material of the mesh instance is transparent. Optimization to avoid accessing the
     * material. Updated by the material instance itself.
     *
     * @ignore
     */
    transparent: boolean;
    /**
     * @type {import('./materials/material.js').Material|null}
     * @private
     */
    private _material;
    /**
     * An array of shader cache entries, indexed by the shader pass constant (SHADER_FORWARD..). The
     * value stores all shaders and bind groups for the shader pass for various light combinations.
     *
     * @type {Array<ShaderCacheEntry|null>}
     * @private
     */
    private _shaderCache;
    /** @ignore */
    id: number;
    /**
     * True if the mesh instance is pickable by the {@link Picker}. Defaults to true.
     *
     * @type {boolean}
     * @ignore
     */
    pick: boolean;
    _key: number[];
    /**
     * The graph node defining the transform for this instance.
     *
     * @type {GraphNode}
     */
    node: GraphNode;
    _mesh: import("./mesh.js").Mesh;
    /**
     * The material used by this mesh instance.
     *
     * @type {import('./materials/material.js').Material}
     */
    set material(material: import("./materials/material.js").Material);
    get material(): import("./materials/material.js").Material;
    _shaderDefs: number;
    set layer(layer: any);
    get layer(): any;
    /** @private */
    private _renderStyle;
    _receiveShadow: boolean;
    _screenSpace: boolean;
    /**
     * Controls whether the mesh instance can be culled by frustum culling
     * ({@link CameraComponent#frustumCulling}). Defaults to true.
     *
     * @type {boolean}
     */
    cull: boolean;
    _updateAabb: boolean;
    _updateAabbFunc: any;
    _calculateSortDistance: any;
    /**
     * @type {import('./skin-instance.js').SkinInstance|null}
     * @private
     */
    private _skinInstance;
    /**
     * @type {import('./morph-instance.js').MorphInstance|null}
     * @private
     */
    private _morphInstance;
    /**
     * @type {import('./gsplat/gsplat-instance.js').GSplatInstance|null}
     * @ignore
     */
    gsplatInstance: import('./gsplat/gsplat-instance.js').GSplatInstance | null;
    instancingData: InstancingData;
    /**
     * @type {BoundingBox|null}
     * @private
     */
    private _customAabb;
    /**
     * The world space axis-aligned bounding box for this mesh instance.
     *
     * @type {BoundingBox}
     */
    set aabb(aabb: any);
    get aabb(): any;
    _aabbVer: number;
    _aabbMeshVer: number;
    /**
     * Use this value to affect rendering order of mesh instances. Only used when mesh
     * instances are added to a {@link Layer} with {@link Layer#opaqueSortMode} or
     * {@link Layer#transparentSortMode} (depending on the material) set to
     * {@link SORTMODE_MANUAL}.
     *
     * @type {number}
     */
    drawOrder: number;
    /**
     * Read this value in {@link Layer#onPostCull} to determine if the object is actually going
     * to be rendered.
     *
     * @type {boolean}
     */
    visibleThisFrame: boolean;
    isVisibleFunc: any;
    parameters: {};
    stencilFront: any;
    stencilBack: any;
    flipFacesFactor: number;
    /**
     * The render style of the mesh instance. Can be:
     *
     * - {@link RENDERSTYLE_SOLID}
     * - {@link RENDERSTYLE_WIREFRAME}
     * - {@link RENDERSTYLE_POINTS}
     *
     * Defaults to {@link RENDERSTYLE_SOLID}.
     *
     * @type {number}
     */
    set renderStyle(renderStyle: number);
    get renderStyle(): number;
    /**
     * The graphics mesh being instanced.
     *
     * @type {import('./mesh.js').Mesh}
     */
    set mesh(mesh: import("./mesh.js").Mesh);
    get mesh(): import("./mesh.js").Mesh;
    _aabb: any;
    /**
     * Clear the internal shader cache.
     *
     * @ignore
     */
    clearShaders(): void;
    /**
     * Returns the shader instance for the specified shader pass and light hash that is compatible
     * with this mesh instance.
     *
     * @param {number} shaderPass - The shader pass index.
     * @param {number} lightHash - The hash value of the lights that are affecting this mesh instance.
     * @param {import('./scene.js').Scene} scene - The scene.
     * @param {import('../platform/graphics/uniform-buffer-format.js').UniformBufferFormat} [viewUniformFormat] - The
     * format of the view uniform buffer.
     * @param {import('../platform/graphics/bind-group-format.js').BindGroupFormat} [viewBindGroupFormat] - The
     * format of the view bind group.
     * @param {any} [sortedLights] - Array of arrays of lights.
     * @returns {ShaderInstance} - the shader instance.
     * @ignore
     */
    getShaderInstance(shaderPass: number, lightHash: number, scene: import('./scene.js').Scene, viewUniformFormat?: import('../platform/graphics/uniform-buffer-format.js').UniformBufferFormat, viewBindGroupFormat?: import('../platform/graphics/bind-group-format.js').BindGroupFormat, sortedLights?: any): ShaderInstance;
    _layer: any;
    _updateShaderDefs(shaderDefs: any): void;
    /**
     * In some circumstances mesh instances are sorted by a distance calculation to determine their
     * rendering order. Set this callback to override the default distance calculation, which gives
     * the dot product of the camera forward vector and the vector between the camera position and
     * the center of the mesh instance's axis-aligned bounding box. This option can be particularly
     * useful for rendering transparent meshes in a better order than default.
     *
     * @type {CalculateSortDistanceCallback}
     */
    set calculateSortDistance(calculateSortDistance: any);
    get calculateSortDistance(): any;
    set receiveShadow(val: boolean);
    get receiveShadow(): boolean;
    /**
     * The skin instance managing skinning of this mesh instance, or null if skinning is not used.
     *
     * @type {import('./skin-instance.js').SkinInstance}
     */
    set skinInstance(val: import("./skin-instance.js").SkinInstance);
    get skinInstance(): import("./skin-instance.js").SkinInstance;
    /**
     * The morph instance managing morphing of this mesh instance, or null if morphing is not used.
     *
     * @type {import('./morph-instance.js').MorphInstance}
     */
    set morphInstance(val: import("./morph-instance.js").MorphInstance);
    get morphInstance(): import("./morph-instance.js").MorphInstance;
    set screenSpace(val: boolean);
    get screenSpace(): boolean;
    set key(val: number);
    get key(): number;
    /**
     * Mask controlling which {@link LightComponent}s light this mesh instance, which
     * {@link CameraComponent} sees it and in which {@link Layer} it is rendered. Defaults to 1.
     *
     * @type {number}
     */
    set mask(val: number);
    get mask(): number;
    /**
     * Number of instances when using hardware instancing to render the mesh.
     *
     * @type {number}
     */
    set instancingCount(value: number);
    get instancingCount(): number;
    destroy(): void;
    _isVisible(camera: any): any;
    updateKey(): void;
    /**
     * Sets up {@link MeshInstance} to be rendered using Hardware Instancing.
     *
     * @param {import('../platform/graphics/vertex-buffer.js').VertexBuffer|null} vertexBuffer -
     * Vertex buffer to hold per-instance vertex data (usually world matrices). Pass null to turn
     * off hardware instancing.
     * @param {boolean} cull - Whether to perform frustum culling on this instance. If true, the whole
     * instance will be culled by the  camera frustum. This often involves setting
     * {@link RenderComponent#customAabb} containing all instances. Defaults to false, which means
     * the whole instance is always rendered.
     */
    setInstancing(vertexBuffer: import('../platform/graphics/vertex-buffer.js').VertexBuffer | null, cull?: boolean): void;
    ensureMaterial(device: any): void;
    clearParameters(): void;
    getParameters(): {};
    /**
     * Retrieves the specified shader parameter from a mesh instance.
     *
     * @param {string} name - The name of the parameter to query.
     * @returns {object} The named parameter.
     */
    getParameter(name: string): object;
    /**
     * Sets a shader parameter on a mesh instance. Note that this parameter will take precedence
     * over parameter of the same name if set on Material this mesh instance uses for rendering.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|import('../platform/graphics/texture.js').Texture|Float32Array} data - The
     * value for the specified parameter.
     * @param {number} [passFlags] - Mask describing which passes the material should be included
     * in.
     */
    setParameter(name: string, data: number | number[] | import('../platform/graphics/texture.js').Texture | Float32Array, passFlags?: number): void;
    setRealtimeLightmap(name: any, texture: any): void;
    /**
     * Deletes a shader parameter on a mesh instance.
     *
     * @param {string} name - The name of the parameter to delete.
     */
    deleteParameter(name: string): void;
    setParameters(device: any, passFlag: any): void;
    setLightmapped(value: any): void;
    setCustomAabb(aabb: any): void;
    _setupSkinUpdate(): void;
}
import { GraphNode } from './graph-node.js';
/**
 * Internal data structure used to store data used by hardware instancing.
 *
 * @ignore
 */
declare class InstancingData {
    /**
     * @param {number} numObjects - The number of objects instanced.
     */
    constructor(numObjects: number);
    /** @type {import('../platform/graphics/vertex-buffer.js').VertexBuffer|null} */
    vertexBuffer: import('../platform/graphics/vertex-buffer.js').VertexBuffer | null;
    count: number;
}
/**
 * Internal helper class for storing the shader and related mesh bind group in the shader cache.
 *
 * @ignore
 */
declare class ShaderInstance {
    /**
     * A shader.
     *
     * @type {import('../platform/graphics/shader.js').Shader|undefined}
     */
    shader: import('../platform/graphics/shader.js').Shader | undefined;
    /**
     * A bind group storing mesh uniforms for the shader.
     *
     * @type {BindGroup|null}
     */
    bindGroup: BindGroup | null;
    /**
     * Returns the mesh bind group for the shader.
     *
     * @param {import('../platform/graphics/graphics-device.js').GraphicsDevice} device - The
     * graphics device.
     * @returns {BindGroup} - The mesh bind group.
     */
    getBindGroup(device: import('../platform/graphics/graphics-device.js').GraphicsDevice): BindGroup;
    destroy(): void;
}
import { BindGroup } from '../platform/graphics/bind-group.js';
export {};
