/** @ignore */
export class GSplat {
    /**
     * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The graphics device.
     * @param {import('./gsplat-data.js').GSplatData} gsplatData - The splat data.
     */
    constructor(device: import('../../platform/graphics/graphics-device.js').GraphicsDevice, gsplatData: import('./gsplat-data.js').GSplatData);
    device: import("../../platform/graphics/graphics-device.js").GraphicsDevice;
    numSplats: any;
    /** @type {Float32Array} */
    centers: Float32Array;
    /** @type {import('../../core/shape/bounding-box.js').BoundingBox} */
    aabb: import('../../core/shape/bounding-box.js').BoundingBox;
    /** @type {Texture} */
    colorTexture: Texture;
    /** @type {Texture} */
    transformATexture: Texture;
    /** @type {Texture} */
    transformBTexture: Texture;
    /** @type {Texture} */
    transformCTexture: Texture;
    destroy(): void;
    /**
     * @returns {import('../materials/material.js').Material} material - The material to set up for
     * the splat rendering.
     */
    createMaterial(options: any): import('../materials/material.js').Material;
    /**
     * Evaluates the texture size needed to store a given number of elements.
     * The function calculates a width and height that is close to a square
     * that can contain 'count' elements.
     *
     * @param {number} count - The number of elements to store in the texture.
     * @returns {Vec2} An instance of Vec2 representing the width and height of the texture.
     */
    evalTextureSize(count: number): Vec2;
    /**
     * Creates a new texture with the specified parameters.
     *
     * @param {string} name - The name of the texture to be created.
     * @param {number} format - The pixel format of the texture.
     * @param {Vec2} size - The size of the texture in a Vec2 object, containing width (x) and height (y).
     * @returns {Texture} The created texture instance.
     */
    createTexture(name: string, format: number, size: Vec2): Texture;
    /**
     * Gets the most suitable texture format based on device capabilities.
     *
     * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The graphics device.
     * @param {boolean} preferHighPrecision - True to prefer high precision when available.
     * @returns {boolean|undefined} True if half format should be used, false is float format should
     * be used or undefined if none are available.
     */
    getTextureFormat(device: import('../../platform/graphics/graphics-device.js').GraphicsDevice, preferHighPrecision: boolean): boolean | undefined;
    /**
     * Updates pixel data of this.colorTexture based on the supplied color components and opacity.
     * Assumes that the texture is using an RGBA format where RGB are color components influenced
     * by SH spherical harmonics and A is opacity after a sigmoid transformation.
     *
     * @param {import('./gsplat-data.js').GSplatData} gsplatData - The source data
     */
    updateColorData(gsplatData: import('./gsplat-data.js').GSplatData): void;
    /**
     * @param {import('./gsplat-data.js').GSplatData} gsplatData - The source data
     */
    updateTransformData(gsplatData: import('./gsplat-data.js').GSplatData): void;
    /**
     * Evaluate the covariance values based on the rotation and scale.
     *
     * @param {Mat3} rot - The rotation matrix.
     * @param {Vec3} scale - The scale.
     * @param {Vec3} covA - The first covariance vector.
     * @param {Vec3} covB - The second covariance vector.
     */
    computeCov3d(rot: Mat3, scale: Vec3, covA: Vec3, covB: Vec3): void;
}
import { Texture } from '../../platform/graphics/texture.js';
import { Vec2 } from '../../core/math/vec2.js';
import { Mat3 } from '../../core/math/mat3.js';
import { Vec3 } from '../../core/math/vec3.js';
