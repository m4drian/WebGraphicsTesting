/**
 * The Light Component enables the Entity to light the scene. There are three types of light:
 * directional, omni and spot. Directional lights are global in that they are considered to be
 * infinitely far away and light the entire scene. Omni and spot lights are local in that they have
 * a position and a range. A spot light is a specialization of an omni light where light is emitted
 * in a cone rather than in all directions. Lights also have the ability to cast shadows to add
 * realism to your scenes.
 *
 * ```javascript
 * // Add a pc.LightComponent to an entity
 * const entity = new pc.Entity();
 * entity.addComponent('light', {
 *     type: "omni",
 *     color: new pc.Color(1, 0, 0),
 *     range: 10
 * });
 *
 * // Get the pc.LightComponent on an entity
 * const lightComponent = entity.light;
 *
 * // Update a property on a light component
 * entity.light.range = 20;
 * ```
 *
 * @category Graphics
 */
export class LightComponent extends Component {
    /**
     * Creates a new LightComponent instance.
     *
     * @param {import('./system.js').LightComponentSystem} system - The ComponentSystem that
     * created this Component.
     * @param {import('../../entity.js').Entity} entity - The Entity that this Component is
     * attached to.
     */
    constructor(system: import('./system.js').LightComponentSystem, entity: import('../../entity.js').Entity);
    _cookieAsset: any;
    _cookieAssetId: any;
    _cookieAssetAdd: boolean;
    _cookieMatrix: any;
    /**
     * @type {import('./data.js').LightComponentData}
     * @ignore
     */
    get data(): import("./data.js").LightComponentData;
    /**
     * @type {import('../../../scene/light.js').Light}
     * @ignore
     */
    set light(arg: import("../../../scene/light.js").Light);
    get light(): import("../../../scene/light.js").Light;
    /**
     * The type of light. Can be:
     *
     * - "directional": A light that is infinitely far away and lights the entire scene from one
     * direction.
     * - "omni": An omni-directional light that illuminates in all directions from the light source.
     * - "spot": An omni-directional light but is bounded by a cone.
     * Defaults to "directional".
     *
     * @type {string}
     */
    set type(arg: string);
    get type(): string;
    /**
     * The Color of the light. The alpha component of the color is ignored.
     * Defaults to white (1, 1, 1).
     *
     * @type {import('../../../core/math/color.js').Color};
     */
    set color(arg: import("../../../core/math/color.js").Color);
    get color(): import("../../../core/math/color.js").Color;
    /**
     * The brightness of the light. Defaults to 1.
     *
     * @type {number}
     */
    set intensity(arg: number);
    get intensity(): number;
    /**
     * The physically based luminance. Only used if scene.physicalUnits is true. Defaults to 0.
     *
     * @type {number}
     */
    set luminance(arg: number);
    get luminance(): number;
    /**
     * The light source shape. Can be:
     *
     * - {@link LIGHTSHAPE_PUNCTUAL}: Infinitesimally small point.
     * - {@link LIGHTSHAPE_RECT}: Rectangle shape.
     * - {@link LIGHTSHAPE_DISK}: Disk shape.
     * - {@link LIGHTSHAPE_SPHERE}: Sphere shape.
     *
     * Defaults to pc.LIGHTSHAPE_PUNCTUAL.
     *
     * @type {number}
     */
    set shape(arg: number);
    get shape(): number;
    /**
     * If enabled, material specularity will be affected by this light.
     * Ignored for lights other than {@link LIGHTTYPE_DIRECTIONAL}. Defaults to true.
     *
     * @type {boolean}
     */
    set affectSpecularity(arg: boolean);
    get affectSpecularity(): boolean;
    /**
     * If enabled the light will cast shadows. Defaults to false.
     *
     * @type {boolean}
     */
    set castShadows(arg: boolean);
    get castShadows(): boolean;
    /**
     * The distance from the viewpoint beyond which shadows are no
     * longer rendered. Affects directional lights only. Defaults to 40.
     *
     * @type {number}
     */
    set shadowDistance(arg: number);
    get shadowDistance(): number;
    /**
     * The intensity of the shadow darkening, 1 being shadows are entirely black.
     * Defaults to 1.
     *
     * @type {number}
     */
    set shadowIntensity(arg: number);
    get shadowIntensity(): number;
    /**
     * The size of the texture used for the shadow map. Valid sizes
     * are 64, 128, 256, 512, 1024, 2048. Defaults to 1024.
     *
     * @type {number}
     */
    set shadowResolution(arg: number);
    get shadowResolution(): number;
    /**
     * The depth bias for tuning the appearance of the shadow mapping generated by this light. Valid
     * range is 0 to 1. Defaults to 0.05.
     *
     * @type {number}
     */
    set shadowBias(arg: number);
    get shadowBias(): number;
    /**
     * Number of shadow cascades. Can be 1, 2, 3 or 4. Defaults to 1,
     * representing no cascades.
     *
     * @type {number}
     */
    set numCascades(arg: number);
    get numCascades(): number;
    /**
     * If bake is true, this specifies the number of samples used to
     * bake this light into the lightmap. Defaults to 1. Maximum value is 255.
     *
     * @type {number}
     */
    set bakeNumSamples(arg: number);
    get bakeNumSamples(): number;
    /**
     * If bake is true and the light type is {@link LIGHTTYPE_DIRECTIONAL},
     * this specifies the penumbra angle in degrees, allowing a soft shadow boundary. Defaults to 0.
     *
     * @type {number}
     */
    set bakeArea(arg: number);
    get bakeArea(): number;
    /**
     * The distribution of subdivision of the camera frustum for individual shadow cascades.
     * Only used if {@link LightComponent#numCascades} is larger than 1.
     * Can be a value in range of 0 and 1. Value of 0 represents a linear distribution, value of 1
     * represents a logarithmic distribution. Defaults to 0.5. Larger value increases the resolution of
     * the shadows in the near distance.
     *
     * @type {number}
     */
    set cascadeDistribution(arg: number);
    get cascadeDistribution(): number;
    /**
     * Normal offset depth bias. Valid range is 0 to 1. Defaults to 0.
     *
     * @type {number}
     */
    set normalOffsetBias(arg: number);
    get normalOffsetBias(): number;
    /**
     * The range of the light. Affects omni and spot lights only. Defaults to 10.
     *
     * @type {number}
     */
    set range(arg: number);
    get range(): number;
    /**
     * The angle at which the spotlight cone starts to fade off. The
     * angle is specified in degrees. Affects spot lights only. Defaults to 40.
     *
     * @type {number}
     */
    set innerConeAngle(arg: number);
    get innerConeAngle(): number;
    /**
     * The angle at which the spotlight cone has faded to nothing.
     * The angle is specified in degrees. Affects spot lights only. Defaults to 45.
     *
     * @type {number}
     */
    set outerConeAngle(arg: number);
    get outerConeAngle(): number;
    /**
     * Controls the rate at which a light attenuates from its position. Can be:
     *
     * - {@link LIGHTFALLOFF_LINEAR}: Linear.
     * - {@link LIGHTFALLOFF_INVERSESQUARED}: Inverse squared.
     *
     * Affects omni and spot lights only. Defaults to {@link LIGHTFALLOFF_LINEAR}.
     *
     * @type {number}
     */
    set falloffMode(arg: number);
    get falloffMode(): number;
    /**
     * Type of shadows being rendered by this light. Options:
     *
     * - {@link SHADOW_PCF3}: Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3
     * sampling.
     * - {@link SHADOW_VSM8}: Render packed variance shadow map. All shadow receivers must also cast
     * shadows for this mode to work correctly.
     * - {@link SHADOW_VSM16}: Render 16-bit exponential variance shadow map. Requires
     * OES_texture_half_float extension. Falls back to {@link SHADOW_VSM8}, if not supported.
     * - {@link SHADOW_VSM32}: Render 32-bit exponential variance shadow map. Requires
     * OES_texture_float extension. Falls back to {@link SHADOW_VSM16}, if not supported.
     * - {@link SHADOW_PCF5}: Render depth buffer only, can be used for hardware-accelerated PCF 5x5
     * sampling. Requires WebGL2. Falls back to {@link SHADOW_PCF3} on WebGL 1.0.
     * - {@link SHADOW_PCSS}: Render depth as color, and use the software sampled PCSS method for shadows.
     *
     * @type {number}
     */
    set shadowType(arg: number);
    get shadowType(): number;
    /**
     * Number of samples used for blurring a variance shadow map. Only uneven numbers work,
     * even are incremented. Minimum value is 1, maximum is 25. Defaults to 11.
     *
     * @type {number}
     */
    set vsmBlurSize(arg: number);
    get vsmBlurSize(): number;
    /**
     * Blurring mode for variance shadow maps. Can be:
     *
     * - {@link BLUR_BOX}: Box filter.
     * - {@link BLUR_GAUSSIAN}: Gaussian filter. May look smoother than box, but requires more samples.
     *
     * @type {number}
     */
    set vsmBlurMode(arg: number);
    get vsmBlurMode(): number;
    /**
     * TODO:
     *
     * @type {number}
     */
    set vsmBias(arg: number);
    get vsmBias(): number;
    /**
     * Asset that has texture that will be assigned to cookie internally
     * once asset resource is available.
     *
     * @type {number|null}
     */
    set cookieAsset(arg: any);
    get cookieAsset(): any;
    /**
     * Projection texture. Must be 2D for spot and cubemap for omni light
     * (ignored if incorrect type is used).
     *
     * @type {import('../../../platform/graphics/texture.js').Texture|null}
     */
    set cookie(arg: any);
    get cookie(): any;
    /**
     * Projection texture intensity (default is 1).
     *
     * @type {number}
     */
    set cookieIntensity(arg: number);
    get cookieIntensity(): number;
    /**
     * Toggle normal spotlight falloff when projection texture is used. When set to false,
     * spotlight will work like a pure texture projector (only fading with
     * distance). Default is false.
     *
     * @type {boolean}
     */
    set cookieFalloff(arg: boolean);
    get cookieFalloff(): boolean;
    /**
     * Color channels of the projection texture to use. Can be "r", "g", "b", "a", "rgb".
     *
     * @type {string}
     */
    set cookieChannel(arg: string);
    get cookieChannel(): string;
    /**
     * Angle for spotlight cookie rotation.
     *
     * @type {number}
     */
    set cookieAngle(arg: number);
    get cookieAngle(): number;
    /**
     * Spotlight cookie scale.
     *
     * @type {import('../../../core/math/vec2.js').Vec2|null}
     */
    set cookieScale(arg: any);
    get cookieScale(): any;
    /**
     * Spotlight cookie position offset.
     *
     * @type {import('../../../core/math/vec2.js').Vec2}
     */
    set cookieOffset(arg: any);
    get cookieOffset(): any;
    /**
     * Tells the renderer how often shadows must be updated for
     * this light. Can be:
     *
     * - {@link SHADOWUPDATE_NONE}: Don't render shadows.
     * - {@link SHADOWUPDATE_THISFRAME}: Render shadows only once (then automatically switches
     * to {@link SHADOWUPDATE_NONE}.
     * - {@link SHADOWUPDATE_REALTIME}: Render shadows every frame (default).
     *
     * @type {number}
     */
    set shadowUpdateMode(arg: number);
    get shadowUpdateMode(): number;
    /**
     * Defines a mask to determine which {@link MeshInstance}s are lit by this
     * light. Defaults to 1.
     *
     * @type {number}
     */
    set mask(arg: number);
    get mask(): number;
    /**
     * If enabled the light will affect non-lightmapped objects.
     *
     * @type {boolean}
     */
    set affectDynamic(arg: boolean);
    get affectDynamic(): boolean;
    /**
     * If enabled the light will affect lightmapped objects.
     *
     * @type {boolean}
     */
    set affectLightmapped(arg: boolean);
    get affectLightmapped(): boolean;
    /**
     * If enabled the light will be rendered into lightmaps.
     *
     * @type {boolean}
     */
    set bake(arg: boolean);
    get bake(): boolean;
    /**
     * If enabled and bake=true, the light's direction will contribute to
     * directional lightmaps. Be aware, that directional lightmap is an approximation and can only hold
     * single direction per pixel. Intersecting multiple lights with bakeDir=true may lead to incorrect
     * look of specular/bump-mapping in the area of intersection. The error is not always visible
     * though, and highly scene-dependent.
     *
     * @type {boolean}
     */
    set bakeDir(arg: boolean);
    get bakeDir(): boolean;
    /**
     * Mark light as non-movable (optimization).
     *
     * @type {boolean}
     */
    set isStatic(arg: boolean);
    get isStatic(): boolean;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this light should
     * belong. Don't push/pop/splice or modify this array, if you want to change it - set a new one
     * instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * Returns an array of SHADOWUPDATE_ settings per shadow cascade, or undefined if not used.
     *
     * @type {number[] | null}
     */
    set shadowUpdateOverrides(values: any);
    get shadowUpdateOverrides(): any;
    /**
     * Size of penumbra for contact hardening shadows. For area lights acts as a multiplier with
     * the dimensions of the area light. For punctual and directional lights
     * it's the area size of the light. Defaults to 1.0.
     *
     * @type {number}
     */
    set penumbraSize(value: number);
    get penumbraSize(): number;
    /** @ignore */
    _setValue(name: any, value: any, setFunc: any, skipEqualsCheck: any): void;
    addLightToLayers(): void;
    removeLightFromLayers(): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    refreshProperties(): void;
    onCookieAssetSet(): void;
    onCookieAssetAdd(asset: any): void;
    onCookieAssetLoad(): void;
    onCookieAssetRemove(): void;
    onRemove(): void;
}
import { Component } from '../component.js';
