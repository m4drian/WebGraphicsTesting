/**
 * ElementComponents are used to construct user interfaces. An ElementComponent's [type](#type)
 * property can be configured in 3 main ways: as a text element, as an image element or as a group
 * element. If the ElementComponent has a {@link ScreenComponent} ancestor in the hierarchy, it
 * will be transformed with respect to the coordinate system of the screen. If there is no
 * {@link ScreenComponent} ancestor, the ElementComponent will be transformed like any other
 * entity.
 *
 * You should never need to use the ElementComponent constructor. To add an ElementComponent to a
 * {@link Entity}, use {@link Entity#addComponent}:
 *
 * ```javascript
 * // Add an element component to an entity with the default options
 * let entity = pc.Entity();
 * entity.addComponent("element"); // This defaults to a 'group' element
 * ```
 *
 * To create a simple text-based element:
 *
 * ```javascript
 * entity.addComponent("element", {
 *     anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5), // centered anchor
 *     fontAsset: fontAsset,
 *     fontSize: 128,
 *     pivot: new pc.Vec2(0.5, 0.5),            // centered pivot
 *     text: "Hello World!",
 *     type: pc.ELEMENTTYPE_TEXT
 * });
 * ```
 *
 * Once the ElementComponent is added to the entity, you can set and get any of its properties:
 *
 * ```javascript
 * entity.element.color = pc.Color.RED; // Set the element's color to red
 *
 * console.log(entity.element.color);   // Get the element's color and print it
 * ```
 *
 * Relevant 'Engine-only' examples:
 * - [Basic text rendering](https://playcanvas.github.io/#/user-interface/text)
 * - [Auto font sizing](https://playcanvas.github.io/#/user-interface/text-auto-font-size)
 * - [Emojis](https://playcanvas.github.io/#/user-interface/text-emojis)
 * - [Text localization](https://playcanvas.github.io/#/user-interface/text-localization)
 * - [Typewriter text](https://playcanvas.github.io/#/user-interface/text-typewriter)
 *
 * @category User Interface
 */
export class ElementComponent extends Component {
    /**
     * Fired when the mouse is pressed while the cursor is on the component. Only fired when
     * useInput is true. The handler is passed an {@link ElementMouseEvent}.
     *
     * @event
     * @example
     * entity.element.on('mousedown', (event) => {
     *     console.log(`Mouse down event on entity ${entity.name}`);
     * });
     */
    static EVENT_MOUSEDOWN: string;
    /**
     * Fired when the mouse is released while the cursor is on the component. Only fired when
     * useInput is true. The handler is passed an {@link ElementMouseEvent}.
     *
     * @event
     * @example
     * entity.element.on('mouseup', (event) => {
     *     console.log(`Mouse up event on entity ${entity.name}`);
     * });
     */
    static EVENT_MOUSEUP: string;
    /**
     * Fired when the mouse cursor enters the component. Only fired when useInput is true. The
     * handler is passed an {@link ElementMouseEvent}.
     *
     * @event
     * @example
     * entity.element.on('mouseenter', (event) => {
     *     console.log(`Mouse enter event on entity ${entity.name}`);
     * });
     */
    static EVENT_MOUSEENTER: string;
    /**
     * Fired when the mouse cursor leaves the component. Only fired when useInput is true. The
     * handler is passed an {@link ElementMouseEvent}.
     *
     * @event
     * @example
     * entity.element.on('mouseleave', (event) => {
     *     console.log(`Mouse leave event on entity ${entity.name}`);
     * });
     */
    static EVENT_MOUSELEAVE: string;
    /**
     * Fired when the mouse cursor is moved on the component. Only fired when useInput is true. The
     * handler is passed an {@link ElementMouseEvent}.
     *
     * @event
     * @example
     * entity.element.on('mousemove', (event) => {
     *     console.log(`Mouse move event on entity ${entity.name}`);
     * });
     */
    static EVENT_MOUSEMOVE: string;
    /**
     * Fired when the mouse wheel is scrolled on the component. Only fired when useInput is true.
     * The handler is passed an {@link ElementMouseEvent}.
     *
     * @event
     * @example
     * entity.element.on('mousewheel', (event) => {
     *     console.log(`Mouse wheel event on entity ${entity.name}`);
     * });
     */
    static EVENT_MOUSEWHEEL: string;
    /**
     * Fired when the mouse is pressed and released on the component or when a touch starts and
     * ends on the component. Only fired when useInput is true. The handler is passed an
     * {@link ElementMouseEvent} or {@link ElementTouchEvent}.
     *
     * @event
     * @example
     * entity.element.on('click', (event) => {
     *     console.log(`Click event on entity ${entity.name}`);
     * });
     */
    static EVENT_CLICK: string;
    /**
     * Fired when a touch starts on the component. Only fired when useInput is true. The handler is
     * passed an {@link ElementTouchEvent}.
     *
     * @event
     * @example
     * entity.element.on('touchstart', (event) => {
     *     console.log(`Touch start event on entity ${entity.name}`);
     * });
     */
    static EVENT_TOUCHSTART: string;
    /**
     * Fired when a touch ends on the component. Only fired when useInput is true. The handler is
     * passed an {@link ElementTouchEvent}.
     *
     * @event
     * @example
     * entity.element.on('touchend', (event) => {
     *     console.log(`Touch end event on entity ${entity.name}`);
     * });
     */
    static EVENT_TOUCHEND: string;
    /**
     * Fired when a touch moves after it started touching the component. Only fired when useInput
     * is true. The handler is passed an {@link ElementTouchEvent}.
     *
     * @event
     * @example
     * entity.element.on('touchmove', (event) => {
     *     console.log(`Touch move event on entity ${entity.name}`);
     * });
     */
    static EVENT_TOUCHMOVE: string;
    /**
     * Fired when a touch is canceled on the component. Only fired when useInput is true. The
     * handler is passed an {@link ElementTouchEvent}.
     *
     * @event
     * @example
     * entity.element.on('touchcancel', (event) => {
     *     console.log(`Touch cancel event on entity ${entity.name}`);
     * });
     */
    static EVENT_TOUCHCANCEL: string;
    /**
     * Create a new ElementComponent instance.
     *
     * @param {import('./system.js').ElementComponentSystem} system - The ComponentSystem that
     * created this Component.
     * @param {Entity} entity - The Entity that this Component is attached to.
     */
    constructor(system: import('./system.js').ElementComponentSystem, entity: Entity);
    _beingInitialized: boolean;
    _anchor: Vec4;
    _localAnchor: Vec4;
    _pivot: Vec2;
    _width: number;
    _calculatedWidth: number;
    _height: number;
    _calculatedHeight: number;
    _margin: Vec4;
    _modelTransform: Mat4;
    _screenToWorld: Mat4;
    _anchorTransform: Mat4;
    _anchorDirty: boolean;
    _parentWorldTransform: Mat4;
    _screenTransform: Mat4;
    _screenCorners: Vec3[];
    _canvasCorners: Vec2[];
    _worldCorners: Vec3[];
    _cornersDirty: boolean;
    _canvasCornersDirty: boolean;
    _worldCornersDirty: boolean;
    /**
     * The Entity with a {@link ScreenComponent} that this component belongs to. This is
     * automatically set when the component is a child of a ScreenComponent.
     *
     * @type {Entity|null}
     */
    screen: Entity | null;
    _type: string;
    _image: ImageElement;
    _text: TextElement;
    _group: any;
    _drawOrder: number;
    _fitMode: string;
    _useInput: boolean;
    _layers: number[];
    _addedModels: any[];
    _batchGroupId: number;
    _batchGroup: any;
    _offsetReadAt: number;
    _maskOffset: number;
    _maskedBy: any;
    /**
     * @type {import('./data.js').ElementComponentData}
     * @ignore
     */
    get data(): import("./data.js").ElementComponentData;
    /**
     * @type {number}
     * @private
     */
    private get _absLeft();
    /**
     * @type {number}
     * @private
     */
    private get _absRight();
    /**
     * @type {number}
     * @private
     */
    private get _absTop();
    /**
     * @type {number}
     * @private
     */
    private get _absBottom();
    /**
     * @type {boolean}
     * @private
     */
    private get _hasSplitAnchorsX();
    /**
     * @type {boolean}
     * @private
     */
    private get _hasSplitAnchorsY();
    /**
     * @type {import('../../../core/shape/bounding-box.js').BoundingBox | null}
     */
    get aabb(): import("../../../core/shape/bounding-box.js").BoundingBox;
    /**
     * Specifies where the left, bottom, right and top edges of the component are anchored relative
     * to its parent. Each value ranges from 0 to 1. e.g. a value of [0, 0, 0, 0] means that the
     * element will be anchored to the bottom left of its parent. A value of [1, 1, 1, 1] means it
     * will be anchored to the top right. A split anchor is when the left-right or top-bottom pairs
     * of the anchor are not equal. In that case the component will be resized to cover that entire
     * area. e.g. a value of [0, 0, 1, 1] will make the component resize exactly as its parent.
     *
     * @example
     * pc.app.root.findByName("Inventory").element.anchor = new pc.Vec4(Math.random() * 0.1, 0, 1, 0);
     * @example
     * pc.app.root.findByName("Inventory").element.anchor = [Math.random() * 0.1, 0, 1, 0];
     *
     * @type {Vec4 | number[]}
     */
    set anchor(value: Vec4);
    get anchor(): Vec4;
    /**
     * Assign element to a specific batch group (see {@link BatchGroup}). Default is -1 (no group).
     *
     * @type {number}
     */
    set batchGroupId(value: number);
    get batchGroupId(): number;
    /**
     * The distance from the bottom edge of the anchor. Can be used in combination with a split
     * anchor to make the component's top edge always be 'top' units away from the top.
     *
     * @type {number}
     */
    set bottom(value: number);
    get bottom(): number;
    /**
     * The width at which the element will be rendered. In most cases this will be the same as
     * `width`. However, in some cases the engine may calculate a different width for the element,
     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these
     * scenarios, `calculatedWidth` may be smaller or larger than the width that was set in the
     * editor.
     *
     * @type {number}
     */
    set calculatedWidth(value: number);
    get calculatedWidth(): number;
    /**
     * The height at which the element will be rendered. In most cases this will be the same as
     * `height`. However, in some cases the engine may calculate a different height for the element,
     * such as when the element is under the control of a {@link LayoutGroupComponent}. In these
     * scenarios, `calculatedHeight` may be smaller or larger than the height that was set in the
     * editor.
     *
     * @type {number}
     */
    set calculatedHeight(value: number);
    get calculatedHeight(): number;
    /**
     * An array of 4 {@link Vec2}s that represent the bottom left, bottom right, top right and top
     * left corners of the component in canvas pixels. Only works for screen space element
     * components.
     *
     * @type {Vec2[]}
     */
    get canvasCorners(): Vec2[];
    /**
     * The draw order of the component. A higher value means that the component will be rendered on
     * top of other components.
     *
     * @type {number}
     */
    set drawOrder(value: number);
    get drawOrder(): number;
    /**
     * The height of the element as set in the editor. Note that in some cases this may not reflect
     * the true height at which the element is rendered, such as when the element is under the
     * control of a {@link LayoutGroupComponent}. See `calculatedHeight` in order to ensure you are
     * reading the true height at which the element will be rendered.
     *
     * @type {number}
     */
    set height(value: number);
    get height(): number;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this element should belong. Don't push,
     * pop, splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(value: number[]);
    get layers(): number[];
    /**
     * The distance from the left edge of the anchor. Can be used in combination with a split
     * anchor to make the component's left edge always be 'left' units away from the left.
     *
     * @type {number}
     */
    set left(value: number);
    get left(): number;
    /**
     * The distance from the left, bottom, right and top edges of the anchor. For example if we are
     * using a split anchor like [0,0,1,1] and the margin is [0,0,0,0] then the component will be
     * the same width and height as its parent.
     *
     * @type {Vec4}
     */
    set margin(value: Vec4);
    get margin(): Vec4;
    /**
     * Get the entity that is currently masking this element.
     *
     * @type {Entity}
     * @private
     */
    private get maskedBy();
    /**
     * The position of the pivot of the component relative to its anchor. Each value ranges from 0
     * to 1 where [0,0] is the bottom left and [1,1] is the top right.
     *
     * @example
     * pc.app.root.findByName("Inventory").element.pivot = [Math.random() * 0.1, Math.random() * 0.1];
     * @example
     * pc.app.root.findByName("Inventory").element.pivot = new pc.Vec2(Math.random() * 0.1, Math.random() * 0.1);
     *
     * @type {Vec2 | number[]}
     */
    set pivot(value: Vec2);
    get pivot(): Vec2;
    /**
     * The distance from the right edge of the anchor. Can be used in combination with a split
     * anchor to make the component's right edge always be 'right' units away from the right.
     *
     * @type {number}
     */
    set right(value: number);
    get right(): number;
    /**
     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top
     * left corners of the component relative to its parent {@link ScreenComponent}.
     *
     * @type {Vec3[]}
     */
    get screenCorners(): Vec3[];
    /**
     * The width of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    get textWidth(): number;
    /**
     * The height of the text rendered by the component. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    get textHeight(): number;
    /**
     * The distance from the top edge of the anchor. Can be used in combination with a split anchor
     * to make the component's bottom edge always be 'bottom' units away from the bottom.
     *
     * @type {number}
     */
    set top(value: number);
    get top(): number;
    /**
     * The type of the ElementComponent. Can be:
     *
     * - {@link ELEMENTTYPE_GROUP}: The component can be used as a layout mechanism to create groups of
     * ElementComponents e.g. panels.
     * - {@link ELEMENTTYPE_IMAGE}: The component will render an image
     * - {@link ELEMENTTYPE_TEXT}: The component will render text
     *
     * @type {string}
     */
    set type(value: string);
    get type(): string;
    /**
     * If true then the component will receive Mouse or Touch input events.
     *
     * @type {boolean}
     */
    set useInput(value: boolean);
    get useInput(): boolean;
    /**
     * Set how the content should be fitted and preserve the aspect ratio of the source texture or sprite.
     * Only works for {@link ELEMENTTYPE_IMAGE} types. Can be:
     *
     * - {@link FITMODE_STRETCH}: Fit the content exactly to Element's bounding box.
     * - {@link FITMODE_CONTAIN}: Fit the content within the Element's bounding box while preserving its Aspect Ratio.
     * - {@link FITMODE_COVER}: Fit the content to cover the entire Element's bounding box while preserving its Aspect Ratio.
     *
     * @type {string}
     */
    set fitMode(value: string);
    get fitMode(): string;
    /**
     * The width of the element as set in the editor. Note that in some cases this may not reflect
     * the true width at which the element is rendered, such as when the element is under the
     * control of a {@link LayoutGroupComponent}. See `calculatedWidth` in order to ensure you are
     * reading the true width at which the element will be rendered.
     *
     * @type {number}
     */
    set width(value: number);
    get width(): number;
    /**
     * An array of 4 {@link Vec3}s that represent the bottom left, bottom right, top right and top
     * left corners of the component in world space. Only works for 3D element components.
     *
     * @type {Vec3[]}
     */
    get worldCorners(): Vec3[];
    /**
     * The size of the font. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set fontSize(arg: number);
    get fontSize(): number;
    /**
     * The minimum size that the font can scale to when autoFitWidth or autoFitHeight are true.
     *
     * @type {number}
     */
    set minFontSize(arg: number);
    get minFontSize(): number;
    /**
     * The maximum size that the font can scale to when autoFitWidth or autoFitHeight are true.
     *
     * @type {number}
     */
    set maxFontSize(arg: number);
    get maxFontSize(): number;
    /**
     * The maximum number of lines that the Element can wrap to. Any leftover text will be appended
     * to the last line. Set this to null to allow unlimited lines.
     *
     * @type {number}
     */
    set maxLines(arg: number);
    get maxLines(): number;
    /**
     * When true the font size and line height will scale so that the text fits inside the width of
     * the Element. The font size will be scaled between minFontSize and maxFontSize. The value of
     * autoFitWidth will be ignored if autoWidth is true.
     *
     * @type {boolean}
     */
    set autoFitWidth(arg: boolean);
    get autoFitWidth(): boolean;
    /**
     * When true the font size and line height will scale so that the text fits inside the height of
     * the Element. The font size will be scaled between minFontSize and maxFontSize. The value of
     * autoFitHeight will be ignored if autoHeight is true.
     *
     * @type {boolean}
     */
    set autoFitHeight(arg: boolean);
    get autoFitHeight(): boolean;
    /**
     * The color of the image for {@link ELEMENTTYPE_IMAGE} types or the color of the text for
     * {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {import('../../../core/math/color.js').Color}
     */
    set color(arg: import("../../../core/math/color.js").Color);
    get color(): import("../../../core/math/color.js").Color;
    /**
     * The font used for rendering the text. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {import('../../../framework/font/font.js').Font | import('../../../framework/font/canvas-font.js').CanvasFont}
     */
    set font(arg: import("../../../framework/font/font.js").Font | import("../../../framework/font/canvas-font.js").CanvasFont);
    get font(): import("../../../framework/font/font.js").Font | import("../../../framework/font/canvas-font.js").CanvasFont;
    /**
     * The id of the font asset used for rendering the text. Only works for {@link ELEMENTTYPE_TEXT}
     * types.
     *
     * @type {number}
     */
    set fontAsset(arg: number);
    get fontAsset(): number;
    /**
     * The spacing between the letters of the text. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set spacing(arg: number);
    get spacing(): number;
    /**
     * The height of each line of text. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set lineHeight(arg: number);
    get lineHeight(): number;
    /**
     * Whether to automatically wrap lines based on the element width. Only works for
     * {@link ELEMENTTYPE_TEXT} types, and when autoWidth is set to false.
     *
     * @type {boolean}
     */
    set wrapLines(arg: boolean);
    get wrapLines(): boolean;
    /**
     * @type {any}
     * @ignore
     */
    set lines(arg: any[]);
    /**
     * @ignore
     */
    get lines(): any[];
    /**
     * The horizontal and vertical alignment of the text. Values range from 0 to 1 where [0,0] is
     * the bottom left and [1,1] is the top right.  Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {Vec2}
     */
    set alignment(arg: Vec2);
    get alignment(): Vec2;
    /**
     * Automatically set the width of the component to be the same as the textWidth. Only works for
     * {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {boolean}
     */
    set autoWidth(arg: boolean);
    get autoWidth(): boolean;
    /**
     * Automatically set the height of the component to be the same as the textHeight. Only works
     * for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {boolean}
     */
    set autoHeight(arg: boolean);
    get autoHeight(): boolean;
    /**
     * Reorder the text for RTL languages using a function registered by
     * `app.systems.element.registerUnicodeConverter`.
     *
     * @type {boolean}
     */
    set rtlReorder(arg: boolean);
    get rtlReorder(): boolean;
    /**
     * Convert unicode characters using a function registered by `app.systems.element.registerUnicodeConverter`.
     *
     * @type {boolean}
     */
    set unicodeConverter(arg: boolean);
    get unicodeConverter(): boolean;
    /**
     * The text to render. Only works for {@link ELEMENTTYPE_TEXT} types. To
     * override certain text styling properties on a per-character basis, the text can optionally
     * include markup tags contained within square brackets. Supported tags are:
     *
     * 1. `color` - override the element's `color` property. Examples:
     * - `[color="#ff0000"]red text[/color]`
     * - `[color="#00ff00"]green text[/color]`
     * - `[color="#0000ff"]blue text[/color]`
     * 2. `outline` - override the element's `outlineColor` and `outlineThickness` properties. Example:
     * - `[outline color="#ffffff" thickness="0.5"]text[/outline]`
     * 3. `shadow` - override the element's `shadowColor` and `shadowOffset` properties. Examples:
     * - `[shadow color="#ffffff" offset="0.5"]text[/shadow]`
     * - `[shadow color="#000000" offsetX="0.1" offsetY="0.2"]text[/shadow]`
     *
     * Note that markup tags are only processed if the text element's `enableMarkup` property is set to
     * true.
     *
     * @type {string}
     */
    set text(arg: string);
    get text(): string;
    /**
     * The localization key to use to get the localized text from {@link Application#i18n}. Only
     * works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {string}
     */
    set key(arg: string);
    get key(): string;
    /**
     * The texture to render. Only works for {@link ELEMENTTYPE_IMAGE} types.
     *
     * @type {import('../../../platform/graphics/texture.js').Texture}
     */
    set texture(arg: import("../../../platform/graphics/texture.js").Texture);
    get texture(): import("../../../platform/graphics/texture.js").Texture;
    /**
     * The id of the texture asset to render. Only works for {@link ELEMENTTYPE_IMAGE} types.
     *
     * @type {number}
     */
    set textureAsset(arg: number);
    get textureAsset(): number;
    /**
     * The material to use when rendering an image. Only works for {@link ELEMENTTYPE_IMAGE} types.
     *
     * @type {import('../../../scene/materials/material.js').Material}
     */
    set material(arg: import("../../../scene/materials/material.js").Material);
    get material(): import("../../../scene/materials/material.js").Material;
    /**
     * The id of the material asset to use when rendering an image. Only works for
     * {@link ELEMENTTYPE_IMAGE} types.
     *
     * @type {number}
     */
    set materialAsset(arg: number);
    get materialAsset(): number;
    /**
     * The sprite to render. Only works for {@link ELEMENTTYPE_IMAGE} types which can render either
     * a texture or a sprite.
     *
     * @type {import('../../../scene/sprite.js').Sprite}
     */
    set sprite(arg: import("../../../scene/sprite.js").Sprite);
    get sprite(): import("../../../scene/sprite.js").Sprite;
    /**
     * The id of the sprite asset to render. Only works for {@link ELEMENTTYPE_IMAGE} types which
     * can render either a texture or a sprite.
     *
     * @type {number}
     */
    set spriteAsset(arg: number);
    get spriteAsset(): number;
    /**
     * The frame of the sprite to render. Only works for {@link ELEMENTTYPE_IMAGE} types who have a
     * sprite assigned.
     *
     * @type {number}
     */
    set spriteFrame(arg: number);
    get spriteFrame(): number;
    /**
     * The number of pixels that map to one PlayCanvas unit. Only works for
     * {@link ELEMENTTYPE_IMAGE} types who have a sliced sprite assigned.
     *
     * @type {number}
     */
    set pixelsPerUnit(arg: number);
    get pixelsPerUnit(): number;
    /**
     * The opacity of the image for {@link ELEMENTTYPE_IMAGE} types or the text for
     * {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set opacity(arg: number);
    get opacity(): number;
    /**
     * Specifies which region of the texture to use in order to render an image. Values range from 0
     * to 1 and indicate u, v, width, height. Only works for {@link ELEMENTTYPE_IMAGE} types.
     *
     * @type {Vec4}
     */
    set rect(arg: Vec4);
    get rect(): Vec4;
    /**
     * Switch Image Element into a mask. Masks do not render into the scene, but instead limit child
     * elements to only be rendered where this element is rendered.
     *
     * @type {boolean}
     */
    set mask(arg: boolean);
    get mask(): boolean;
    /**
     * The text outline effect color and opacity. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {import('../../../core/math/color.js').Color}
     */
    set outlineColor(arg: import("../../../core/math/color.js").Color);
    get outlineColor(): import("../../../core/math/color.js").Color;
    /**
     * The width of the text outline effect. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set outlineThickness(arg: number);
    get outlineThickness(): number;
    /**
     * The text shadow effect color and opacity. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {import('../../../core/math/color.js').Color}
     */
    set shadowColor(arg: import("../../../core/math/color.js").Color);
    get shadowColor(): import("../../../core/math/color.js").Color;
    /**
     * The text shadow effect shift amount from original text. Only works for
     * {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set shadowOffset(arg: Vec2);
    get shadowOffset(): Vec2;
    /**
     * Flag for enabling markup processing. Only works for {@link ELEMENTTYPE_TEXT} types. Defaults
     * to false.
     *
     * @type {boolean}
     */
    set enableMarkup(arg: boolean);
    get enableMarkup(): boolean;
    /**
     * Index of the first character to render. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set rangeStart(arg: number);
    get rangeStart(): number;
    /**
     * Index of the last character to render. Only works for {@link ELEMENTTYPE_TEXT} types.
     *
     * @type {number}
     */
    set rangeEnd(arg: number);
    get rangeEnd(): number;
    /** @ignore */
    _setValue(name: any, value: any): void;
    _patch(): void;
    _unpatch(): void;
    /**
     * Patched method for setting the position.
     *
     * @param {number|Vec3} x - The x coordinate or Vec3
     * @param {number} [y] - The y coordinate
     * @param {number} [z] - The z coordinate
     * @private
     */
    private _setPosition;
    /**
     * Patched method for setting the local position.
     *
     * @param {number|Vec3} x - The x coordinate or Vec3
     * @param {number} [y] - The y coordinate
     * @param {number} [z] - The z coordinate
     * @private
     */
    private _setLocalPosition;
    _sync(): void;
    _dirtyLocal: boolean;
    _dirtyWorld: boolean;
    _onInsert(parent: any): void;
    _dirtifyMask(): void;
    _onPrerender(): void;
    _bindScreen(screen: any): void;
    _unbindScreen(screen: any): void;
    _updateScreen(screen: any): void;
    syncMask(depth: any): void;
    _setMaskedBy(mask: any): void;
    _updateMask(currentMask: any, depth: any): void;
    _parseUpToScreen(): {
        screen: any;
        mask: any;
    };
    _onScreenResize(res: any): void;
    _onScreenSpaceChange(): void;
    _onScreenRemove(): void;
    _calculateLocalAnchors(): void;
    getOffsetPosition(x: any, y: any): Vec3;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    onRemove(): void;
    /**
     * Recalculates these properties:
     *   - `_localAnchor`
     *   - `width`
     *   - `height`
     *   - Local position is updated if anchors are split
     *
     * Assumes these properties are up to date:
     *   - `_margin`
     *
     * @param {boolean} propagateCalculatedWidth - If true, call `_setWidth` instead
     * of `_setCalculatedWidth`
     * @param {boolean} propagateCalculatedHeight - If true, call `_setHeight` instead
     * of `_setCalculatedHeight`
     * @private
     */
    private _calculateSize;
    _sizeDirty: boolean;
    /**
     * Internal set width without updating margin.
     *
     * @param {number} w - The new width.
     * @private
     */
    private _setWidth;
    /**
     * Internal set height without updating margin.
     *
     * @param {number} h - The new height.
     * @private
     */
    private _setHeight;
    /**
     * This method sets the calculated width value and optionally updates the margins.
     *
     * @param {number} value - The new calculated width.
     * @param {boolean} updateMargins - Update margins or not.
     * @private
     */
    private _setCalculatedWidth;
    /**
     * This method sets the calculated height value and optionally updates the margins.
     *
     * @param {number} value - The new calculated height.
     * @param {boolean} updateMargins - Update margins or not.
     * @private
     */
    private _setCalculatedHeight;
    _flagChildrenAsDirty(): void;
    addModelToLayers(model: any): void;
    removeModelFromLayers(model: any): void;
    getMaskOffset(): number;
    isVisibleForCamera(camera: any): boolean;
    _isScreenSpace(): boolean;
    _isScreenCulled(): boolean;
    _dirtyBatch(): void;
}
import { Component } from '../component.js';
import { Vec4 } from '../../../core/math/vec4.js';
import { Vec2 } from '../../../core/math/vec2.js';
import { Mat4 } from '../../../core/math/mat4.js';
import { Vec3 } from '../../../core/math/vec3.js';
import { Entity } from '../../entity.js';
import { ImageElement } from './image-element.js';
import { TextElement } from './text-element.js';
