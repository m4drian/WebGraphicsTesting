/**
 * Used to simulate particles and produce renderable particle mesh on either CPU or GPU. GPU
 * simulation is generally much faster than its CPU counterpart, because it avoids slow CPU-GPU
 * synchronization and takes advantage of many GPU cores. However, it requires client to support
 * reasonable uniform count, reading from multiple textures in vertex shader and OES_texture_float
 * extension, including rendering into float textures. Most mobile devices fail to satisfy these
 * requirements, so it's not recommended to simulate thousands of particles on them. GPU version
 * also can't sort particles, so enabling sorting forces CPU mode too. Particle rotation is
 * specified by a single angle parameter: default billboard particles rotate around camera facing
 * axis, while mesh particles rotate around 2 different view-independent axes. Most of the
 * simulation parameters are specified with {@link Curve} or {@link CurveSet}. Curves are
 * interpolated based on each particle's lifetime, therefore parameters are able to change over
 * time. Most of the curve parameters can also be specified by 2 minimum/maximum curves, this way
 * each particle will pick a random value in-between.
 *
 * @category Graphics
 */
export class ParticleSystemComponent extends Component {
    /**
     * Create a new ParticleSystemComponent.
     *
     * @param {import('./system.js').ParticleSystemComponentSystem} system - The ComponentSystem
     * that created this Component.
     * @param {import('../../entity.js').Entity} entity - The Entity this Component is attached to.
     */
    constructor(system: import('./system.js').ParticleSystemComponentSystem, entity: import('../../entity.js').Entity);
    /** @private */
    private _requestedDepth;
    /** @private */
    private _drawOrder;
    /**
     * @type {import('./data.js').ParticleSystemComponentData}
     * @ignore
     */
    get data(): import("./data.js").ParticleSystemComponentData;
    /**
     * Controls whether the particle system plays automatically on creation.
     * If set to false, it is necessary to call {@link ParticleSystemComponent#play} for
     * the particle system to play. Defaults to true.
     *
     * @type {boolean}
     */
    set autoPlay(arg: boolean);
    get autoPlay(): boolean;
    /**
     * Maximum number of simulated particles.
     *
     * @type {number}
     */
    set numParticles(arg: number);
    get numParticles(): number;
    /**
     * The length of time in seconds between a particle's birth and its death.
     *
     * @type {number}
     */
    set lifetime(arg: number);
    get lifetime(): number;
    /**
     * Minimal interval in seconds between particle births.
     *
     * @type {number}
     */
    set rate(arg: number);
    get rate(): number;
    /**
     * Maximal interval in seconds between particle births.
     *
     * @type {number}
     */
    set rate2(arg: number);
    get rate2(): number;
    /**
     * Minimal initial Euler angle of a particle.
     *
     * @type {number}
     */
    set startAngle(arg: number);
    get startAngle(): number;
    /**
     * Maximal initial Euler angle of a particle.
     *
     * @type {number}
     */
    set startAngle2(arg: number);
    get startAngle2(): number;
    /**
     * Enables or disables respawning of particles.
     *
     * @type {boolean}
     */
    set loop(arg: boolean);
    get loop(): boolean;
    /**
     * If enabled, the particle system will be initialized as though it had already completed a full
     * cycle. This only works with looping particle systems.
     *
     * @type {boolean}
     */
    set preWarm(arg: boolean);
    get preWarm(): boolean;
    /**
     * If enabled, particles will be lit by ambient and directional lights.
     *
     * @type {boolean}
     */
    set lighting(arg: boolean);
    get lighting(): boolean;
    /**
     * Enabling Half Lambert lighting avoids particles looking too flat in shadowed areas. It is a
     * completely non-physical lighting model but can give more pleasing visual results.
     *
     * @type {boolean}
     */
    set halfLambert(arg: boolean);
    get halfLambert(): boolean;
    /**
     * Color multiplier.
     *
     * @type {number}
     */
    set intensity(arg: number);
    get intensity(): number;
    /**
     * If enabled, the particles will write to the depth buffer. If disabled, the depth buffer is
     * left unchanged and particles will be guaranteed to overwrite one another in the order in
     * which they are rendered.
     *
     * @type {boolean}
     */
    set depthWrite(arg: boolean);
    get depthWrite(): boolean;
    /**
     * Disable fogging.
     *
     * @type {boolean}
     */
    set noFog(arg: boolean);
    get noFog(): boolean;
    /**
     * Controls fading of particles near their intersections with scene geometry. This effect, when
     * it's non-zero, requires scene depth map to be rendered. Multiple depth-dependent effects can
     * share the same map, but if you only use it for particles, bear in mind that it can double
     * engine draw calls.
     *
     * @type {number}
     */
    set depthSoftening(arg: number);
    get depthSoftening(): number;
    /**
     * Sorting mode. Forces CPU simulation, so be careful.
     *
     * - {@link PARTICLESORT_NONE}: No sorting, particles are drawn in arbitrary order. Can be
     * simulated on GPU.
     * - {@link PARTICLESORT_DISTANCE}: Sorting based on distance to the camera. CPU only.
     * - {@link PARTICLESORT_NEWER_FIRST}: Newer particles are drawn first. CPU only.
     * - {@link PARTICLESORT_OLDER_FIRST}: Older particles are drawn first. CPU only.
     *
     * @type {number}
     */
    set sort(arg: number);
    get sort(): number;
    /**
     * Controls how particles are blended when being written to the currently active render target.
     * Can be:
     *
     * - {@link BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination
     * fragment and write the result to the frame buffer.
     * - {@link BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and
     * write the result to the frame buffer.
     * - {@link BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is
     * equivalent to enabling a source blend mode of {@link BLENDMODE_SRC_ALPHA} and
     * a destination
     * blend mode of {@link BLENDMODE_ONE_MINUS_SRC_ALPHA}.
     * - {@link BLEND_NONE}: Disable blending.
     * - {@link BLEND_PREMULTIPLIED}: Similar to {@link BLEND_NORMAL} expect
     * the source fragment is
     * assumed to have already been multiplied by the source alpha value.
     * - {@link BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the
     * destination fragment and write the result to the frame buffer.
     * - {@link BLEND_ADDITIVEALPHA}: Same as {@link BLEND_ADDITIVE} except
     * the source RGB is
     * multiplied by the source alpha.
     *
     * @type {number}
     */
    set blendType(arg: number);
    get blendType(): number;
    /**
     * A value in world units that controls the amount by which particles are stretched based on
     * their velocity. Particles are stretched from their center towards their previous position.
     *
     * @type {number}
     */
    set stretch(arg: number);
    get stretch(): number;
    /**
     * Orient particles in their direction of motion.
     *
     * @type {boolean}
     */
    set alignToMotion(arg: boolean);
    get alignToMotion(): boolean;
    /**
     * Shape of the emitter. Defines the bounds inside which particles are spawned. Also affects the
     * direction of initial velocity.
     *
     * - {@link EMITTERSHAPE_BOX}: Box shape parameterized by emitterExtents. Initial velocity is
     * directed towards local Z axis.
     * - {@link EMITTERSHAPE_SPHERE}: Sphere shape parameterized by emitterRadius. Initial velocity is
     * directed outwards from the center.
     *
     * @type {number}
     */
    set emitterShape(arg: number);
    get emitterShape(): number;
    /**
     * (Only for EMITTERSHAPE_BOX)
     * The extents of a local space bounding box within which particles are spawned at random positions.
     *
     * @type {import('../../../core/math/vec3.js').Vec3}
     */
    set emitterExtents(arg: import("../../../core/math/vec3.js").Vec3);
    get emitterExtents(): import("../../../core/math/vec3.js").Vec3;
    /**
     * (Only for EMITTERSHAPE_BOX)
     * The exception of extents of a local space bounding box within
     * which particles are not spawned. Aligned to the center of EmitterExtents.
     *
     * @type {import('../../../core/math/vec3.js').Vec3}
     */
    set emitterExtentsInner(arg: import("../../../core/math/vec3.js").Vec3);
    get emitterExtentsInner(): import("../../../core/math/vec3.js").Vec3;
    /**
     * (Only for EMITTERSHAPE_SPHERE)
     * The radius within which particles are spawned at random positions.
     *
     * @type {number}
     */
    set emitterRadius(arg: number);
    get emitterRadius(): number;
    /**
     * (Only for EMITTERSHAPE_SPHERE)
     * The inner radius within which particles are not spawned.
     *
     * @type {number}
     */
    set emitterRadiusInner(arg: number);
    get emitterRadiusInner(): number;
    /**
     * Defines magnitude of the initial emitter velocity. Direction is given by emitter shape.
     *
     * @type {number}
     */
    set initialVelocity(arg: number);
    get initialVelocity(): number;
    /**
     * Enable particle wrapping.
     *
     * @type {boolean}
     */
    set wrap(arg: boolean);
    get wrap(): boolean;
    /**
     * The half extents of a world space box volume centered on the owner entity's position.
     * If a particle crosses the boundary of one side of the volume, it teleports to the
     * opposite side.
     *
     * @type {import('../../../core/math/vec3.js').Vec3}
     */
    set wrapBounds(arg: import("../../../core/math/vec3.js").Vec3);
    get wrapBounds(): import("../../../core/math/vec3.js").Vec3;
    /**
     * Binds particles to emitter transformation rather then world space.
     *
     * @type {boolean}
     */
    set localSpace(arg: boolean);
    get localSpace(): boolean;
    /**
     * Renders particles in 2D screen space. This needs to be set when particle system is part of
     * hierarchy with {@link ScreenComponent} as its ancestor, and allows particle system to
     * integrate with the rendering of {@link ElementComponent}s. Note that an entity with
     * ParticleSystem component cannot be parented directly to {@link ScreenComponent}, but has to
     * be a child of a {@link ElementComponent}, for example {@link LayoutGroupComponent}.
     *
     * @type {boolean}
     */
    set screenSpace(arg: boolean);
    get screenSpace(): boolean;
    /**
     * The {@link Asset} used to set the colorMap.
     *
     * @type {Asset}
     */
    set colorMapAsset(arg: Asset);
    get colorMapAsset(): Asset;
    /**
     * The {@link Asset} used to set the normalMap.
     *
     * @type {Asset}
     */
    set normalMapAsset(arg: Asset);
    get normalMapAsset(): Asset;
    /**
     * Triangular mesh to be used as a particle. Only first vertex/index buffer is used. Vertex buffer
     * must contain local position at first 3 floats of each vertex.
     *
     * @type {Mesh}
     */
    set mesh(arg: Mesh);
    get mesh(): Mesh;
    /**
     * The {@link Asset} used to set the mesh.
     *
     * @type {Asset}
     */
    set meshAsset(arg: Asset);
    get meshAsset(): Asset;
    /**
     * The Render {@link Asset} used to set the mesh.
     *
     * @type {Asset}
     */
    set renderAsset(arg: Asset);
    get renderAsset(): Asset;
    /**
     * Sorting mode. Forces CPU simulation, so be careful.
     *
     * - {@link PARTICLEORIENTATION_SCREEN}: Particles are facing camera.
     * - {@link PARTICLEORIENTATION_WORLD}: User defines world space normal (particleNormal) to set
     * planes orientation.
     * - {@link PARTICLEORIENTATION_EMITTER}: Similar to previous, but the normal is affected by
     * emitter (entity) transformation.
     *
     * @type {number}
     */
    set orientation(arg: number);
    get orientation(): number;
    /**
     * (Only for PARTICLEORIENTATION_WORLD and PARTICLEORIENTATION_EMITTER)
     * The exception of extents of a local space bounding box within which particles are not spawned.
     * Aligned to the center of EmitterExtents.
     *
     * @type {import('../../../core/math/vec3.js').Vec3}
     */
    set particleNormal(arg: import("../../../core/math/vec3.js").Vec3);
    get particleNormal(): import("../../../core/math/vec3.js").Vec3;
    /**
     * Velocity relative to emitter over lifetime.
     *
     * @type {import('../../../core/math/curve-set.js').CurveSet}
     */
    set localVelocityGraph(arg: import("../../../core/math/curve-set.js").CurveSet);
    get localVelocityGraph(): import("../../../core/math/curve-set.js").CurveSet;
    /**
     * If not null, particles pick random values between localVelocityGraph and localVelocityGraph2.
     *
     * @type {import('../../../core/math/curve-set.js').CurveSet}
     */
    set localVelocityGraph2(arg: import("../../../core/math/curve-set.js").CurveSet);
    get localVelocityGraph2(): import("../../../core/math/curve-set.js").CurveSet;
    /**
     * World-space velocity over lifetime.
     *
     * @type {import('../../../core/math/curve-set.js').CurveSet}
     */
    set velocityGraph(arg: import("../../../core/math/curve-set.js").CurveSet);
    get velocityGraph(): import("../../../core/math/curve-set.js").CurveSet;
    /**
     * If not null, particles pick random values between velocityGraph and velocityGraph2.
     *
     * @type {import('../../../core/math/curve-set.js').CurveSet}
     */
    set velocityGraph2(arg: import("../../../core/math/curve-set.js").CurveSet);
    get velocityGraph2(): import("../../../core/math/curve-set.js").CurveSet;
    /**
     * Rotation speed over lifetime.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set rotationSpeedGraph(arg: import("../../../core/math/curve.js").Curve);
    get rotationSpeedGraph(): import("../../../core/math/curve.js").Curve;
    /**
     * If not null, particles pick random values between rotationSpeedGraph and rotationSpeedGraph2.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set rotationSpeedGraph2(arg: import("../../../core/math/curve.js").Curve);
    get rotationSpeedGraph2(): import("../../../core/math/curve.js").Curve;
    /**
     * Radial speed over lifetime, velocity vector points from emitter origin to particle pos.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set radialSpeedGraph(arg: import("../../../core/math/curve.js").Curve);
    get radialSpeedGraph(): import("../../../core/math/curve.js").Curve;
    /**
     * If not null, particles pick random values between radialSpeedGraph and radialSpeedGraph2.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set radialSpeedGraph2(arg: import("../../../core/math/curve.js").Curve);
    get radialSpeedGraph2(): import("../../../core/math/curve.js").Curve;
    /**
     * Scale over lifetime.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set scaleGraph(arg: import("../../../core/math/curve.js").Curve);
    get scaleGraph(): import("../../../core/math/curve.js").Curve;
    /**
     * If not null, particles pick random values between scaleGraph and scaleGraph2.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set scaleGraph2(arg: import("../../../core/math/curve.js").Curve);
    get scaleGraph2(): import("../../../core/math/curve.js").Curve;
    /**
     * Color over lifetime.
     *
     * @type {import('../../../core/math/curve-set.js').CurveSet}
     */
    set colorGraph(arg: import("../../../core/math/curve-set.js").CurveSet);
    get colorGraph(): import("../../../core/math/curve-set.js").CurveSet;
    /**
     * If not null, particles pick random values between colorGraph and colorGraph2.
     *
     * @type {import('../../../core/math/curve-set.js').CurveSet}
     */
    set colorGraph2(arg: import("../../../core/math/curve-set.js").CurveSet);
    get colorGraph2(): import("../../../core/math/curve-set.js").CurveSet;
    /**
     * Alpha over lifetime.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set alphaGraph(arg: import("../../../core/math/curve.js").Curve);
    get alphaGraph(): import("../../../core/math/curve.js").Curve;
    /**
     * If not null, particles pick random values between alphaGraph and alphaGraph2.
     *
     * @type {import('../../../core/math/curve.js').Curve}
     */
    set alphaGraph2(arg: import("../../../core/math/curve.js").Curve);
    get alphaGraph2(): import("../../../core/math/curve.js").Curve;
    /**
     * The color map texture to apply to all particles in the system. If no texture is assigned, a
     * default spot texture is used.
     *
     * @type {import('../../../platform/graphics/texture.js').Texture}
     */
    set colorMap(arg: import("../../../platform/graphics/texture.js").Texture);
    get colorMap(): import("../../../platform/graphics/texture.js").Texture;
    /**
     * The normal map texture to apply to all particles in the system. If no texture is assigned,
     * an approximate spherical normal is calculated for each vertex.
     *
     * @type {import('../../../platform/graphics/texture.js').Texture}
     */
    set normalMap(arg: import("../../../platform/graphics/texture.js").Texture);
    get normalMap(): import("../../../platform/graphics/texture.js").Texture;
    /**
     * Number of horizontal tiles in the sprite sheet.
     *
     * @type {number}
     */
    set animTilesX(arg: number);
    get animTilesX(): number;
    /**
     * Number of vertical tiles in the sprite sheet.
     *
     * @type {number}
     */
    set animTilesY(arg: number);
    get animTilesY(): number;
    /**
     * The sprite sheet frame that the animation should begin playing from. Indexed from the start
     * of the current animation.
     *
     * @type {number}
     */
    set animStartFrame(arg: number);
    get animStartFrame(): number;
    /**
     * Number of sprite sheet frames in the current sprite sheet animation. The number of animations
     * multiplied by number of frames should be a value less than animTilesX multiplied by animTilesY.
     *
     * @type {number}
     */
    set animNumFrames(arg: number);
    get animNumFrames(): number;
    /**
     * Number of sprite sheet animations contained within the current sprite sheet. The number of
     * animations multiplied by number of frames should be a value less than animTilesX multiplied
     * by animTilesY.
     *
     * @type {number}
     */
    set animNumAnimations(arg: number);
    get animNumAnimations(): number;
    /**
     * When animNumAnimations is greater than 1, the sprite sheet animation index determines which
     * animation the particle system should play.
     *
     * @type {number}
     */
    set animIndex(arg: number);
    get animIndex(): number;
    /**
     * Each particle emitted by the system will play a random animation from the sprite sheet, up to
     * animNumAnimations.
     *
     * @type {number}
     */
    set randomizeAnimIndex(arg: boolean);
    get randomizeAnimIndex(): boolean;
    /**
     * Sprite sheet animation speed. 1 = particle lifetime, 2 = twice during lifetime etc.
     *
     * @type {number}
     */
    set animSpeed(arg: number);
    get animSpeed(): number;
    /**
     * Controls whether the sprite sheet animation plays once or loops continuously.
     *
     * @type {boolean}
     */
    set animLoop(arg: boolean);
    get animLoop(): boolean;
    /**
     * An array of layer IDs ({@link Layer#id}) to which this particle system should belong. Don't
     * push/pop/splice or modify this array, if you want to change it - set a new one instead.
     *
     * @type {number[]}
     */
    set layers(arg: number[]);
    get layers(): number[];
    /**
     * @type {number}
     */
    set drawOrder(drawOrder: number);
    get drawOrder(): number;
    /** @ignore */
    _setValue(name: any, value: any): void;
    addMeshInstanceToLayers(): void;
    removeMeshInstanceFromLayers(): void;
    onSetLayers(name: any, oldValue: any, newValue: any): void;
    onLayersChanged(oldComp: any, newComp: any): void;
    onLayerAdded(layer: any): void;
    onLayerRemoved(layer: any): void;
    _bindColorMapAsset(asset: any): void;
    _unbindColorMapAsset(asset: any): void;
    _onColorMapAssetLoad(asset: any): void;
    _onColorMapAssetUnload(asset: any): void;
    _onColorMapAssetRemove(asset: any): void;
    _onColorMapAssetChange(asset: any): void;
    onSetColorMapAsset(name: any, oldValue: any, newValue: any): void;
    _bindNormalMapAsset(asset: any): void;
    _unbindNormalMapAsset(asset: any): void;
    _onNormalMapAssetLoad(asset: any): void;
    _onNormalMapAssetUnload(asset: any): void;
    _onNormalMapAssetRemove(asset: any): void;
    _onNormalMapAssetChange(asset: any): void;
    onSetNormalMapAsset(name: any, oldValue: any, newValue: any): void;
    _bindMeshAsset(asset: any): void;
    _unbindMeshAsset(asset: any): void;
    _onMeshAssetLoad(asset: any): void;
    _onMeshAssetUnload(asset: any): void;
    _onMeshAssetRemove(asset: any): void;
    _onMeshAssetChange(asset: any): void;
    onSetMeshAsset(name: any, oldValue: any, newValue: any): void;
    onSetMesh(name: any, oldValue: any, newValue: any): void;
    _onMeshChanged(mesh: any): void;
    onSetRenderAsset(name: any, oldValue: any, newValue: any): void;
    _bindRenderAsset(asset: any): void;
    _unbindRenderAsset(asset: any): void;
    _onRenderAssetLoad(asset: any): void;
    _onRenderAssetUnload(asset: any): void;
    _onRenderAssetRemove(asset: any): void;
    _onRenderChanged(render: any): void;
    _onRenderSetMeshes(meshes: any): void;
    onSetLoop(name: any, oldValue: any, newValue: any): void;
    onSetBlendType(name: any, oldValue: any, newValue: any): void;
    _requestDepth(): void;
    _releaseDepth(): void;
    onSetDepthSoftening(name: any, oldValue: any, newValue: any): void;
    onSetSimpleProperty(name: any, oldValue: any, newValue: any): void;
    onSetComplexProperty(name: any, oldValue: any, newValue: any): void;
    onSetGraphProperty(name: any, oldValue: any, newValue: any): void;
    emitter: ParticleEmitter;
    onBeforeRemove(): void;
    /**
     * Resets particle state, doesn't affect playing.
     */
    reset(): void;
    /**
     * Disables the emission of new particles, lets existing to finish their simulation.
     */
    stop(): void;
    /**
     * Freezes the simulation.
     */
    pause(): void;
    /**
     * Unfreezes the simulation.
     */
    unpause(): void;
    /**
     * Enables/unfreezes the simulation.
     */
    play(): void;
    /**
     * Checks if simulation is in progress.
     *
     * @returns {boolean} True if the particle system is currently playing and false otherwise.
     */
    isPlaying(): boolean;
    /**
     * Rebuilds all data used by this particle system.
     *
     * @private
     */
    private rebuild;
}
import { Component } from '../component.js';
import { Asset } from '../../asset/asset.js';
import { Mesh } from '../../../scene/mesh.js';
import { ParticleEmitter } from '../../../scene/particle-system/particle-emitter.js';
