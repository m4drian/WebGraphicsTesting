/**
 * Oriented Box.
 *
 * @category Math
 */
export class OrientedBox {
    /**
     * Create a new OrientedBox instance.
     *
     * @param {Mat4} [worldTransform] - Transform that has the orientation and position of the box.
     * Scale is assumed to be one.
     * @param {Vec3} [halfExtents] - Half the distance across the box in each local axis. The
     * constructor takes a reference of this parameter.
     */
    constructor(worldTransform?: Mat4, halfExtents?: Vec3);
    halfExtents: Vec3;
    /**
     * @type {Mat4}
     * @private
     */
    private _modelTransform;
    /**
     * @type {Mat4}
     * @private
     */
    private _worldTransform;
    /**
     * @type {BoundingBox}
     * @private
     */
    private _aabb;
    /**
     * The world transform of the OBB.
     *
     * @type {Mat4}
     */
    set worldTransform(value: Mat4);
    get worldTransform(): Mat4;
    /**
     * Test if a ray intersects with the OBB.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray, point?: Vec3): boolean;
    /**
     * Test if a point is inside a OBB.
     *
     * @param {Vec3} point - Point to test.
     * @returns {boolean} True if the point is inside the OBB and false otherwise.
     */
    containsPoint(point: Vec3): boolean;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this OBB.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping or inside this OBB
     * and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere): boolean;
}
import { Vec3 } from '../math/vec3.js';
import { Mat4 } from '../math/mat4.js';
import { Ray } from './ray.js';
import { BoundingSphere } from './bounding-sphere.js';
