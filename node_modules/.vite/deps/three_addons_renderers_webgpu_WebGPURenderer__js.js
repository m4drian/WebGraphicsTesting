import {
  WebGPU_default
} from "./chunk-WQQ4QB74.js";
import {
  ACESFilmicToneMapping,
  AddEquation,
  AdditiveBlending,
  AgXToneMapping,
  AlphaFormat,
  AlwaysCompare,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  BackSide,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  CineonToneMapping,
  ClampToEdgeWrapping,
  Color,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeUVReflectionMapping,
  CullFaceBack,
  CullFaceFront,
  CullFaceNone,
  CustomBlending,
  DataArrayTexture,
  DataTexture,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EqualCompare,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  EventDispatcher,
  Float16BufferAttribute,
  Float32BufferAttribute,
  FloatType,
  FramebufferTexture,
  FrontSide,
  Frustum,
  GreaterCompare,
  GreaterDepth,
  GreaterEqualCompare,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  HalfFloatType,
  HemisphereLight,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedInterleavedBuffer,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  InvertStencilOp,
  KeepStencilOp,
  LessCompare,
  LessDepth,
  LessEqualCompare,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  LuminanceAlphaFormat,
  LuminanceFormat,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MultiplyBlending,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverCompare,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  NormalBlending,
  NotEqualCompare,
  NotEqualDepth,
  NotEqualStencilFunc,
  ObjectSpaceNormalMap,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PointLight,
  PointsMaterial,
  RED_GREEN_RGTC2_Format,
  RED_RGTC1_Format,
  REVISION,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBFormat,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RenderTarget,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  SIGNED_RED_GREEN_RGTC2_Format,
  SIGNED_RED_RGTC1_Format,
  SRGBColorSpace,
  Scene,
  ShadowMaterial,
  ShortType,
  SphereGeometry,
  SpotLight,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticDrawUsage,
  SubtractEquation,
  SubtractiveBlending,
  TangentSpaceNormalMap,
  Texture,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedInt5999Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  WebGLCoordinateSystem,
  WebGLCubeRenderTarget,
  WebGPUCoordinateSystem,
  ZeroFactor,
  ZeroStencilOp,
  createCanvasElement
} from "./chunk-52M4HH6Y.js";

// node_modules/three/examples/jsm/renderers/common/Animation.js
var Animation = class {
  constructor(nodes, info) {
    this.nodes = nodes;
    this.info = info;
    this.animationLoop = null;
    this.requestId = null;
    this._init();
  }
  _init() {
    const update = (time, frame) => {
      this.requestId = self.requestAnimationFrame(update);
      if (this.info.autoReset === true) this.info.reset();
      this.nodes.nodeFrame.update();
      this.info.frame = this.nodes.nodeFrame.frameId;
      if (this.animationLoop !== null) this.animationLoop(time, frame);
    };
    update();
  }
  dispose() {
    self.cancelAnimationFrame(this.requestId);
    this.requestId = null;
  }
  setAnimationLoop(callback) {
    this.animationLoop = callback;
  }
};
var Animation_default = Animation;

// node_modules/three/examples/jsm/renderers/common/ChainMap.js
var ChainMap = class {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(keys) {
    let map = this.weakMap;
    for (let i = 0; i < keys.length; i++) {
      map = map.get(keys[i]);
      if (map === void 0) return void 0;
    }
    return map.get(keys[keys.length - 1]);
  }
  set(keys, value) {
    let map = this.weakMap;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (map.has(key) === false) map.set(key, /* @__PURE__ */ new WeakMap());
      map = map.get(key);
    }
    return map.set(keys[keys.length - 1], value);
  }
  delete(keys) {
    let map = this.weakMap;
    for (let i = 0; i < keys.length; i++) {
      map = map.get(keys[i]);
      if (map === void 0) return false;
    }
    return map.delete(keys[keys.length - 1]);
  }
};

// node_modules/three/examples/jsm/renderers/common/ClippingContext.js
var _plane = new Plane();
var _clippingContextVersion = 0;
var ClippingContext = class {
  constructor() {
    this.version = ++_clippingContextVersion;
    this.globalClippingCount = 0;
    this.localClippingCount = 0;
    this.localClippingEnabled = false;
    this.localClipIntersection = false;
    this.planes = [];
    this.parentVersion = 0;
    this.viewNormalMatrix = new Matrix3();
  }
  projectPlanes(source, offset) {
    const l = source.length;
    const planes = this.planes;
    for (let i = 0; i < l; i++) {
      _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const v = planes[offset + i];
      const normal2 = _plane.normal;
      v.x = -normal2.x;
      v.y = -normal2.y;
      v.z = -normal2.z;
      v.w = _plane.constant;
    }
  }
  updateGlobal(renderer, camera) {
    const rendererClippingPlanes = renderer.clippingPlanes;
    this.viewMatrix = camera.matrixWorldInverse;
    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
    let update = false;
    if (Array.isArray(rendererClippingPlanes) && rendererClippingPlanes.length !== 0) {
      const l = rendererClippingPlanes.length;
      if (l !== this.globalClippingCount) {
        const planes = [];
        for (let i = 0; i < l; i++) {
          planes.push(new Vector4());
        }
        this.globalClippingCount = l;
        this.planes = planes;
        update = true;
      }
      this.projectPlanes(rendererClippingPlanes, 0);
    } else if (this.globalClippingCount !== 0) {
      this.globalClippingCount = 0;
      this.planes = [];
      update = true;
    }
    if (renderer.localClippingEnabled !== this.localClippingEnabled) {
      this.localClippingEnabled = renderer.localClippingEnabled;
      update = true;
    }
    if (update) this.version = _clippingContextVersion++;
  }
  update(parent, material) {
    let update = false;
    if (this !== parent && parent.version !== this.parentVersion) {
      this.globalClippingCount = material.isShadowNodeMaterial ? 0 : parent.globalClippingCount;
      this.localClippingEnabled = parent.localClippingEnabled;
      this.planes = Array.from(parent.planes);
      this.parentVersion = parent.version;
      this.viewMatrix = parent.viewMatrix;
      this.viewNormalMatrix = parent.viewNormalMatrix;
      update = true;
    }
    if (this.localClippingEnabled) {
      const localClippingPlanes = material.clippingPlanes;
      if (Array.isArray(localClippingPlanes) && localClippingPlanes.length !== 0) {
        const l = localClippingPlanes.length;
        const planes = this.planes;
        const offset = this.globalClippingCount;
        if (update || l !== this.localClippingCount) {
          planes.length = offset + l;
          for (let i = 0; i < l; i++) {
            planes[offset + i] = new Vector4();
          }
          this.localClippingCount = l;
          update = true;
        }
        this.projectPlanes(localClippingPlanes, offset);
      } else if (this.localClippingCount !== 0) {
        this.localClippingCount = 0;
        update = true;
      }
      if (this.localClipIntersection !== material.clipIntersection) {
        this.localClipIntersection = material.clipIntersection;
        update = true;
      }
    }
    if (update) this.version = _clippingContextVersion++;
  }
};
var ClippingContext_default = ClippingContext;

// node_modules/three/examples/jsm/renderers/common/RenderObject.js
var id = 0;
function getKeys(obj) {
  const keys = Object.keys(obj);
  let proto = Object.getPrototypeOf(obj);
  while (proto) {
    const descriptors = Object.getOwnPropertyDescriptors(proto);
    for (const key in descriptors) {
      if (descriptors[key] !== void 0) {
        const descriptor = descriptors[key];
        if (descriptor && typeof descriptor.get === "function") {
          keys.push(key);
        }
      }
    }
    proto = Object.getPrototypeOf(proto);
  }
  return keys;
}
var RenderObject = class {
  constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode2, renderContext) {
    this._nodes = nodes;
    this._geometries = geometries;
    this.id = id++;
    this.renderer = renderer;
    this.object = object;
    this.material = material;
    this.scene = scene;
    this.camera = camera;
    this.lightsNode = lightsNode2;
    this.context = renderContext;
    this.geometry = object.geometry;
    this.version = material.version;
    this.drawRange = null;
    this.attributes = null;
    this.pipeline = null;
    this.vertexBuffers = null;
    this.updateClipping(renderContext.clippingContext);
    this.clippingContextVersion = this.clippingContext.version;
    this.initialNodesCacheKey = this.getNodesCacheKey();
    this.initialCacheKey = this.getCacheKey();
    this._nodeBuilderState = null;
    this._bindings = null;
    this.onDispose = null;
    this.isRenderObject = true;
    this.onMaterialDispose = () => {
      this.dispose();
    };
    this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  updateClipping(parent) {
    const material = this.material;
    let clippingContext = this.clippingContext;
    if (Array.isArray(material.clippingPlanes)) {
      if (clippingContext === parent || !clippingContext) {
        clippingContext = new ClippingContext_default();
        this.clippingContext = clippingContext;
      }
      clippingContext.update(parent, material);
    } else if (this.clippingContext !== parent) {
      this.clippingContext = parent;
    }
  }
  get clippingNeedsUpdate() {
    if (this.clippingContext.version === this.clippingContextVersion) return false;
    this.clippingContextVersion = this.clippingContext.version;
    return true;
  }
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  getIndex() {
    return this._geometries.getIndex(this);
  }
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
    const geometry = this.geometry;
    const attributes = [];
    const vertexBuffers = /* @__PURE__ */ new Set();
    for (const nodeAttribute of nodeAttributes) {
      const attribute2 = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);
      if (attribute2 === void 0) continue;
      attributes.push(attribute2);
      const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
      vertexBuffers.add(bufferAttribute2);
    }
    this.attributes = attributes;
    this.vertexBuffers = Array.from(vertexBuffers.values());
    return attributes;
  }
  getVertexBuffers() {
    if (this.vertexBuffers === null) this.getAttributes();
    return this.vertexBuffers;
  }
  getMaterialCacheKey() {
    const { object, material } = this;
    let cacheKey = material.customProgramCacheKey();
    for (const property2 of getKeys(material)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property2)) continue;
      let value = material[property2];
      if (value !== null) {
        const type = typeof value;
        if (type === "number") value = value !== 0 ? "1" : "0";
        else if (type === "object") value = "{}";
      }
      cacheKey += /*property + ':' +*/
      value + ",";
    }
    cacheKey += this.clippingContextVersion + ",";
    if (object.skeleton) {
      cacheKey += object.skeleton.bones.length + ",";
    }
    if (object.morphTargetInfluences) {
      cacheKey += object.morphTargetInfluences.length + ",";
    }
    if (object.isBatchedMesh) {
      cacheKey += object._matricesTexture.uuid + ",";
      if (object._colorsTexture !== null) {
        cacheKey += object._colorsTexture.uuid + ",";
      }
    }
    return cacheKey;
  }
  get needsUpdate() {
    return this.initialNodesCacheKey !== this.getNodesCacheKey() || this.clippingNeedsUpdate;
  }
  getNodesCacheKey() {
    return this._nodes.getCacheKey(this.scene, this.lightsNode);
  }
  getCacheKey() {
    return this.getMaterialCacheKey() + "," + this.getNodesCacheKey();
  }
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose);
    this.onDispose();
  }
};

// node_modules/three/examples/jsm/renderers/common/RenderObjects.js
var RenderObjects = class {
  constructor(renderer, nodes, geometries, pipelines, bindings, info) {
    this.renderer = renderer;
    this.nodes = nodes;
    this.geometries = geometries;
    this.pipelines = pipelines;
    this.bindings = bindings;
    this.info = info;
    this.chainMaps = {};
  }
  get(object, material, scene, camera, lightsNode2, renderContext, passId) {
    const chainMap = this.getChainMap(passId);
    const chainArray = [object, material, renderContext, lightsNode2];
    let renderObject = chainMap.get(chainArray);
    if (renderObject === void 0) {
      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode2, renderContext, passId);
      chainMap.set(chainArray, renderObject);
    } else {
      renderObject.updateClipping(renderContext.clippingContext);
      if (renderObject.version !== material.version || renderObject.needsUpdate) {
        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
          renderObject.dispose();
          renderObject = this.get(object, material, scene, camera, lightsNode2, renderContext, passId);
        } else {
          renderObject.version = material.version;
        }
      }
    }
    return renderObject;
  }
  getChainMap(passId = "default") {
    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
  }
  dispose() {
    this.chainMaps = {};
  }
  createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode2, renderContext, passId) {
    const chainMap = this.getChainMap(passId);
    const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode2, renderContext);
    renderObject.onDispose = () => {
      this.pipelines.delete(renderObject);
      this.bindings.delete(renderObject);
      this.nodes.delete(renderObject);
      chainMap.delete(renderObject.getChainArray());
    };
    return renderObject;
  }
};
var RenderObjects_default = RenderObjects;

// node_modules/three/examples/jsm/renderers/common/DataMap.js
var DataMap = class {
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  get(object) {
    let map = this.data.get(object);
    if (map === void 0) {
      map = {};
      this.data.set(object, map);
    }
    return map;
  }
  delete(object) {
    let map;
    if (this.data.has(object)) {
      map = this.data.get(object);
      this.data.delete(object);
    }
    return map;
  }
  has(object) {
    return this.data.has(object);
  }
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
};
var DataMap_default = DataMap;

// node_modules/three/examples/jsm/renderers/common/Constants.js
var AttributeType = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 4
};
var GPU_CHUNK_BYTES = 16;
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;

// node_modules/three/examples/jsm/renderers/common/Attributes.js
var Attributes = class extends DataMap_default {
  constructor(backend) {
    super();
    this.backend = backend;
  }
  delete(attribute2) {
    const attributeData = super.delete(attribute2);
    if (attributeData !== void 0) {
      this.backend.destroyAttribute(attribute2);
    }
    return attributeData;
  }
  update(attribute2, type) {
    const data = this.get(attribute2);
    if (data.version === void 0) {
      if (type === AttributeType.VERTEX) {
        this.backend.createAttribute(attribute2);
      } else if (type === AttributeType.INDEX) {
        this.backend.createIndexAttribute(attribute2);
      } else if (type === AttributeType.STORAGE) {
        this.backend.createStorageAttribute(attribute2);
      }
      data.version = this._getBufferAttribute(attribute2).version;
    } else {
      const bufferAttribute2 = this._getBufferAttribute(attribute2);
      if (data.version < bufferAttribute2.version || bufferAttribute2.usage === DynamicDrawUsage) {
        this.backend.updateAttribute(attribute2);
        data.version = bufferAttribute2.version;
      }
    }
  }
  _getBufferAttribute(attribute2) {
    if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;
    return attribute2;
  }
};
var Attributes_default = Attributes;

// node_modules/three/examples/jsm/renderers/common/Geometries.js
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true;
  }
  return false;
}
function getWireframeVersion(geometry) {
  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
}
function getWireframeIndex(geometry) {
  const indices = [];
  const geometryIndex = geometry.index;
  const geometryPosition = geometry.attributes.position;
  if (geometryIndex !== null) {
    const array = geometryIndex.array;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const a = array[i + 0];
      const b = array[i + 1];
      const c = array[i + 2];
      indices.push(a, b, b, c, c, a);
    }
  } else {
    const array = geometryPosition.array;
    for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
      const a = i + 0;
      const b = i + 1;
      const c = i + 2;
      indices.push(a, b, b, c, c, a);
    }
  }
  const attribute2 = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
  attribute2.version = getWireframeVersion(geometry);
  return attribute2;
}
var Geometries = class extends DataMap_default {
  constructor(attributes, info) {
    super();
    this.attributes = attributes;
    this.info = info;
    this.wireframes = /* @__PURE__ */ new WeakMap();
    this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  has(renderObject) {
    const geometry = renderObject.geometry;
    return super.has(geometry) && this.get(geometry).initialized === true;
  }
  updateForRender(renderObject) {
    if (this.has(renderObject) === false) this.initGeometry(renderObject);
    this.updateAttributes(renderObject);
  }
  initGeometry(renderObject) {
    const geometry = renderObject.geometry;
    const geometryData = this.get(geometry);
    geometryData.initialized = true;
    this.info.memory.geometries++;
    const onDispose = () => {
      this.info.memory.geometries--;
      const index = geometry.index;
      const geometryAttributes = renderObject.getAttributes();
      if (index !== null) {
        this.attributes.delete(index);
      }
      for (const geometryAttribute of geometryAttributes) {
        this.attributes.delete(geometryAttribute);
      }
      const wireframeAttribute = this.wireframes.get(geometry);
      if (wireframeAttribute !== void 0) {
        this.attributes.delete(wireframeAttribute);
      }
      geometry.removeEventListener("dispose", onDispose);
    };
    geometry.addEventListener("dispose", onDispose);
  }
  updateAttributes(renderObject) {
    const attributes = renderObject.getAttributes();
    for (const attribute2 of attributes) {
      this.updateAttribute(attribute2, AttributeType.VERTEX);
    }
    const index = this.getIndex(renderObject);
    if (index !== null) {
      this.updateAttribute(index, AttributeType.INDEX);
    }
  }
  updateAttribute(attribute2, type) {
    const callId = this.info.render.calls;
    if (this.attributeCall.get(attribute2) !== callId) {
      this.attributes.update(attribute2, type);
      this.attributeCall.set(attribute2, callId);
    }
  }
  getIndex(renderObject) {
    const { geometry, material } = renderObject;
    let index = geometry.index;
    if (material.wireframe === true) {
      const wireframes = this.wireframes;
      let wireframeAttribute = wireframes.get(geometry);
      if (wireframeAttribute === void 0) {
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
        this.attributes.delete(wireframeAttribute);
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      }
      index = wireframeAttribute;
    }
    return index;
  }
};
var Geometries_default = Geometries;

// node_modules/three/examples/jsm/renderers/common/Info.js
var Info = class {
  constructor() {
    this.autoReset = true;
    this.frame = 0;
    this.calls = 0;
    this.render = {
      calls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0
    };
    this.compute = {
      calls: 0,
      computeCalls: 0,
      timestamp: 0
    };
    this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(object, count, instanceCount) {
    this.render.drawCalls++;
    if (object.isMesh || object.isSprite) {
      this.render.triangles += instanceCount * (count / 3);
    } else if (object.isPoints) {
      this.render.points += instanceCount * count;
    } else if (object.isLineSegments) {
      this.render.lines += instanceCount * (count / 2);
    } else if (object.isLine) {
      this.render.lines += instanceCount * (count - 1);
    } else {
      console.error("THREE.WebGPUInfo: Unknown object type.");
    }
  }
  updateTimestamp(type, time) {
    this[type].timestamp += time;
  }
  reset() {
    this.render.drawCalls = 0;
    this.compute.computeCalls = 0;
    this.render.triangles = 0;
    this.render.points = 0;
    this.render.lines = 0;
    this.render.timestamp = 0;
    this.compute.timestamp = 0;
  }
  dispose() {
    this.reset();
    this.calls = 0;
    this.render.calls = 0;
    this.compute.calls = 0;
    this.render.timestamp = 0;
    this.compute.timestamp = 0;
    this.memory.geometries = 0;
    this.memory.textures = 0;
  }
};
var Info_default = Info;

// node_modules/three/examples/jsm/renderers/common/Pipeline.js
var Pipeline = class {
  constructor(cacheKey) {
    this.cacheKey = cacheKey;
    this.usedTimes = 0;
  }
};
var Pipeline_default = Pipeline;

// node_modules/three/examples/jsm/renderers/common/RenderPipeline.js
var RenderPipeline = class extends Pipeline_default {
  constructor(cacheKey, vertexProgram, fragmentProgram) {
    super(cacheKey);
    this.vertexProgram = vertexProgram;
    this.fragmentProgram = fragmentProgram;
  }
};
var RenderPipeline_default = RenderPipeline;

// node_modules/three/examples/jsm/renderers/common/ComputePipeline.js
var ComputePipeline = class extends Pipeline_default {
  constructor(cacheKey, computeProgram) {
    super(cacheKey);
    this.computeProgram = computeProgram;
    this.isComputePipeline = true;
  }
};
var ComputePipeline_default = ComputePipeline;

// node_modules/three/examples/jsm/renderers/common/ProgrammableStage.js
var _id = 0;
var ProgrammableStage = class {
  constructor(code2, type, transforms = null, attributes = null) {
    this.id = _id++;
    this.code = code2;
    this.stage = type;
    this.transforms = transforms;
    this.attributes = attributes;
    this.usedTimes = 0;
  }
};
var ProgrammableStage_default = ProgrammableStage;

// node_modules/three/examples/jsm/renderers/common/Pipelines.js
var Pipelines = class extends DataMap_default {
  constructor(backend, nodes) {
    super();
    this.backend = backend;
    this.nodes = nodes;
    this.bindings = null;
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  getForCompute(computeNode, bindings) {
    const { backend } = this;
    const data = this.get(computeNode);
    if (this._needsComputeUpdate(computeNode)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.computeProgram.usedTimes--;
      }
      const nodeBuilderState = this.nodes.getForCompute(computeNode);
      let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
      if (stageCompute === void 0) {
        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);
        stageCompute = new ProgrammableStage_default(nodeBuilderState.computeShader, "compute", nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);
        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
        backend.createProgram(stageCompute);
      }
      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
      }
      pipeline.usedTimes++;
      stageCompute.usedTimes++;
      data.version = computeNode.version;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  getForRender(renderObject, promises = null) {
    const { backend } = this;
    const data = this.get(renderObject);
    if (this._needsRenderUpdate(renderObject)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.vertexProgram.usedTimes--;
        previousPipeline.fragmentProgram.usedTimes--;
      }
      const nodeBuilderState = renderObject.getNodeBuilderState();
      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
      if (stageVertex === void 0) {
        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);
        stageVertex = new ProgrammableStage_default(nodeBuilderState.vertexShader, "vertex");
        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
        backend.createProgram(stageVertex);
      }
      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
      if (stageFragment === void 0) {
        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);
        stageFragment = new ProgrammableStage_default(nodeBuilderState.fragmentShader, "fragment");
        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
        backend.createProgram(stageFragment);
      }
      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);
      } else {
        renderObject.pipeline = pipeline;
      }
      pipeline.usedTimes++;
      stageVertex.usedTimes++;
      stageFragment.usedTimes++;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  delete(object) {
    const pipeline = this.get(object).pipeline;
    if (pipeline) {
      pipeline.usedTimes--;
      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);
      if (pipeline.isComputePipeline) {
        pipeline.computeProgram.usedTimes--;
        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
      } else {
        pipeline.fragmentProgram.usedTimes--;
        pipeline.vertexProgram.usedTimes--;
        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
      }
    }
    return super.delete(object);
  }
  dispose() {
    super.dispose();
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  updateForRender(renderObject) {
    this.getForRender(renderObject);
  }
  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new ComputePipeline_default(cacheKey, stageCompute);
      this.caches.set(cacheKey, pipeline);
      this.backend.createComputePipeline(pipeline, bindings);
    }
    return pipeline;
  }
  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new RenderPipeline_default(cacheKey, stageVertex, stageFragment);
      this.caches.set(cacheKey, pipeline);
      renderObject.pipeline = pipeline;
      this.backend.createRenderPipeline(renderObject, promises);
    }
    return pipeline;
  }
  _getComputeCacheKey(computeNode, stageCompute) {
    return computeNode.id + "," + stageCompute.id;
  }
  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
    return stageVertex.id + "," + stageFragment.id + "," + this.backend.getRenderCacheKey(renderObject);
  }
  _releasePipeline(pipeline) {
    this.caches.delete(pipeline.cacheKey);
  }
  _releaseProgram(program) {
    const code2 = program.code;
    const stage = program.stage;
    this.programs[stage].delete(code2);
  }
  _needsComputeUpdate(computeNode) {
    const data = this.get(computeNode);
    return data.pipeline === void 0 || data.version !== computeNode.version;
  }
  _needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    return data.pipeline === void 0 || this.backend.needsRenderUpdate(renderObject);
  }
};
var Pipelines_default = Pipelines;

// node_modules/three/examples/jsm/renderers/common/Bindings.js
var Bindings = class extends DataMap_default {
  constructor(backend, nodes, textures, attributes, pipelines, info) {
    super();
    this.backend = backend;
    this.textures = textures;
    this.pipelines = pipelines;
    this.attributes = attributes;
    this.nodes = nodes;
    this.info = info;
    this.pipelines.bindings = this;
  }
  getForRender(renderObject) {
    const bindings = renderObject.getBindings();
    const data = this.get(renderObject);
    if (data.bindings !== bindings) {
      data.bindings = bindings;
      this._init(bindings);
      this.backend.createBindings(bindings);
    }
    return data.bindings;
  }
  getForCompute(computeNode) {
    const data = this.get(computeNode);
    if (data.bindings === void 0) {
      const nodeBuilderState = this.nodes.getForCompute(computeNode);
      const bindings = nodeBuilderState.bindings;
      data.bindings = bindings;
      this._init(bindings);
      this.backend.createBindings(bindings);
    }
    return data.bindings;
  }
  updateForCompute(computeNode) {
    this._update(computeNode, this.getForCompute(computeNode));
  }
  updateForRender(renderObject) {
    this._update(renderObject, this.getForRender(renderObject));
  }
  _init(bindings) {
    for (const binding of bindings) {
      if (binding.isSampledTexture) {
        this.textures.updateTexture(binding.texture);
      } else if (binding.isStorageBuffer) {
        const attribute2 = binding.attribute;
        this.attributes.update(attribute2, AttributeType.STORAGE);
      }
    }
  }
  _update(object, bindings) {
    const { backend } = this;
    let needsBindingsUpdate = false;
    for (const binding of bindings) {
      if (binding.isNodeUniformsGroup) {
        const updated = this.nodes.updateGroup(binding);
        if (!updated) continue;
      }
      if (binding.isUniformBuffer) {
        const updated = binding.update();
        if (updated) {
          backend.updateBinding(binding);
        }
      } else if (binding.isSampler) {
        binding.update();
      } else if (binding.isSampledTexture) {
        const texture2 = binding.texture;
        if (binding.needsBindingsUpdate) needsBindingsUpdate = true;
        const updated = binding.update();
        if (updated) {
          this.textures.updateTexture(binding.texture);
        }
        const textureData = backend.get(binding.texture);
        if (backend.isWebGPUBackend === true && textureData.texture === void 0 && textureData.externalTexture === void 0) {
          console.error("Bindings._update: binding should be available:", binding, updated, binding.texture, binding.textureNode.value);
          this.textures.updateTexture(binding.texture);
          needsBindingsUpdate = true;
        }
        if (texture2.isStorageTexture === true) {
          const textureData2 = this.get(texture2);
          if (binding.store === true) {
            textureData2.needsMipmap = true;
          } else if (texture2.generateMipmaps === true && this.textures.needsMipmaps(texture2) && textureData2.needsMipmap === true) {
            this.backend.generateMipmaps(texture2);
            textureData2.needsMipmap = false;
          }
        }
      }
    }
    if (needsBindingsUpdate === true) {
      const pipeline = this.pipelines.getForRender(object);
      this.backend.updateBindings(bindings, pipeline);
    }
  }
};
var Bindings_default = Bindings;

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["setup", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
function getCacheKey(object, force = false) {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += object.id;
  }
  for (const { property: property2, childNode } of getNodeChildren(object)) {
    cacheKey += "," + property2.slice(0, -4) + ":" + childNode.getCacheKey(force);
  }
  cacheKey += "}";
  return cacheKey;
}
function* getNodeChildren(node, toJSON = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true) continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4") params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}

// node_modules/three/examples/jsm/nodes/core/Node.js
var NodeClasses = /* @__PURE__ */ new Map();
var _nodeId = 0;
var Node = class extends EventDispatcher {
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    this.global = false;
    this.isNode = true;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this.getSelf());
    return this;
  }
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  onReference(callback) {
    this.updateReference = callback.bind(this.getSelf());
    return this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  getCacheKey(force = false) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      this._cacheKey = getCacheKey(this, force);
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  getShared(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index++] = childNode;
    }
    return null;
  }
  construct(builder) {
    console.warn("THREE.Node: construct() is deprecated. Use setup() instead.");
    return this.setup(builder);
  }
  increaseUsage(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.usageCount = nodeData.usageCount === void 0 ? 1 : nodeData.usageCount + 1;
    return nodeData.usageCount;
  }
  analyze(builder) {
    const usageCount = this.increaseUsage(builder);
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output2 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        const stackNodesBeforeSetup = builder.stack.nodes.length;
        properties.initialized = true;
        properties.outputNode = this.setup(builder);
        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) {
          properties.outputNode = builder.stack;
        }
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output2);
      } else {
        result = this.generate(builder, output2) || "";
      }
    }
    builder.removeChain(this);
    return result;
  }
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;
function addNodeClass(type, nodeClass) {
  if (typeof nodeClass !== "function" || !type) throw new Error(`Node class ${type} is not a class`);
  if (NodeClasses.has(type)) {
    console.warn(`Redefinition of node class ${type}`);
    return;
  }
  NodeClasses.set(type, nodeClass);
  nodeClass.type = type;
}

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (builder.context.tempWrite !== false && type !== "void" && output2 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
};
var TempNode_default = TempNode;
addNodeClass("TempNode", TempNode);

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;
addNodeClass("ArrayElementNode", ArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
};
var ConvertNode_default = ConvertNode;
addNodeClass("ConvertNode", ConvertNode);

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends TempNode_default {
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    for (const input of nodes) {
      let inputSnippet = input.build(builder);
      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));
      if (inputPrimitiveType !== primitiveType) {
        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
};
var JoinNode_default = JoinNode;
addNodeClass("JoinNode", JoinNode);

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output2);
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;
addNodeClass("SplitNode", SplitNode);

// node_modules/three/examples/jsm/nodes/utils/SetNode.js
var SetNode = class extends TempNode_default {
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const targetType = builder.getTypeFromLength(components.length);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var SetNode_default = SetNode;
addNodeClass("SetNode", SetNode);

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;
addNodeClass("InputNode", InputNode);

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output2);
  }
};
var ConstNode_default = ConstNode;
addNodeClass("ConstNode", ConstNode);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addNodeElement(name, nodeElement) {
  if (NodeElements.has(name)) {
    console.warn(`Redefinition of node element ${name}`);
    return;
  }
  if (typeof nodeElement !== "function") throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var shaderNodeHandler = {
  setup(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (node.isStackNode !== true && prop === "assign") {
        return (...params) => {
          currentStack.assign(nodeObj, ...params);
          return nodeObj;
        };
      } else if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "self") {
        return node;
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop);
        return nodeObject(new SplitNode_default(nodeObj, prop));
      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop.slice(3).toLowerCase());
        prop = prop.split("").sort().join("");
        return (value) => nodeObject(new SetNode_default(node, prop, value));
      } else if (prop === "width" || prop === "height" || prop === "depth") {
        if (prop === "width") prop = "x";
        else if (prop === "height") prop = "y";
        else if (prop === "depth") prop = "z";
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(nodeObj, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return Reflect.get(node, prop, nodeObj);
  },
  set(node, prop, value, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === "width" || prop === "height" || prop === "depth" || /^\d+$/.test(prop) === true) {
        nodeObj[prop].assign(value);
        return true;
      }
    }
    return Reflect.set(node, prop, value, nodeObj);
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return tslFn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderCallNodeInternal = class extends Node_default {
  constructor(shaderNode, inputNodes) {
    super();
    this.shaderNode = shaderNode;
    this.inputNodes = inputNodes;
  }
  getNodeType(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode === null) {
      properties.outputNode = this.setupOutput(builder);
    }
    return properties.outputNode.getNodeType(builder);
  }
  call(builder) {
    const { shaderNode, inputNodes } = this;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      if (builder.currentFunctionNode !== null) {
        builder.currentFunctionNode.includes.push(functionNode);
      }
      return nodeObject(functionNode.call(inputNodes));
    }
    const jsFunc = shaderNode.jsFunc;
    const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder.stack, builder) : jsFunc(builder.stack, builder);
    return nodeObject(outputNode);
  }
  setup(builder) {
    const { outputNode } = builder.getNodeProperties(this);
    return outputNode || this.setupOutput(builder);
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode === null) {
      return this.call(builder).build(builder, output2);
    }
    return super.generate(builder, output2);
  }
};
var ShaderNodeInternal = class extends Node_default {
  constructor(jsFunc) {
    super();
    this.jsFunc = jsFunc;
    this.layout = null;
  }
  get isArrayInput() {
    return /^\((\s+)?\[/.test(this.jsFunc.toString());
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(inputs = null) {
    nodeObjects(inputs);
    return nodeObject(new ShaderCallNodeInternal(this, inputs));
  }
  setup() {
    return this.call();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools) boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints) uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints) intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats) floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats) floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value, type);
  }
};
var safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch (_) {
    return void 0;
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type) return nodeObject(node);
      return nodeObject(new ConvertNode_default(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode_default(nodes, type));
  };
};
var defined = (value) => value && value.value;
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc) {
  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (...params) => new ShaderNodeProxy(...params);
var nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
var tslFn = (jsFunc) => {
  const shaderNode = new ShaderNode(jsFunc);
  const fn = (...params) => {
    let inputs;
    nodeObjects(params);
    if (params[0] && params[0].isNode) {
      inputs = [...params];
    } else {
      inputs = params[0];
    }
    return shaderNode.call(inputs);
  };
  fn.shaderNode = shaderNode;
  fn.setLayout = (layout) => {
    shaderNode.setLayout(layout);
    return fn;
  };
  return fn;
};
addNodeClass("ShaderNode", ShaderNode);
addNodeElement("toGlobal", (node) => {
  node.global = true;
  return node;
});
var setCurrentStack = (stack2) => {
  if (currentStack === stack2) {
  }
  currentStack = stack2;
};
var getCurrentStack = () => currentStack;
var If = (...params) => currentStack.if(...params);
function append(node) {
  if (currentStack) currentStack.add(node);
  return node;
}
addNodeElement("append", append);
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.ints);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat2 = new ConvertType("mat2");
var imat2 = new ConvertType("imat2");
var umat2 = new ConvertType("umat2");
var bmat2 = new ConvertType("bmat2");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
addNodeElement("toColor", color);
addNodeElement("toFloat", float);
addNodeElement("toInt", int);
addNodeElement("toUint", uint);
addNodeElement("toBool", bool);
addNodeElement("toVec2", vec2);
addNodeElement("toIvec2", ivec2);
addNodeElement("toUvec2", uvec2);
addNodeElement("toBvec2", bvec2);
addNodeElement("toVec3", vec3);
addNodeElement("toIvec3", ivec3);
addNodeElement("toUvec3", uvec3);
addNodeElement("toBvec3", bvec3);
addNodeElement("toVec4", vec4);
addNodeElement("toIvec4", ivec4);
addNodeElement("toUvec4", uvec4);
addNodeElement("toBvec4", bvec4);
addNodeElement("toMat2", mat2);
addNodeElement("toImat2", imat2);
addNodeElement("toUmat2", umat2);
addNodeElement("toBmat2", bmat2);
addNodeElement("toMat3", mat3);
addNodeElement("toImat3", imat3);
addNodeElement("toUmat3", umat3);
addNodeElement("toBmat3", bmat3);
addNodeElement("toMat4", mat4);
addNodeElement("toImat4", imat4);
addNodeElement("toUmat4", umat4);
addNodeElement("toBmat4", bmat4);
var element = nodeProxy(ArrayElementNode_default);
var convert = (node, types) => nodeObject(new ConvertNode_default(nodeObject(node), types));
addNodeElement("element", element);
addNodeElement("convert", convert);

// node_modules/three/examples/jsm/nodes/core/AssignNode.js
var AssignNode = class extends TempNode_default {
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
  }
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output2) {
    return output2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDiferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDiferentVector;
    }
    return false;
  }
  generate(builder, output2) {
    const { targetNode, sourceNode } = this;
    const needsSplitAssign = this.needsSplitAssign(builder);
    const targetType = targetNode.getNodeType(builder);
    const target = targetNode.context({ assign: true }).build(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output2 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`);
      const targetRoot = targetNode.node.context({ assign: true }).build(builder);
      for (let i = 0; i < targetNode.components.length; i++) {
        const component = targetNode.components[i];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`);
      }
      if (output2 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output2 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet);
        if (output2 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output2);
  }
};
var assign = nodeProxy(AssignNode);
addNodeClass("AssignNode", AssignNode);
addNodeElement("assign", assign);

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying2 = properties.varying;
    if (varying2 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      properties.varying = varying2 = builder.getVaryingFromNode(this, name, type);
      properties.node = this.node;
    }
    varying2.needsInterpolation || (varying2.needsInterpolation = builder.shaderStage === "fragment");
    return varying2;
  }
  setup(builder) {
    this.setupVarying(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const varying2 = this.setupVarying(builder);
    if (properties.propertyName === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying2, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);
      properties.propertyName = propertyName;
    }
    return builder.getPropertyName(varying2);
  }
};
var varying = nodeProxy(VaryingNode);
addNodeElement("varying", varying);
addNodeClass("VaryingNode", VaryingNode);

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null, defaultNode = null) {
    super(nodeType);
    this.defaultNode = defaultNode;
    this._attributeName = attributeName;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
      const { defaultNode } = this;
      if (defaultNode !== null) {
        return defaultNode.build(builder, nodeType);
      } else {
        return builder.generateConst(nodeType);
      }
    }
  }
};
var AttributeNode_default = AttributeNode;
var attribute = (name, nodeType, defaultNode) => nodeObject(new AttributeNode(name, nodeType, nodeObject(defaultNode)));
addNodeClass("AttributeNode", AttributeNode);

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet);
    }
    return this.outputNode.build(builder);
  }
};
var bypass = nodeProxy(BypassNode);
addNodeElement("bypass", bypass);
addNodeClass("BypassNode", BypassNode);

// node_modules/three/examples/jsm/nodes/core/NodeCache.js
var id2 = 0;
var NodeCache = class {
  constructor() {
    this.id = id2++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(node) {
    return this.nodesData.get(node);
  }
  setNodeData(node, data) {
    this.nodesData.set(node, data);
  }
};
var NodeCache_default = NodeCache;

// node_modules/three/examples/jsm/nodes/core/CacheNode.js
var CacheNode = class extends Node_default {
  constructor(node, cache2 = new NodeCache_default()) {
    super();
    this.isCacheNode = true;
    this.node = node;
    this.cache = cache2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache2 = this.cache || builder.globalCache;
    builder.setCache(cache2);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var cache = nodeProxy(CacheNode);
var globalCache = (node) => cache(node, null);
addNodeElement("cache", cache);
addNodeElement("globalCache", globalCache);
addNodeClass("CacheNode", CacheNode);

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  analyze(builder) {
    this.node.build(builder);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output2) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;
var context = nodeProxy(ContextNode);
var label = (node, name) => context(node, { label: name });
addNodeElement("context", context);
addNodeElement("label", label);
addNodeClass("ContextNode", ContextNode);

// node_modules/three/examples/jsm/nodes/core/IndexNode.js
var IndexNode = class _IndexNode extends Node_default {
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
addNodeClass("IndexNode", IndexNode);

// node_modules/three/examples/jsm/nodes/core/LightingModel.js
var LightingModel = class {
  start() {
  }
  finish() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
};
var LightingModel_default = LightingModel;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVarNode = true;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { node, name } = this;
    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));
    const propertyName = builder.getPropertyName(nodeVar);
    const snippet = node.build(builder, nodeVar.type);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var temp = nodeProxy(VarNode);
addNodeElement("temp", temp);
addNodeElement("toVar", (...params) => temp(...params).append());
addNodeClass("VarNode", VarNode);

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node.getSelf();
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class extends NodeVar_default {
  constructor(name, type) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = {};
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var PropertyNode_default = PropertyNode;
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var alphaT = nodeImmutable(PropertyNode, "float", "AlphaT");
var anisotropy = nodeImmutable(PropertyNode, "float", "Anisotropy");
var anisotropyT = nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
var anisotropyB = nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var specularF90 = nodeImmutable(PropertyNode, "float", "SpecularF90");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
var ior = nodeImmutable(PropertyNode, "float", "IOR");
var transmission = nodeImmutable(PropertyNode, "float", "Transmission");
var thickness = nodeImmutable(PropertyNode, "float", "Thickness");
var attenuationDistance = nodeImmutable(PropertyNode, "float", "AttenuationDistance");
var attenuationColor = nodeImmutable(PropertyNode, "color", "AttenuationColor");
var dispersion = nodeImmutable(PropertyNode, "float", "Dispersion");
addNodeClass("PropertyNode", PropertyNode);

// node_modules/three/examples/jsm/nodes/core/ParameterNode.js
var ParameterNode = class extends PropertyNode_default {
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
};
var ParameterNode_default = ParameterNode;
addNodeClass("ParameterNode", ParameterNode);

// node_modules/three/examples/jsm/nodes/code/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this.language = language;
    this.includes = includes;
  }
  isGlobal() {
    return true;
  }
  setIncludes(includes) {
    this.includes = includes;
    return this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var CodeNode_default = CodeNode;
var code = nodeProxy(CodeNode);
addNodeClass("CodeNode", CodeNode);

// node_modules/three/examples/jsm/nodes/code/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes = [], language = "") {
    super(code2, includes, language);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2 + "\n";
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
};
var FunctionNode_default = FunctionNode;
addNodeClass("FunctionNode", FunctionNode);

// node_modules/three/examples/jsm/nodes/core/UniformGroupNode.js
var UniformGroupNode = class extends Node_default {
  constructor(name, shared = false) {
    super("string");
    this.name = name;
    this.version = 0;
    this.shared = shared;
    this.isUniformGroup = true;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
};
var uniformGroup = (name) => new UniformGroupNode(name);
var sharedUniformGroup = (name) => new UniformGroupNode(name, true);
var frameGroup = sharedUniformGroup("frame");
var renderGroup = sharedUniformGroup("render");
var objectGroup = uniformGroup("object");
addNodeClass("UniformGroupNode", UniformGroupNode);

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.groupNode = objectGroup;
  }
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    const self2 = this.getSelf();
    callback = callback.bind(self2);
    return super.onUpdate((frame) => {
      const value = callback(frame, self2);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, builder.context.label);
    const propertyName = builder.getPropertyName(nodeUniform);
    if (builder.context.label !== void 0) delete builder.context.label;
    return builder.format(propertyName, type, output2);
  }
};
var UniformNode_default = UniformNode;
var uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
addNodeClass("UniformNode", UniformNode);

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var uv = (index) => attribute("uv" + (index > 0 ? index : ""), "vec2");

// node_modules/three/examples/jsm/nodes/accessors/TextureSizeNode.js
var TextureSizeNode = class extends Node_default {
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const levelNode = this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${levelNode} )`, this.getNodeType(builder), output2);
  }
};
var textureSize = nodeProxy(TextureSizeNode);
addNodeElement("textureSize", textureSize);
addNodeClass("TextureSizeNode", TextureSizeNode);

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output2 ? builder.getTypeLength(output2) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output2);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = typeof bNode !== "undefined" ? bNode.build(builder, typeB) : null;
    const outputLength = builder.getTypeLength(output2);
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output2 !== "void") {
      if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output2);
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output2);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output2);
      } else {
        return builder.format(`( ${a} ${op} ${b} )`, type, output2);
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output2);
      } else {
        return builder.format(`${a} ${op} ${b}`, type, output2);
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var remainder = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var notEqual = nodeProxy(OperatorNode, "!=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var not = nodeProxy(OperatorNode, "!");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitNot = nodeProxy(OperatorNode, "~");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addNodeElement("add", add);
addNodeElement("sub", sub);
addNodeElement("mul", mul);
addNodeElement("div", div);
addNodeElement("remainder", remainder);
addNodeElement("equal", equal);
addNodeElement("notEqual", notEqual);
addNodeElement("lessThan", lessThan);
addNodeElement("greaterThan", greaterThan);
addNodeElement("lessThanEqual", lessThanEqual);
addNodeElement("greaterThanEqual", greaterThanEqual);
addNodeElement("and", and);
addNodeElement("or", or);
addNodeElement("not", not);
addNodeElement("xor", xor);
addNodeElement("bitAnd", bitAnd);
addNodeElement("bitNot", bitNot);
addNodeElement("bitOr", bitOr);
addNodeElement("bitXor", bitXor);
addNodeElement("shiftLeft", shiftLeft);
addNodeElement("shiftRight", shiftRight);
addNodeClass("OperatorNode", OperatorNode);

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else if (method === _MathNode.ALL) {
      return "bool";
    } else if (method === _MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else if (method === _MathNode.MOD) {
      return this.aNode.getNodeType(builder);
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output2) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output2);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output2);
    } else if (method === _MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output2);
    } else if (method === _MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output2);
    } else if (method === _MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output2);
    } else {
      const params = [];
      if (method === _MathNode.CROSS || method === _MathNode.MOD) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c !== null) params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method, type)}( ${params.join(", ")} )`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.EQUALS = "equals";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.BITCAST = "bitcast";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var MathNode_default = MathNode;
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var PI = float(Math.PI);
var PI2 = float(Math.PI * 2);
var all = nodeProxy(MathNode, MathNode.ALL);
var any = nodeProxy(MathNode, MathNode.ANY);
var equals = nodeProxy(MathNode, MathNode.EQUALS);
var radians = nodeProxy(MathNode, MathNode.RADIANS);
var degrees = nodeProxy(MathNode, MathNode.DEGREES);
var exp = nodeProxy(MathNode, MathNode.EXP);
var exp2 = nodeProxy(MathNode, MathNode.EXP2);
var log = nodeProxy(MathNode, MathNode.LOG);
var log2 = nodeProxy(MathNode, MathNode.LOG2);
var sqrt = nodeProxy(MathNode, MathNode.SQRT);
var inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);
var floor = nodeProxy(MathNode, MathNode.FLOOR);
var ceil = nodeProxy(MathNode, MathNode.CEIL);
var normalize = nodeProxy(MathNode, MathNode.NORMALIZE);
var fract = nodeProxy(MathNode, MathNode.FRACT);
var sin = nodeProxy(MathNode, MathNode.SIN);
var cos = nodeProxy(MathNode, MathNode.COS);
var tan = nodeProxy(MathNode, MathNode.TAN);
var asin = nodeProxy(MathNode, MathNode.ASIN);
var acos = nodeProxy(MathNode, MathNode.ACOS);
var atan = nodeProxy(MathNode, MathNode.ATAN);
var abs = nodeProxy(MathNode, MathNode.ABS);
var sign = nodeProxy(MathNode, MathNode.SIGN);
var length = nodeProxy(MathNode, MathNode.LENGTH);
var negate = nodeProxy(MathNode, MathNode.NEGATE);
var oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);
var dFdx = nodeProxy(MathNode, MathNode.DFDX);
var dFdy = nodeProxy(MathNode, MathNode.DFDY);
var round = nodeProxy(MathNode, MathNode.ROUND);
var reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);
var trunc = nodeProxy(MathNode, MathNode.TRUNC);
var fwidth = nodeProxy(MathNode, MathNode.FWIDTH);
var bitcast = nodeProxy(MathNode, MathNode.BITCAST);
var atan2 = nodeProxy(MathNode, MathNode.ATAN2);
var min = nodeProxy(MathNode, MathNode.MIN);
var max = nodeProxy(MathNode, MathNode.MAX);
var mod = nodeProxy(MathNode, MathNode.MOD);
var step = nodeProxy(MathNode, MathNode.STEP);
var reflect = nodeProxy(MathNode, MathNode.REFLECT);
var distance = nodeProxy(MathNode, MathNode.DISTANCE);
var difference = nodeProxy(MathNode, MathNode.DIFFERENCE);
var dot = nodeProxy(MathNode, MathNode.DOT);
var cross = nodeProxy(MathNode, MathNode.CROSS);
var pow = nodeProxy(MathNode, MathNode.POW);
var pow2 = nodeProxy(MathNode, MathNode.POW, 2);
var pow3 = nodeProxy(MathNode, MathNode.POW, 3);
var pow4 = nodeProxy(MathNode, MathNode.POW, 4);
var transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
var cbrt = (a) => mul(sign(a), pow(abs(a), 1 / 3));
var lengthSq = (a) => dot(a, a);
var mix = nodeProxy(MathNode, MathNode.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate = (value) => clamp(value);
var refract = nodeProxy(MathNode, MathNode.REFRACT);
var smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);
var faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);
var mixElement = (t, e1, e2) => mix(e1, e2, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
addNodeElement("all", all);
addNodeElement("any", any);
addNodeElement("equals", equals);
addNodeElement("radians", radians);
addNodeElement("degrees", degrees);
addNodeElement("exp", exp);
addNodeElement("exp2", exp2);
addNodeElement("log", log);
addNodeElement("log2", log2);
addNodeElement("sqrt", sqrt);
addNodeElement("inverseSqrt", inverseSqrt);
addNodeElement("floor", floor);
addNodeElement("ceil", ceil);
addNodeElement("normalize", normalize);
addNodeElement("fract", fract);
addNodeElement("sin", sin);
addNodeElement("cos", cos);
addNodeElement("tan", tan);
addNodeElement("asin", asin);
addNodeElement("acos", acos);
addNodeElement("atan", atan);
addNodeElement("abs", abs);
addNodeElement("sign", sign);
addNodeElement("length", length);
addNodeElement("lengthSq", lengthSq);
addNodeElement("negate", negate);
addNodeElement("oneMinus", oneMinus);
addNodeElement("dFdx", dFdx);
addNodeElement("dFdy", dFdy);
addNodeElement("round", round);
addNodeElement("reciprocal", reciprocal);
addNodeElement("trunc", trunc);
addNodeElement("fwidth", fwidth);
addNodeElement("atan2", atan2);
addNodeElement("min", min);
addNodeElement("max", max);
addNodeElement("mod", mod);
addNodeElement("step", step);
addNodeElement("reflect", reflect);
addNodeElement("distance", distance);
addNodeElement("dot", dot);
addNodeElement("cross", cross);
addNodeElement("pow", pow);
addNodeElement("pow2", pow2);
addNodeElement("pow3", pow3);
addNodeElement("pow4", pow4);
addNodeElement("transformDirection", transformDirection);
addNodeElement("mix", mixElement);
addNodeElement("clamp", clamp);
addNodeElement("refract", refract);
addNodeElement("smoothstep", smoothstepElement);
addNodeElement("faceForward", faceForward);
addNodeElement("difference", difference);
addNodeElement("saturate", saturate);
addNodeElement("cbrt", cbrt);
addNodeClass("MathNode", MathNode);

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var sRGBToLinearShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = rgb.mul(0.0773993808);
  const factor = rgb.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var LinearTosRGBShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);
  const b = rgb.mul(12.92);
  const factor = rgb.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var getColorSpaceMethod = (colorSpace) => {
  let method = null;
  if (colorSpace === LinearSRGBColorSpace) {
    method = "Linear";
  } else if (colorSpace === SRGBColorSpace) {
    method = "sRGB";
  }
  return method;
};
var getMethod = (source, target) => {
  return getColorSpaceMethod(source) + "To" + getColorSpaceMethod(target);
};
var ColorSpaceNode = class _ColorSpaceNode extends TempNode_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  setup() {
    const { method, node } = this;
    if (method === _ColorSpaceNode.LINEAR_TO_LINEAR)
      return node;
    return Methods[method]({ value: node });
  }
};
ColorSpaceNode.LINEAR_TO_LINEAR = "LinearToLinear";
ColorSpaceNode.LINEAR_TO_sRGB = "LinearTosRGB";
ColorSpaceNode.sRGB_TO_LINEAR = "sRGBToLinear";
var Methods = {
  [ColorSpaceNode.LINEAR_TO_sRGB]: LinearTosRGBShader,
  [ColorSpaceNode.sRGB_TO_LINEAR]: sRGBToLinearShader
};
var linearToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(LinearSRGBColorSpace, colorSpace), nodeObject(node)));
var colorSpaceToLinear = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(colorSpace, LinearSRGBColorSpace), nodeObject(node)));
var linearTosRGB = nodeProxy(ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB);
var sRGBToLinear = nodeProxy(ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR);
addNodeElement("linearTosRGB", linearTosRGB);
addNodeElement("sRGBToLinear", sRGBToLinear);
addNodeElement("linearToColorSpace", linearToColorSpace);
addNodeElement("colorSpaceToLinear", colorSpaceToLinear);
addNodeClass("ColorSpaceNode", ColorSpaceNode);

// node_modules/three/examples/jsm/nodes/code/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet);
    } else {
      return builder.format(`( ${snippet} )`, type, output2);
    }
  }
};
var expression = nodeProxy(ExpressionNode);
addNodeClass("ExpressionNode", ExpressionNode);

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(textureNode) {
    super(0);
    this.textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var maxMipLevel = nodeProxy(MaxMipLevelNode);
addNodeClass("MaxMipLevelNode", MaxMipLevelNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    if (this.value.isDepthTexture === true) return "float";
    return "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return uv(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(uvNode) {
    const texture2 = this.value;
    return uniform(texture2.matrix).mul(vec3(uvNode, 1)).xy;
  }
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
    return this;
  }
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.isFlipY() && (texture2.isRenderTargetTexture === true || texture2.isFramebufferTexture === true || texture2.isDepthTexture === true)) {
      uvNode = uvNode.setY(uvNode.y.oneMinus());
    }
    return uvNode;
  }
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    let uvNode = this.uvNode;
    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    if (!uvNode) uvNode = this.getDefaultUV();
    if (this.updateMatrix === true) {
      uvNode = this.getTransformedUV(uvNode);
    }
    uvNode = this.setupUV(builder, uvNode);
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
  }
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet) {
    const texture2 = this.value;
    let snippet;
    if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet);
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, depthSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture2, textureProperty, uvSnippet, depthSnippet);
    } else {
      snippet = builder.generateTexture(texture2, textureProperty, uvSnippet, depthSnippet);
    }
    return snippet;
  }
  generate(builder, output2) {
    const properties = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "property");
    if (output2 === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, compareNode, depthNode, gradNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`);
        if (builder.context.tempWrite !== false) {
          nodeData.snippet = snippet2;
          nodeData.propertyName = propertyName;
        }
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsColorSpaceToLinear(texture2)) {
        snippet = colorSpaceToLinear(expression(snippet, nodeType), texture2.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = uvNode;
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  blur(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode;
    textureNode.referenceNode = this;
    return textureNode;
  }
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
  update() {
    const texture2 = this.value;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
  }
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    return newNode;
  }
};
var TextureNode_default = TextureNode;
var texture = nodeProxy(TextureNode);
var textureLoad = (...params) => texture(...params).setSampler(false);
addNodeElement("texture", texture);
addNodeClass("TextureNode", TextureNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;
var buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
addNodeClass("BufferNode", BufferNode);

// node_modules/three/examples/jsm/nodes/accessors/UniformsNode.js
var UniformsElementNode = class extends ArrayElementNode_default {
  constructor(arrayBuffer, indexNode) {
    super(arrayBuffer, indexNode);
    this.isArrayBufferElementNode = true;
  }
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    return builder.format(snippet, "vec4", type);
  }
};
var UniformsNode = class extends BufferNode_default {
  constructor(value, elementType = null) {
    super(null, "vec4");
    this.array = value;
    this.elementType = elementType;
    this._elementType = null;
    this._elementLength = 0;
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array, value } = this;
    const elementLength = this.getElementLength();
    const elementType = this.getElementType();
    if (elementLength === 1) {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        value[index] = array[i];
      }
    } else if (elementType === "color") {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        const vector = array[i];
        value[index] = vector.r;
        value[index + 1] = vector.g;
        value[index + 2] = vector.b || 0;
      }
    } else {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        const vector = array[i];
        value[index] = vector.x;
        value[index + 1] = vector.y;
        value[index + 2] = vector.z || 0;
        value[index + 3] = vector.w || 0;
      }
    }
  }
  setup(builder) {
    const length2 = this.array.length;
    this._elementType = this.elementType === null ? getValueType(this.array[0]) : this.elementType;
    this._elementLength = builder.getTypeLength(this._elementType);
    this.value = new Float32Array(length2 * 4);
    this.bufferCount = length2;
    return super.setup(builder);
  }
  element(indexNode) {
    return nodeObject(new UniformsElementNode(this, nodeObject(indexNode)));
  }
};
var uniforms = (values, nodeType) => nodeObject(new UniformsNode(values, nodeType));
addNodeClass("UniformsNode", UniformsNode);

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceElementNode = class extends ArrayElementNode_default {
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = null;
    this.node = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  element(indexNode) {
    return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));
  }
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniforms(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture(null);
    } else {
      node = uniform(null, uniformType);
    }
    this.node = node;
  }
  getNodeType(builder) {
    if (this.node === null) {
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  setup() {
    this.updateValue();
    return this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var ReferenceNode_default = ReferenceNode;
var reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
var referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));
addNodeClass("ReferenceNode", ReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
};
var materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));
addNodeClass("MaterialReferenceNode", MaterialReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var cameraNear = uniform("float").onRenderUpdate(({ camera }) => camera.near);
var cameraFar = uniform("float").onRenderUpdate(({ camera }) => camera.far);
var cameraLogDepth = uniform("float").onRenderUpdate(({ camera }) => 2 / (Math.log(camera.far + 1) / Math.LN2));
var cameraProjectionMatrix = uniform("mat4").onRenderUpdate(({ camera }) => camera.projectionMatrix);
var cameraProjectionMatrixInverse = uniform("mat4").onRenderUpdate(({ camera }) => camera.projectionMatrixInverse);
var cameraViewMatrix = uniform("mat4").onRenderUpdate(({ camera }) => camera.matrixWorldInverse);
var cameraWorldMatrix = uniform("mat4").onRenderUpdate(({ camera }) => camera.matrixWorld);
var cameraNormalMatrix = uniform("mat3").onRenderUpdate(({ camera }) => camera.normalMatrix);
var cameraPosition = uniform(new Vector3()).onRenderUpdate(({ camera }, self2) => self2.value.setFromMatrixPosition(camera.matrixWorld));

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.VIEW_MATRIX = "viewMatrix";
Object3DNode.NORMAL_MATRIX = "normalMatrix";
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var Object3DNode_default = Object3DNode;
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION);
var objectViewMatrix = nodeProxy(Object3DNode, Object3DNode.VIEW_MATRIX);
var objectNormalMatrix = nodeProxy(Object3DNode, Object3DNode.NORMAL_MATRIX);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);
addNodeClass("Object3DNode", Object3DNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelViewMatrix = nodeImmutable(ModelNode, ModelNode.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix");
var modelNormalMatrix = nodeImmutable(ModelNode, ModelNode.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
var modelWorldMatrixInverse = uniform(new Matrix4()).onObjectUpdate(({ object }, self2) => self2.value.copy(object.matrixWorld).invert());
addNodeClass("ModelNode", ModelNode);

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var normalGeometry = attribute("normal", "vec3", vec3(0, 1, 0));
var normalLocal = normalGeometry.toVar("normalLocal");
var normalView = varying(modelNormalMatrix.mul(normalLocal), "v_normalView").normalize().toVar("normalView");
var normalWorld = varying(normalView.transformDirection(cameraViewMatrix), "v_normalWorld").normalize().toVar("transformedNormalWorld");
var transformedNormalView = property("vec3", "transformedNormalView");
var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize().toVar("transformedNormalWorld");
var transformedClearcoatNormalView = property("vec3", "transformedClearcoatNormalView");

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _propertyCache = /* @__PURE__ */ new Map();
var MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getCache(property2, type) {
    let node = _propertyCache.get(property2);
    if (node === void 0) {
      node = materialReference(property2, type);
      _propertyCache.set(property2, node);
    }
    return node;
  }
  getFloat(property2) {
    return this.getCache(property2, "float");
  }
  getColor(property2) {
    return this.getCache(property2, "color");
  }
  getTexture(property2) {
    return this.getCache(property2 === "map" ? "map" : property2 + "Map", "texture");
  }
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.COLOR) {
      const colorNode = this.getColor(scope);
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensity = this.getFloat(scope);
      if (material.specularMap) {
        node = specularIntensity.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensity;
      }
    } else if (scope === _MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (material.specularColorMap && material.specularColorMap.isTexture === true) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveNode = this.getColor(scope);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = this.getTexture("normal").normalMap(this.getCache("normalScale", "vec2"));
      } else if (material.bumpMap) {
        node = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = this.getTexture(scope).normalMap(this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === _MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anisotropyPolar.b));
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference("1", "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference("0", "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === _MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === _MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === _MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_WIDTH = "pointWidth";
MaterialNode.DISPERSION = "dispersion";
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
var materialSpecularIntensity = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialNormal = nodeImmutable(MaterialNode, MaterialNode.NORMAL);
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialClearcoatNormal = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialAnisotropy = nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
var materialTransmission = nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
var materialThickness = nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
var materialIOR = nodeImmutable(MaterialNode, MaterialNode.IOR);
var materialAttenuationDistance = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
var materialAttenuationColor = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
var materialLineScale = nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
var materialLineDashSize = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
var materialLineGapSize = nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
var materialLineWidth = nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
var materialLineDashOffset = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
var materialPointWidth = nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);
var materialDispersion = nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
var materialAnisotropyVector = uniform(new Vector2()).onReference(function(frame) {
  return frame.material;
}).onRenderUpdate(function({ material }) {
  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
addNodeClass("MaterialNode", MaterialNode);

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var positionGeometry = attribute("position", "vec3");
var positionLocal = positionGeometry.toVar("positionLocal");
var positionWorld = varying(modelWorldMatrix.mul(positionLocal).xyz, "v_positionWorld");
var positionWorldDirection = varying(positionLocal.transformDirection(modelWorldMatrix), "v_positionWorldDirection").normalize().toVar("positionWorldDirection");
var positionView = varying(modelViewMatrix.mul(positionLocal).xyz, "v_positionView");
var positionViewDirection = varying(positionView.negate(), "v_positionViewDirection").normalize().toVar("positionViewDirection");

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends TempNode_default {
  constructor(positionNode = null) {
    super("vec4");
    this.positionNode = positionNode;
  }
  setup(builder) {
    if (builder.shaderStage === "fragment") {
      return varying(builder.context.mvp);
    }
    const position = this.positionNode || positionLocal;
    return cameraProjectionMatrix.mul(modelViewMatrix).mul(position);
  }
};
var modelViewProjection = nodeProxy(ModelViewProjectionNode);
addNodeClass("ModelViewProjectionNode", ModelViewProjectionNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferAttributeNode.js
var BufferAttributeNode = class extends InputNode_default {
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer2 = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output2 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
var bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
var dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
var instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);
var instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
addNodeElement("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
addNodeClass("BufferAttributeNode", BufferAttributeNode);

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
  }
  setup() {
    let instanceMatrixNode = this.instanceMatrixNode;
    const instanceMesh = this.instanceMesh;
    if (instanceMatrixNode === null) {
      const instanceAttribute = instanceMesh.instanceMatrix;
      const buffer2 = new InstancedInterleavedBuffer(instanceAttribute.array, 16, 1);
      const bufferFn = instanceAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      const instanceBuffers = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        bufferFn(buffer2, "vec4", 16, 0),
        bufferFn(buffer2, "vec4", 16, 4),
        bufferFn(buffer2, "vec4", 16, 8),
        bufferFn(buffer2, "vec4", 16, 12)
      ];
      instanceMatrixNode = mat4(...instanceBuffers);
      this.instanceMatrixNode = instanceMatrixNode;
    }
    const instanceColorAttribute = instanceMesh.instanceColor;
    if (instanceColorAttribute && this.instanceColorNode === null) {
      const buffer2 = new InstancedBufferAttribute(instanceColorAttribute.array, 3);
      const bufferFn = instanceColorAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      this.instanceColorNode = vec3(bufferFn(buffer2, "vec3", 3, 0));
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = normalLocal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
    const instanceNormal = m.mul(transformedNormal).xyz;
    positionLocal.assign(instancePosition);
    normalLocal.assign(instanceNormal);
    if (this.instanceColorNode !== null) {
      varyingProperty("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
};
var instance = nodeProxy(InstanceNode);
addNodeClass("InstanceNode", InstanceNode);

// node_modules/three/examples/jsm/nodes/accessors/TangentNode.js
var tangentGeometry = tslFn((stack2, builder) => {
  if (builder.geometry.hasAttribute("tangent") === false) {
    builder.geometry.computeTangents();
  }
  return attribute("tangent", "vec4");
})();
var tangentLocal = tangentGeometry.xyz.toVar("tangentLocal");
var tangentView = varying(modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz, "v_tangentView").normalize().toVar("tangentView");
var tangentWorld = varying(tangentView.transformDirection(cameraViewMatrix), "v_tangentWorld").normalize().toVar("tangentWorld");
var transformedTangentView = tangentView.toVar("transformedTangentView");
var transformedTangentWorld = transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar("transformedTangentWorld");

// node_modules/three/examples/jsm/nodes/accessors/BatchNode.js
var BatchNode = class extends Node_default {
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.instanceColorNode = null;
    this.batchingIdNode = null;
  }
  setup(builder) {
    if (this.batchingIdNode === null) {
      this.batchingIdNode = attribute("batchId");
    }
    const matriceTexture = this.batchMesh._matricesTexture;
    const size = textureSize(textureLoad(matriceTexture), 0);
    const j = float(int(this.batchingIdNode)).mul(4).toVar();
    const x = int(j.mod(size));
    const y = int(j).div(int(size));
    const batchingMatrix = mat4(
      textureLoad(matriceTexture, ivec2(x, y)),
      textureLoad(matriceTexture, ivec2(x.add(1), y)),
      textureLoad(matriceTexture, ivec2(x.add(2), y)),
      textureLoad(matriceTexture, ivec2(x.add(3), y))
    );
    const bm = mat3(
      batchingMatrix[0].xyz,
      batchingMatrix[1].xyz,
      batchingMatrix[2].xyz
    );
    positionLocal.assign(batchingMatrix.mul(positionLocal));
    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
};
var batch = nodeProxy(BatchNode);
addNodeClass("batch", BatchNode);

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh, useReference = false) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.useReference = useReference;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;
    if (useReference) {
      bindMatrixNode = reference("bindMatrix", "mat4");
      bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
      boneMatricesNode = referenceBuffer("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    } else {
      bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
      bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
      boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
    }
    this.bindMatrixNode = bindMatrixNode;
    this.bindMatrixInverseNode = bindMatrixInverseNode;
    this.boneMatricesNode = boneMatricesNode;
  }
  setup(builder) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode, boneMatricesNode } = this;
    const boneMatX = boneMatricesNode.element(skinIndexNode.x);
    const boneMatY = boneMatricesNode.element(skinIndexNode.y);
    const boneMatZ = boneMatricesNode.element(skinIndexNode.z);
    const boneMatW = boneMatricesNode.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(positionLocal);
    const skinned = add(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    const skinPosition = bindMatrixInverseNode.mul(skinned).xyz;
    let skinMatrix = add(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    const skinNormal = skinMatrix.transformDirection(normalLocal).xyz;
    positionLocal.assign(skinPosition);
    normalLocal.assign(skinNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.assign(skinNormal);
    }
  }
  generate(builder, output2) {
    if (output2 !== "void") {
      return positionLocal.build(builder, output2);
    }
  }
  update(frame) {
    const object = this.useReference ? frame.object : this.skinnedMesh;
    object.skeleton.update();
  }
};
var skinningReference = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh, true));
addNodeClass("SkinningNode", SkinningNode);

// node_modules/three/examples/jsm/nodes/utils/LoopNode.js
var LoopNode = class extends Node_default {
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0) return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    properties.returnsNode = this.params[this.params.length - 1](inputs, builder.addStack(), builder);
    properties.stackNode = builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const contextData = { tempWrite: false };
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let start = null, end = null, name = null, type = null, condition = null, update = null;
      if (param.isNode) {
        type = "int";
        name = this.getVarName(i);
        start = "0";
        end = param.build(builder, type);
        condition = "<";
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number") start = start.toString();
        else if (start && start.isNode) start = start.build(builder, type);
        if (typeof end === "number") end = end.toString();
        else if (end && end.isNode) end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      const internalParam = { start, end, condition };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      if (!update) {
        if (type === "int" || type === "uint") {
          if (condition.includes("<")) update = "++";
          else update = "--";
        } else {
          if (condition.includes("<")) update = "+= 1.";
          else update = "-= 1.";
        }
      }
      declarationSnippet += builder.getVar(type, name) + " = " + startSnippet;
      conditionalSnippet += name + " " + condition + " " + endSnippet;
      updateSnippet += name + " " + update;
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = context(stackNode, contextData).build(builder, "void");
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int"))).append();
var Break = () => expression("break").append();
addNodeElement("loop", (returns, ...params) => bypass(returns, loop(...params)));
addNodeClass("LoopNode", LoopNode);

// node_modules/three/examples/jsm/nodes/accessors/MorphNode.js
var morphTextures = /* @__PURE__ */ new WeakMap();
var morphVec4 = new Vector4();
var getMorph = tslFn(({ bufferMap, influence, stride, width, depth: depth2, offset }) => {
  const texelIndex = int(vertexIndex).mul(stride).add(offset);
  const y = texelIndex.div(width);
  const x = texelIndex.sub(y.mul(width));
  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth2);
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0) entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true) vertexDataCount = 1;
    if (hasMorphNormals === true) vertexDataCount = 2;
    if (hasMorphColors === true) vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer2, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i = 0; i < morphTargetsCount; i++) {
      const morphTarget = morphTargets[i];
      const morphNormal = morphNormals[i];
      const morphColor = morphColors[i];
      const offset = width * height * 4 * i;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          morphVec4.fromBufferAttribute(morphTarget, j);
          buffer2[offset + stride + 0] = morphVec4.x;
          buffer2[offset + stride + 1] = morphVec4.y;
          buffer2[offset + stride + 2] = morphVec4.z;
          buffer2[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          morphVec4.fromBufferAttribute(morphNormal, j);
          buffer2[offset + stride + 4] = morphVec4.x;
          buffer2[offset + stride + 5] = morphVec4.y;
          buffer2[offset + stride + 6] = morphVec4.z;
          buffer2[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          morphVec4.fromBufferAttribute(morphColor, j);
          buffer2[offset + stride + 8] = morphVec4.x;
          buffer2[offset + stride + 9] = morphVec4.y;
          buffer2[offset + stride + 10] = morphVec4.z;
          buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
var MorphNode = class extends Node_default {
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size.width);
    loop(morphTargetsCount, ({ i }) => {
      const influence = float(0).toVar();
      if (this.mesh.isInstancedMesh === true && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {
        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);
      } else {
        influence.assign(reference("morphTargetInfluences", "float").element(i).toVar());
      }
      if (hasMorphPosition === true) {
        positionLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: i,
          offset: int(0)
        }));
      }
      if (hasMorphNormals === true) {
        normalLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: i,
          offset: int(1)
        }));
      }
    });
  }
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
};
var morphReference = nodeProxy(MorphNode);
addNodeClass("MorphNode", MorphNode);

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var reflectView = positionViewDirection.negate().reflect(transformedNormalView);
var reflectVector = reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector");

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return reflectVector;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture2.isRenderTargetTexture) {
      return vec3(uvNode.x.negate(), uvNode.yz);
    } else {
      return uvNode;
    }
  }
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, "vec3");
  }
};
var cubeTexture = nodeProxy(CubeTextureNode);
addNodeElement("cubeTexture", cubeTexture);
addNodeClass("CubeTextureNode", CubeTextureNode);

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;
addNodeClass("LightingNode", LightingNode);

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var overrideMaterial = null;
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.FRAME;
    this.light = light;
    this.rtt = null;
    this.shadowNode = null;
    this.shadowMaskNode = null;
    this.color = new Color();
    this._defaultColorNode = uniform(this.color);
    this.colorNode = this._defaultColorNode;
    this.isAnalyticLightNode = true;
  }
  getCacheKey() {
    return super.getCacheKey() + "-" + (this.light.id + "-" + (this.light.castShadow ? "1" : "0"));
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(builder) {
    const { object } = builder;
    if (object.receiveShadow === false) return;
    let shadowNode = this.shadowNode;
    if (shadowNode === null) {
      if (overrideMaterial === null) {
        overrideMaterial = builder.createNodeMaterial();
        overrideMaterial.fragmentNode = vec4(0, 0, 0, 1);
        overrideMaterial.isShadowNodeMaterial = true;
      }
      const shadow = this.light.shadow;
      const rtt = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
      const depthTexture2 = new DepthTexture();
      depthTexture2.minFilter = NearestFilter;
      depthTexture2.magFilter = NearestFilter;
      depthTexture2.image.width = shadow.mapSize.width;
      depthTexture2.image.height = shadow.mapSize.height;
      depthTexture2.compareFunction = LessCompare;
      rtt.depthTexture = depthTexture2;
      shadow.camera.updateProjectionMatrix();
      const bias = reference("bias", "float", shadow);
      const normalBias = reference("normalBias", "float", shadow);
      const position = object.material.shadowPositionNode || positionWorld;
      let shadowCoord = uniform(shadow.matrix).mul(position.add(normalWorld.mul(normalBias)));
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
      let coordZ = shadowCoord.z.add(bias);
      if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
      shadowCoord = vec3(
        shadowCoord.x,
        shadowCoord.y.oneMinus(),
        // follow webgpu standards
        coordZ
      );
      const textureCompare = (depthTexture3, shadowCoord2, compare) => texture(depthTexture3, shadowCoord2).compare(compare);
      shadowNode = textureCompare(depthTexture2, shadowCoord.xy, shadowCoord.z);
      const shadowColor = texture(rtt.texture, shadowCoord);
      const shadowMaskNode = frustumTest.mix(1, shadowNode.mix(shadowColor.a.mix(1, shadowColor), 1));
      this.rtt = rtt;
      this.colorNode = this.colorNode.mul(shadowMaskNode);
      this.shadowNode = shadowNode;
      this.shadowMaskNode = shadowMaskNode;
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  setup(builder) {
    if (this.light.castShadow) this.setupShadow(builder);
    else if (this.shadowNode !== null) this.disposeShadow();
  }
  updateShadow(frame) {
    const { rtt, light } = this;
    const { renderer, scene, camera } = frame;
    const currentOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = overrideMaterial;
    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);
    light.shadow.updateMatrices(light);
    light.shadow.camera.layers.mask = camera.layers.mask;
    const currentToneMapping = renderer.toneMapping;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    renderer.setRenderObjectFunction((object, ...params) => {
      if (object.castShadow === true) {
        renderer.renderObject(object, ...params);
      }
    });
    renderer.setRenderTarget(rtt);
    renderer.toneMapping = NoToneMapping;
    renderer.render(scene, light.shadow.camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
    renderer.toneMapping = currentToneMapping;
    scene.overrideMaterial = currentOverrideMaterial;
  }
  disposeShadow() {
    this.rtt.dispose();
    this.shadowNode = null;
    this.shadowMaskNode = null;
    this.rtt = null;
    this.colorNode = this._defaultColorNode;
  }
  updateBefore(frame) {
    const { light } = this;
    if (light.castShadow) this.updateShadow(frame);
  }
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;
addNodeClass("AnalyticLightNode", AnalyticLightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var LightNodes = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.totalDiffuseNode = vec3().temp("totalDiffuse");
    this.totalSpecularNode = vec3().temp("totalSpecular");
    this.outgoingLightNode = vec3().temp("outgoingLight");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  getHash() {
    if (this._hash === null) {
      const hash2 = [];
      for (const lightNode of this.lightNodes) {
        hash2.push(lightNode.getHash());
      }
      this._hash = "lights-" + hash2.join(",");
    }
    return this._hash;
  }
  analyze(builder) {
    const properties = builder.getDataFromNode(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
  }
  setup(builder) {
    const context2 = builder.context;
    const lightingModel = context2.lightingModel;
    let outgoingLightNode = this.outgoingLightNode;
    if (lightingModel) {
      const { lightNodes, totalDiffuseNode, totalSpecularNode } = this;
      context2.outgoingLight = outgoingLightNode;
      const stack2 = builder.addStack();
      const properties = builder.getDataFromNode(this);
      properties.nodes = stack2.nodes;
      lightingModel.start(context2, stack2, builder);
      for (const lightNode of lightNodes) {
        lightNode.build(builder);
      }
      lightingModel.indirectDiffuse(context2, stack2, builder);
      lightingModel.indirectSpecular(context2, stack2, builder);
      lightingModel.ambientOcclusion(context2, stack2, builder);
      const { backdrop, backdropAlpha } = context2;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context2.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3(backdrop);
        }
        context2.material.transparent = true;
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(context2, stack2, builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    }
    return outgoingLightNode;
  }
  _getLightNodeById(id6) {
    for (const lightNode of this.lightNodes) {
      if (lightNode.isAnalyticLightNode && lightNode.light.id === id6) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2 = []) {
    const lightNodes = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this._getLightNodeById(light.id);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode_default;
        lightNode = nodeObject(new lightNodeClass(light));
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;
var lightsNode = nodeProxy(LightsNode);
function addLightNode(lightClass, lightNodeClass) {
  if (LightNodes.has(lightClass)) {
    console.warn(`Redefinition of light node ${lightNodeClass.type}`);
    return;
  }
  if (typeof lightClass !== "function") throw new Error(`Light ${lightClass.name} is not a class`);
  if (typeof lightNodeClass !== "function" || !lightNodeClass.type) throw new Error(`Light node ${lightNodeClass.type} is not a class`);
  LightNodes.set(lightClass, lightNodeClass);
}

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    const aoIntensity = 1;
    const aoNode = this.aoNode.x.sub(1).mul(aoIntensity).add(1);
    builder.context.ambientOcclusion.mulAssign(aoNode);
  }
};
var AONode_default = AONode;
addNodeClass("AONode", AONode);

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(node);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._context = null;
  }
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().temp("directDiffuse"), directSpecular = vec3().temp("directSpecular"), indirectDiffuse = vec3().temp("indirectDiffuse"), indirectSpecular = vec3().temp("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context2 = {
      radiance: vec3().temp("radiance"),
      irradiance: vec3().temp("irradiance"),
      iblIrradiance: vec3().temp("iblIrradiance"),
      ambientOcclusion: float(1).temp("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context2;
  }
  setup(builder) {
    this.context = this._context || (this._context = this.getContext());
    this.context.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
};
var lightingContext = nodeProxy(LightingContextNode);
addNodeElement("lightingContext", lightingContext);
addNodeClass("LightingContextNode", LightingContextNode);

// node_modules/three/examples/jsm/nodes/accessors/BitangentNode.js
var getBitangent = (crossNormalTangent) => crossNormalTangent.mul(tangentGeometry.w).xyz;
var bitangentGeometry = varying(getBitangent(normalGeometry.cross(tangentGeometry)), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
var bitangentLocal = varying(getBitangent(normalLocal.cross(tangentLocal)), "v_bitangentLocal").normalize().toVar("bitangentLocal");
var bitangentView = varying(getBitangent(normalView.cross(tangentView)), "v_bitangentView").normalize().toVar("bitangentView");
var bitangentWorld = varying(getBitangent(normalWorld.cross(tangentWorld)), "v_bitangentWorld").normalize().toVar("bitangentWorld");
var transformedBitangentView = getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar("transformedBitangentView");
var transformedBitangentWorld = transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar("transformedBitangentWorld");

// node_modules/three/examples/jsm/nodes/accessors/AccessorsUtils.js
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);
var parallaxDirection = positionViewDirection.mul(TBNViewMatrix);
var transformedBentNormalView = (() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
  return bentNormal;
})();

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { ifNode, elseNode } = this;
    const needsOutput = output2 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = context(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = context(ifNode, context2).build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = context(elseNode, context2).build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output2);
  }
};
var CondNode_default = CondNode;
var cond = nodeProxy(CondNode);
addNodeElement("cond", cond);
addNodeClass("CondNode", CondNode);

// node_modules/three/examples/jsm/nodes/pmrem/PMREMUtils.js
var cubeUV_r0 = float(1);
var cubeUV_m0 = float(-2);
var cubeUV_r1 = float(0.8);
var cubeUV_m1 = float(-1);
var cubeUV_r4 = float(0.4);
var cubeUV_m4 = float(2);
var cubeUV_r5 = float(0.305);
var cubeUV_m5 = float(3);
var cubeUV_r6 = float(0.21);
var cubeUV_m6 = float(4);
var cubeUV_minMipLevel = float(4);
var cubeUV_minTileSize = float(16);
var getFace = tslFn(([direction2]) => {
  const absDirection = vec3(abs(direction2)).toVar();
  const face = float(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(cond(direction2.x.greaterThan(0), 0, 3));
    }).else(() => {
      face.assign(cond(direction2.y.greaterThan(0), 1, 4));
    });
  }).else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(cond(direction2.z.greaterThan(0), 2, 5));
    }).else(() => {
      face.assign(cond(direction2.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
});
var getUV = tslFn(([direction2, face]) => {
  const uv2 = vec2().toVar();
  If(face.equal(0), () => {
    uv2.assign(vec2(direction2.z, direction2.y).div(abs(direction2.x)));
  }).elseif(face.equal(1), () => {
    uv2.assign(vec2(direction2.x.negate(), direction2.z.negate()).div(abs(direction2.y)));
  }).elseif(face.equal(2), () => {
    uv2.assign(vec2(direction2.x.negate(), direction2.y).div(abs(direction2.z)));
  }).elseif(face.equal(3), () => {
    uv2.assign(vec2(direction2.z.negate(), direction2.y).div(abs(direction2.x)));
  }).elseif(face.equal(4), () => {
    uv2.assign(vec2(direction2.x.negate(), direction2.z).div(abs(direction2.y)));
  }).else(() => {
    uv2.assign(vec2(direction2.x, direction2.y).div(abs(direction2.z)));
  });
  return mul(0.5, uv2.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
});
var roughnessToMip = tslFn(([roughness2]) => {
  const mip = float(0).toVar();
  If(roughness2.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(cubeUV_r0.sub(roughness2).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
  }).elseif(roughness2.greaterThanEqual(cubeUV_r4), () => {
    mip.assign(cubeUV_r1.sub(roughness2).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
  }).elseif(roughness2.greaterThanEqual(cubeUV_r5), () => {
    mip.assign(cubeUV_r4.sub(roughness2).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
  }).elseif(roughness2.greaterThanEqual(cubeUV_r6), () => {
    mip.assign(cubeUV_r5.sub(roughness2).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
  }).else(() => {
    mip.assign(float(-2).mul(log2(mul(1.16, roughness2))));
  });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
});
var getDirection = tslFn(([uv_immutable, face]) => {
  const uv2 = uv_immutable.toVar();
  uv2.assign(mul(2, uv2).sub(1));
  const direction2 = vec3(uv2, 1).toVar();
  If(face.equal(0), () => {
    direction2.assign(direction2.zyx);
  }).elseif(face.equal(1), () => {
    direction2.assign(direction2.xzy);
    direction2.xz.mulAssign(-1);
  }).elseif(face.equal(2), () => {
    direction2.x.mulAssign(-1);
  }).elseif(face.equal(3), () => {
    direction2.assign(direction2.zyx);
    direction2.xz.mulAssign(-1);
  }).elseif(face.equal(4), () => {
    direction2.assign(direction2.xzy);
    direction2.xy.mulAssign(-1);
  }).elseif(face.equal(5), () => {
    direction2.z.mulAssign(-1);
  });
  return direction2;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
});
var textureCubeUV = tslFn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const roughness2 = float(roughness_immutable);
  const sampleDir = vec3(sampleDir_immutable);
  const mip = clamp(roughnessToMip(roughness2), cubeUV_m0, CUBEUV_MAX_MIP);
  const mipF = fract(mip);
  const mipInt = floor(mip);
  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
  If(mipF.notEqual(0), () => {
    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    color0.assign(mix(color0, color1, mipF));
  });
  return color0;
});
var bilinearCubeUV = tslFn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const mipInt = float(mipInt_immutable).toVar();
  const direction2 = vec3(direction_immutable);
  const face = float(getFace(direction2)).toVar();
  const filterInt = float(max(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
  mipInt.assign(max(mipInt, cubeUV_minMipLevel));
  const faceSize = float(exp2(mipInt)).toVar();
  const uv2 = vec2(getUV(direction2, face).mul(faceSize.sub(2)).add(1)).toVar();
  If(face.greaterThan(2), () => {
    uv2.y.addAssign(faceSize);
    face.subAssign(3);
  });
  uv2.x.addAssign(face.mul(faceSize));
  uv2.x.addAssign(filterInt.mul(mul(3, cubeUV_minTileSize)));
  uv2.y.addAssign(mul(4, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
  uv2.x.mulAssign(CUBEUV_TEXEL_WIDTH);
  uv2.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
  return envMap.uv(uv2).grad(vec2(), vec2());
});
var getSample = tslFn(({ envMap, mipInt, outputDirection: outputDirection2, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const cosTheta = cos(theta);
  const sampleDirection = outputDirection2.mul(cosTheta).add(axis.cross(outputDirection2).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection2).mul(cosTheta.oneMinus())));
  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
var blur = tslFn(({ n, latitudinal, poleAxis, outputDirection: outputDirection2, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const axis = vec3(cond(latitudinal, poleAxis, cross(poleAxis, outputDirection2))).toVar();
  If(all(axis.equals(vec3(0))), () => {
    axis.assign(vec3(outputDirection2.z, 0, outputDirection2.x.negate()));
  });
  axis.assign(normalize(axis));
  const gl_FragColor = vec3().toVar();
  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({ theta: 0, axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  loop({ start: int(1), end: n }, ({ i }) => {
    If(i.greaterThanEqual(samples), () => {
      Break();
    });
    const theta = float(dTheta.mul(float(i))).toVar();
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: theta.mul(-1), axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  });
  return vec4(gl_FragColor, 1);
});

// node_modules/three/examples/jsm/nodes/pmrem/PMREMNode.js
var _generator = null;
var _cache = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture2) {
  let cacheTexture = _cache.get(texture2);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture2.pmremVersion) {
    if (texture2.isCubeTexture) {
      if (texture2.source.data.some((texture3) => texture3 === void 0)) {
        throw new Error("PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader");
      }
      cacheTexture = _generator.fromCubemap(texture2, cacheTexture);
    } else {
      if (texture2.image === void 0) {
        throw new Error("PMREMNode: Undefined image in Texture. Use onLoad callback or async loader");
      }
      cacheTexture = _generator.fromEquirectangular(texture2, cacheTexture);
    }
    cacheTexture.pmremVersion = texture2.pmremVersion;
    _cache.set(texture2, cacheTexture);
  }
  return cacheTexture.texture;
}
var PMREMNode = class extends TempNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    this._texture = texture(null);
    this._width = uniform(0);
    this._height = uniform(0);
    this._maxMip = uniform(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(texture2) {
    const cubeUVSize = _generateCubeUVSize(texture2.image.height);
    this._texture.value = texture2;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore() {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture2 = this._value;
    if (pmremVersion !== texture2.pmremVersion) {
      if (texture2.isPMREMTexture === true) {
        pmrem = texture2;
      } else {
        pmrem = _getPMREMFromTexture(texture2);
      }
      this._pmrem = pmrem;
      this.updateFromTexture(pmrem);
    }
  }
  setup(builder) {
    if (_generator === null) {
      _generator = builder.createPMREMGenerator();
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    const texture2 = this.value;
    if (builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture2.isPMREMTexture !== true && texture2.isRenderTargetTexture === true) {
      uvNode = vec3(uvNode.x.negate(), uvNode.yz);
    }
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
  }
};
var pmremTexture = nodeProxy(PMREMNode);
addNodeClass("PMREMNode", PMREMNode);

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var envNodeCache = /* @__PURE__ */ new WeakMap();
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    let envNode = this.envNode;
    if (envNode.isTextureNode) {
      let cacheEnvNode = envNodeCache.get(envNode.value);
      if (cacheEnvNode === void 0) {
        cacheEnvNode = pmremTexture(envNode.value);
        envNodeCache.set(envNode.value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const { material } = builder;
    const envMap = material.envMap;
    const intensity = envMap ? reference("envMapIntensity", "float", builder.material) : reference("environmentIntensity", "float", builder.scene);
    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
    const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;
    const radiance = context(envNode, createRadianceContext(roughness, radianceNormalView)).mul(intensity);
    const irradiance = context(envNode, createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);
    const isolateRadiance = cache(radiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(irradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = context(envNode, createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);
      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
  }
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  return {
    getUV: () => {
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      return reflectVec;
    },
    getTextureLevel: () => {
      return roughnessNode;
    }
  };
};
var createIrradianceContext = (normalWorldNode) => {
  return {
    getUV: () => {
      return normalWorldNode;
    },
    getTextureLevel: () => {
      return float(1);
    }
  };
};
var EnvironmentNode_default = EnvironmentNode;
addNodeClass("EnvironmentNode", EnvironmentNode);

// node_modules/three/examples/jsm/nodes/lighting/IrradianceNode.js
var IrradianceNode = class extends LightingNode_default {
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
};
var IrradianceNode_default = IrradianceNode;
addNodeClass("IrradianceNode", IrradianceNode);

// node_modules/three/examples/jsm/nodes/display/ViewportNode.js
var resolution;
var viewportResult;
var ViewportNode = class _ViewportNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    if (this.scope === _ViewportNode.VIEWPORT) return "vec4";
    else if (this.scope === _ViewportNode.COORDINATE) return "vec3";
    else return "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ViewportNode.RESOLUTION || this.scope === _ViewportNode.VIEWPORT) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    if (this.scope === _ViewportNode.VIEWPORT) {
      renderer.getViewport(viewportResult);
    } else {
      renderer.getDrawingBufferSize(resolution);
    }
  }
  setup() {
    const scope = this.scope;
    let output2 = null;
    if (scope === _ViewportNode.RESOLUTION) {
      output2 = uniform(resolution || (resolution = new Vector2()));
    } else if (scope === _ViewportNode.VIEWPORT) {
      output2 = uniform(viewportResult || (viewportResult = new Vector4()));
    } else {
      output2 = viewportCoordinate.div(viewportResolution);
      let outX = output2.x;
      let outY = output2.y;
      if (/bottom/i.test(scope)) outY = outY.oneMinus();
      if (/right/i.test(scope)) outX = outX.oneMinus();
      output2 = vec2(outX, outY);
    }
    return output2;
  }
  generate(builder) {
    if (this.scope === _ViewportNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const resolution2 = builder.getNodeProperties(viewportResolution).outputNode.build(builder);
        coord = `${builder.getType("vec3")}( ${coord}.x, ${resolution2}.y - ${coord}.y, ${coord}.z )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
};
ViewportNode.COORDINATE = "coordinate";
ViewportNode.RESOLUTION = "resolution";
ViewportNode.VIEWPORT = "viewport";
ViewportNode.TOP_LEFT = "topLeft";
ViewportNode.BOTTOM_LEFT = "bottomLeft";
ViewportNode.TOP_RIGHT = "topRight";
ViewportNode.BOTTOM_RIGHT = "bottomRight";
var viewportCoordinate = nodeImmutable(ViewportNode, ViewportNode.COORDINATE);
var viewportResolution = nodeImmutable(ViewportNode, ViewportNode.RESOLUTION);
var viewport = nodeImmutable(ViewportNode, ViewportNode.VIEWPORT);
var viewportTopLeft = nodeImmutable(ViewportNode, ViewportNode.TOP_LEFT);
var viewportBottomLeft = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_LEFT);
var viewportTopRight = nodeImmutable(ViewportNode, ViewportNode.TOP_RIGHT);
var viewportBottomRight = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_RIGHT);
addNodeClass("ViewportNode", ViewportNode);

// node_modules/three/examples/jsm/nodes/display/ViewportTextureNode.js
var _size = new Vector2();
var ViewportTextureNode = class extends TextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null, framebufferTexture = null) {
    if (framebufferTexture === null) {
      framebufferTexture = new FramebufferTexture();
      framebufferTexture.minFilter = LinearMipmapLinearFilter;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    renderer.getDrawingBufferSize(_size);
    const framebufferTexture = this.value;
    if (framebufferTexture.image.width !== _size.width || framebufferTexture.image.height !== _size.height) {
      framebufferTexture.image.width = _size.width;
      framebufferTexture.image.height = _size.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
};
var ViewportTextureNode_default = ViewportTextureNode;
var viewportTexture = nodeProxy(ViewportTextureNode);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true });
addNodeElement("viewportTexture", viewportTexture);
addNodeElement("viewportMipTexture", viewportMipTexture);
addNodeClass("ViewportTextureNode", ViewportTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthTextureNode.js
var sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (sharedDepthbuffer === null) {
      sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, sharedDepthbuffer);
  }
};
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode);
addNodeElement("viewportDepthTexture", viewportDepthTexture);
addNodeClass("ViewportDepthTextureNode", ViewportDepthTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthNode.js
var ViewportDepthNode = class _ViewportDepthNode extends Node_default {
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === _ViewportDepthNode.DEPTH_PIXEL) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup() {
    const { scope } = this;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH) {
      node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_TEXTURE) {
      const texture2 = this.valueNode || viewportDepthTexture();
      const viewZ = perspectiveDepthToViewZ(texture2, cameraNear, cameraFar);
      node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_PIXEL) {
      if (this.valueNode !== null) {
        node = depthPixelBase().assign(this.valueNode);
      }
    }
    return node;
  }
};
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var perspectiveDepthToViewZ = (depth2, near, far) => near.mul(far).div(far.sub(near).mul(depth2).sub(far));
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.DEPTH_TEXTURE = "depthTexture";
ViewportDepthNode.DEPTH_PIXEL = "depthPixel";
var depthPixelBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var depthTexture = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE);
var depthPixel = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);
depthPixel.assign = (value) => depthPixelBase(value);
addNodeClass("ViewportDepthNode", ViewportDepthNode);

// node_modules/three/examples/jsm/nodes/accessors/ClippingNode.js
var ClippingNode = class _ClippingNode extends Node_default {
  constructor(scope = _ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { localClipIntersection, localClippingCount, globalClippingCount } = clippingContext;
    const numClippingPlanes = globalClippingCount + localClippingCount;
    const numUnionClippingPlanes = localClipIntersection ? numClippingPlanes - localClippingCount : numClippingPlanes;
    if (this.scope === _ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(clippingContext.planes, numClippingPlanes, numUnionClippingPlanes);
    } else {
      return this.setupDefault(clippingContext.planes, numClippingPlanes, numUnionClippingPlanes);
    }
  }
  setupAlphaToCoverage(planes, numClippingPlanes, numUnionClippingPlanes) {
    return tslFn(() => {
      const clippingPlanes = uniforms(planes);
      const distanceToPlane = property("float", "distanceToPlane");
      const distanceGradient = property("float", "distanceToGradient");
      const clipOpacity = property("float", "clipOpacity");
      clipOpacity.assign(1);
      let plane;
      loop(numUnionClippingPlanes, ({ i }) => {
        plane = clippingPlanes.element(i);
        distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
        distanceGradient.assign(distanceToPlane.fwidth().div(2));
        clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
        clipOpacity.equal(0).discard();
      });
      if (numUnionClippingPlanes < numClippingPlanes) {
        const unionClipOpacity = property("float", "unionclipOpacity");
        unionClipOpacity.assign(1);
        loop({ start: numUnionClippingPlanes, end: numClippingPlanes }, ({ i }) => {
          plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          unionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
        });
        clipOpacity.mulAssign(unionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  setupDefault(planes, numClippingPlanes, numUnionClippingPlanes) {
    return tslFn(() => {
      const clippingPlanes = uniforms(planes);
      let plane;
      loop(numUnionClippingPlanes, ({ i }) => {
        plane = clippingPlanes.element(i);
        positionView.dot(plane.xyz).greaterThan(plane.w).discard();
      });
      if (numUnionClippingPlanes < numClippingPlanes) {
        const clipped = property("bool", "clipped");
        clipped.assign(true);
        loop({ start: numUnionClippingPlanes, end: numClippingPlanes }, ({ i }) => {
          plane = clippingPlanes.element(i);
          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
        });
        clipped.discard();
      }
    })();
  }
};
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
var clipping = () => nodeObject(new ClippingNode());
var clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    const { renderer, material } = builder;
    if (renderer.coordinateSystem === WebGLCoordinateSystem) {
      if (material.side === BackSide) {
        return "false";
      }
    }
    return builder.getFrontFacing();
  }
};
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
addNodeClass("FrontFacingNode", FrontFacingNode);

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterials = /* @__PURE__ */ new Map();
var NodeMaterial = class extends Material {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.type;
    this.forceSinglePass = false;
    this.fog = true;
    this.lights = true;
    this.normals = true;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.positionNode = null;
    this.depthNode = null;
    this.shadowNode = null;
    this.shadowPositionNode = null;
    this.outputNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + getCacheKey(this);
  }
  build(builder) {
    this.setup(builder);
  }
  setup(builder) {
    builder.addStack();
    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true) this.setupDepth(builder);
    if (this.fragmentNode === null) {
      if (this.normals === true) this.setupNormal(builder);
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null) builder.stack.add(clippingNode);
      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      if (this.outputNode !== null) resultNode = this.outputNode;
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
  }
  setupClipping(builder) {
    if (builder.clippingContext === null) return null;
    const { globalClippingCount, localClippingCount } = builder.clippingContext;
    let result = null;
    if (globalClippingCount || localClippingCount) {
      if (this.alphaToCoverage) {
        result = clippingAlpha();
      } else {
        builder.stack.add(clipping());
      }
    }
    return result;
  }
  setupDepth(builder) {
    const { renderer } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null && renderer.logarithmicDepthBuffer === true) {
      const fragDepth = modelViewProjection().w.add(1);
      depthNode = fragDepth.log2().mul(cameraLogDepth).mul(0.5);
    }
    if (depthNode !== null) {
      depthPixel.assign(depthNode).append();
    }
  }
  setupPosition(builder) {
    const { object } = builder;
    const geometry = object.geometry;
    builder.addStack();
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morphReference(object).append();
    }
    if (object.isSkinnedMesh === true) {
      skinningReference(object).append();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
    }
    if (object.isBatchedMesh) {
      batch(object).append();
    }
    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable("instance") === true) {
      instance(object).append();
    }
    if (this.positionNode !== null) {
      positionLocal.assign(this.positionNode);
    }
    const mvp = modelViewProjection();
    builder.context.vertex = builder.removeStack();
    builder.context.mvp = mvp;
    return mvp;
  }
  setupDiffuseColor({ object, geometry }) {
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = vec4(colorNode.xyz.mul(attribute("color", "vec3")), colorNode.a);
    }
    if (object.instanceColor) {
      const instanceColor = varyingProperty("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      diffuseColor.a.lessThanEqual(alphaTestNode).discard();
    }
  }
  setupVariants() {
  }
  setupNormal() {
    if (this.flatShading === true) {
      const normalNode = positionView.dFdx().cross(positionView.dFdy()).normalize();
      transformedNormalView.assign(normalNode.mul(faceDirection));
    } else {
      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;
      transformedNormalView.assign(normalNode.mul(faceDirection));
    }
  }
  getEnvNode(builder) {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);
    } else if (builder.environmentNode) {
      node = builder.environmentNode;
    }
    return node;
  }
  setupLights(builder) {
    const envNode = this.getEnvNode(builder);
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.lightMap) {
      materialLightsNode.push(new IrradianceNode_default(materialReference("lightMap", "texture")));
    }
    if (this.aoNode !== null || builder.material.aoMap) {
      const aoNode = this.aoNode !== null ? this.aoNode : texture(builder.material.aoMap);
      materialLightsNode.push(new AONode_default(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = lightsNode([...lightsN.lightNodes, ...materialLightsNode]);
    }
    return lightsN;
  }
  setupLightingModel() {
  }
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode2 = lights2 ? this.setupLights(builder) : null;
    let outgoingLightNode = diffuseColor.rgb;
    if (lightsNode2 && lightsNode2.hasLight !== false) {
      const lightingModel = this.setupLightingModel(builder);
      outgoingLightNode = lightingContext(lightsNode2, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));
    }
    return outgoingLightNode;
  }
  setupOutput(builder, outputNode) {
    const fogNode = builder.fogNode;
    if (fogNode) outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), outputNode.a);
    return outputNode;
  }
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone) this[property2] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property2, childNode } of nodeChildren) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.positionNode = source.positionNode;
    this.depthNode = source.depthNode;
    this.shadowNode = source.shadowNode;
    this.shadowPositionNode = source.shadowPositionNode;
    this.outputNode = source.outputNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
  static fromMaterial(material) {
    if (material.isNodeMaterial === true) {
      return material;
    }
    const type = material.type.replace("Material", "NodeMaterial");
    const nodeMaterial = createNodeMaterialFromType(type);
    if (nodeMaterial === void 0) {
      throw new Error(`NodeMaterial: Material "${material.type}" is not compatible.`);
    }
    for (const key in material) {
      nodeMaterial[key] = material[key];
    }
    return nodeMaterial;
  }
};
var NodeMaterial_default = NodeMaterial;
function addNodeMaterial(type, nodeMaterial) {
  if (typeof nodeMaterial !== "function" || !type) throw new Error(`Node material ${type} is not a class`);
  if (NodeMaterials.has(type)) {
    console.warn(`Redefinition of node material ${type}`);
    return;
  }
  NodeMaterials.set(type, nodeMaterial);
  nodeMaterial.type = type;
}
function createNodeMaterialFromType(type) {
  const Material2 = NodeMaterials.get(type);
  if (Material2 !== void 0) {
    return new Material2();
  }
}
addNodeMaterial("NodeMaterial", NodeMaterial);

// node_modules/three/examples/jsm/renderers/common/Uniform.js
var Uniform = class {
  constructor(name, value) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  setValue(value) {
    this.value = value;
  }
  getValue() {
    return this.value;
  }
};
var FloatUniform = class extends Uniform {
  constructor(name, value = 0) {
    super(name, value);
    this.isFloatUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends Uniform {
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends Uniform {
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends Uniform {
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends Uniform {
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix3Uniform = class extends Uniform {
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends Uniform {
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniform.js
var FloatNodeUniform = class extends FloatUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};

// node_modules/three/examples/jsm/nodes/core/StackNode.js
var StackNode = class extends Node_default {
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(node);
    return this;
  }
  if(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = cond(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  elseif(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = cond(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  build(builder, ...params) {
    const previousStack = getCurrentStack();
    setCurrentStack(this);
    for (const node of this.nodes) {
      node.build(builder, "void");
    }
    setCurrentStack(previousStack);
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
};
var stack = nodeProxy(StackNode);
addNodeClass("StackNode", StackNode);

// node_modules/three/examples/jsm/nodes/utils/EquirectUVNode.js
var EquirectUVNode = class extends TempNode_default {
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  setup() {
    const dir = this.dirNode;
    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
    const v = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return vec2(u, v);
  }
};
var equirectUV = nodeProxy(EquirectUVNode);
addNodeClass("EquirectUVNode", EquirectUVNode);

// node_modules/three/examples/jsm/renderers/common/CubeRenderTarget.js
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  fromEquirectangularTexture(renderer, texture2) {
    const currentMinFilter = texture2.minFilter;
    const currentGenerateMipmaps = texture2.generateMipmaps;
    texture2.generateMipmaps = true;
    this.texture.type = texture2.type;
    this.texture.colorSpace = texture2.colorSpace;
    this.texture.generateMipmaps = texture2.generateMipmaps;
    this.texture.minFilter = texture2.minFilter;
    this.texture.magFilter = texture2.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = createNodeMaterialFromType("MeshBasicNodeMaterial");
    material.colorNode = texture(texture2, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene = new Scene();
    scene.add(mesh);
    if (texture2.minFilter === LinearMipmapLinearFilter) texture2.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, scene);
    texture2.minFilter = currentMinFilter;
    texture2.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var CubeRenderTarget_default = CubeRenderTarget;

// node_modules/three/examples/jsm/renderers/common/extras/PMREMGenerator.js
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _cubeCamera = new PerspectiveCamera(90, 1);
var _clearColor = new Color();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(-PHI, INV_PHI, 0),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1)
];
var _faceLib = [
  3,
  1,
  5,
  0,
  4,
  2
];
var direction = getDirection(uv(), attribute("faceIndex")).normalize();
var outputDirection = vec3(direction.x, direction.y.negate(), direction.z);
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._backgroundBox = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture2, renderTarget) {
    if (texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping) {
      this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || texture2.image[0].image.width);
    } else {
      this._setSize(texture2.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture2, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace
      //depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = this._lodMeshes[0];
    tmpMesh.material = material;
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const cubeCamera = _cubeCamera;
    cubeCamera.near = near;
    cubeCamera.far = far;
    const upSign = [-1, 1, -1, -1, -1, -1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    renderer.getClearColor(_clearColor);
    renderer.autoClear = false;
    let backgroundBox = this._backgroundBox;
    if (backgroundBox === null) {
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    }
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundBox.material.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundBox.material.color.copy(_clearColor);
      useSolidColor = true;
    }
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.clear();
    if (useSolidColor) {
      renderer.render(backgroundBox, cubeCamera);
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.render(scene, cubeCamera);
    }
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture2, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial(texture2);
      }
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial(texture2);
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    material.fragmentNode.value = texture2;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodPlanes.length;
    for (let i = 1; i < n; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction2 !== "latitudinal" && direction2 !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
    blurUniforms.envMap.value = targetIn.texture;
    blurUniforms.samples.value = samples;
    blurUniforms.weights.array = weights;
    blurUniforms.latitudinal.value = direction2 === "latitudinal" ? 1 : 0;
    if (poleAxis) {
      blurUniforms.poleAxis.value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms.dTheta.value = radiansPerPixel;
    blurUniforms.mipInt.value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min3 = -texelSize;
    const max3 = 1 + texelSize;
    const uv1 = [min3, min3, max3, min3, max3, max3, min3, min3, max3, max3, min3, max3];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      const faceIdx = _faceLib[face];
      position.set(coordinates, positionSize * vertices * faceIdx);
      uv2.set(uv1, uvSize * vertices * faceIdx);
      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas, lodMeshes };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new RenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.texture.isPMREMTexture = true;
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  const viewY = target.height - height - y;
  target.viewport.set(x, viewY, width, height);
  target.scissor.set(x, viewY, width, height);
}
function _getMaterial() {
  const material = new NodeMaterial_default();
  material.depthTest = false;
  material.depthWrite = false;
  material.blending = NoBlending;
  return material;
}
function _getBlurShader(lodMax, width, height) {
  const weights = uniforms(new Array(MAX_SAMPLES).fill(0));
  const poleAxis = uniform(new Vector3(0, 1, 0));
  const dTheta = uniform(0);
  const n = float(MAX_SAMPLES);
  const latitudinal = uniform(0);
  const samples = uniform(1);
  const envMap = texture(null);
  const mipInt = uniform(0);
  const CUBEUV_TEXEL_WIDTH = float(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float(1 / height);
  const CUBEUV_MAX_MIP = float(lodMax);
  const materialUniforms = {
    n,
    latitudinal,
    weights,
    poleAxis,
    outputDirection,
    dTheta,
    samples,
    envMap,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial();
  material.uniforms = materialUniforms;
  material.fragmentNode = blur({ ...materialUniforms, latitudinal: latitudinal.equal(1) });
  return material;
}
function _getCubemapMaterial(envTexture) {
  const material = _getMaterial();
  material.fragmentNode = cubeTexture(envTexture, outputDirection);
  return material;
}
function _getEquirectMaterial(envTexture) {
  const material = _getMaterial();
  material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);
  return material;
}
var PMREMGenerator_default = PMREMGenerator;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var uniformsGroupCache = new ChainMap();
var typeFromLength = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser, scene = null, material = null) {
    this.object = object;
    this.material = material || object && object.material || null;
    this.geometry = object && object.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.scene = scene;
    this.nodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.hashNodes = {};
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.clippingContext = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: "" };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.bindings = { vertex: [], fragment: [], compute: [] };
    this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
    this.bindingsArray = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.codes = {};
    this.vars = {};
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.stacks = [];
    this.tab = "	";
    this.currentFunctionNode = null;
    this.context = {
      keywords: new NodeKeywords_default(),
      material: this.material
    };
    this.cache = new NodeCache_default();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  createRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  createCubeRenderTarget(size, options) {
    return new CubeRenderTarget_default(size, options);
  }
  createPMREMGenerator() {
    return new PMREMGenerator_default(this.renderer);
  }
  includes(node) {
    return this.nodes.includes(node);
  }
  _getSharedBindings(bindings) {
    const shared = [];
    for (const binding of bindings) {
      if (binding.shared === true) {
        const nodes = binding.getNodes();
        let sharedBinding = uniformsGroupCache.get(nodes);
        if (sharedBinding === void 0) {
          uniformsGroupCache.set(nodes, binding);
          sharedBinding = binding;
        }
        shared.push(sharedBinding);
      } else {
        shared.push(binding);
      }
    }
    return shared;
  }
  getBindings() {
    let bindingsArray = this.bindingsArray;
    if (bindingsArray === null) {
      const bindings = this.bindings;
      this.bindingsArray = bindingsArray = this._getSharedBindings(this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute);
    }
    return bindingsArray;
  }
  setHashNode(node, hash2) {
    this.hashNodes[hash2] = node;
  }
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      const updateBeforeType = node.getUpdateBeforeType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node.getSelf());
      }
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(node) {
    this.chaining.push(node);
  }
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash2) {
    return this.hashNodes[hash2];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  setCache(cache2) {
    this.cache = cache2;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return false;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return false;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint") value = 0;
      else if (type === "bool") value = false;
      else if (type === "color") value = new Color();
      else if (type === "vec2") value = new Vector2();
      else if (type === "vec3") value = new Vector3();
      else if (type === "vec4") value = new Vector4();
    }
    if (type === "float") return toFloat(value);
    if (type === "int") return `${Math.round(value)}`;
    if (type === "uint") return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool") return value ? "true" : "false";
    if (type === "color") return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const generateConst = (value2) => this.generateConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(generateConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    if (type === "color") return "vec3";
    return type;
  }
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D";
  }
  needsColorSpaceToLinear() {
    return false;
  }
  getComponentTypeFromTexture(texture2) {
    const type = texture2.type;
    if (texture2.isDataTexture) {
      if (type === IntType) return "int";
      if (type === UnsignedIntType) return "uint";
    }
    return "float";
  }
  getElementType(type) {
    if (type === "mat2") return "vec2";
    if (type === "mat3") return "vec3";
    if (type === "mat4") return "vec4";
    return this.getComponentType(type);
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint") return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null) return null;
    if (componentType[1] === "b") return "bool";
    if (componentType[1] === "i") return "int";
    if (componentType[1] === "u") return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color") return "vec3";
    if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") return "vec4";
    return type;
  }
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1) return componentType;
    const baseType = typeFromLength.get(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    return prefix + baseType;
  }
  getTypeFromArray(array) {
    return typeFromArray.get(array.constructor);
  }
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute) dataAttribute = attribute2.data;
    const array = dataAttribute.array;
    const itemSize = attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (!(attribute2 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null) return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint") return 1;
    if (/mat2/.test(type) === true) return 4;
    if (/mat3/.test(type) === true) return 9;
    if (/mat4/.test(type) === true) return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint") return type;
    return this.changeComponentType(type, "int");
  }
  addStack() {
    this.stack = stack(this.stack);
    this.stacks.push(getCurrentStack() || this.stack);
    setCurrentStack(this.stack);
    return this.stack;
  }
  removeStack() {
    const lastStack = this.stack;
    this.stack = lastStack.parent;
    setCurrentStack(this.stacks.pop());
    return lastStack;
  }
  getDataFromNode(node, shaderStage = this.shaderStage, cache2 = null) {
    cache2 = cache2 === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache2;
    let nodeData = cache2.getNodeData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache2.setNodeData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0) nodeData[shaderStage] = {};
    return nodeData[shaderStage];
  }
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute_default("nodeAttribute" + index, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  getStructTypeFromNode(node, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    if (nodeData.structType === void 0) {
      const index = this.structs.index++;
      node.name = `StructType${index}`;
      this.structs[shaderStage].push(node);
      nodeData.structType = node;
    }
    return node;
  }
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default(name || "nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
      if (name === null) name = "nodeVar" + vars.length;
      nodeVar = new NodeVar_default(name, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {
    const nodeData = this.getDataFromNode(node, "any");
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      if (name === null) name = "nodeVarying" + index;
      nodeVarying = new NodeVarying_default(name, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addLineFlowCode(code2) {
    if (code2 === "") return this;
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output2 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output2);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  buildFunctionNode(shaderNode) {
    const fn = new FunctionNode_default();
    const previous = this.currentFunctionNode;
    this.currentFunctionNode = fn;
    fn.code = this.buildFunctionCode(shaderNode);
    this.currentFunctionNode = previous;
    return fn;
  }
  flowShaderNode(shaderNode) {
    const layout = shaderNode.layout;
    let inputs;
    if (shaderNode.isArrayInput) {
      inputs = [];
      for (const input of layout.inputs) {
        inputs.push(new ParameterNode_default(input.type, input.name));
      }
    } else {
      inputs = {};
      for (const input of layout.inputs) {
        inputs[input.name] = new ParameterNode_default(input.type, input.name);
      }
    }
    shaderNode.layout = null;
    const callNode = shaderNode.call(inputs);
    const flowData = this.flowStagesNode(callNode, layout.type);
    shaderNode.layout = layout;
    return flowData;
  }
  flowStagesNode(node, output2 = null) {
    const previousFlow = this.flow;
    const previousVars = this.vars;
    const previousCache = this.cache;
    const previousBuildStage = this.buildStage;
    const previousStack = this.stack;
    const flow = {
      code: ""
    };
    this.flow = flow;
    this.vars = {};
    this.cache = new NodeCache_default();
    this.stack = stack();
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      flow.result = node.build(this, output2);
    }
    flow.vars = this.getVars(this.shaderStage);
    this.flow = previousFlow;
    this.vars = previousVars;
    this.cache = previousCache;
    this.stack = previousStack;
    this.setBuildStage(previousBuildStage);
    return flow;
  }
  getFunctionOperator() {
    return null;
  }
  flowChildNode(node, output2 = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output2);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output2 = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output2);
    if (propertyName !== null) {
      flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(type, name) {
    return `${this.getType(type)} ${name}`;
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippet += `${this.getVar(variable.type, variable.name)}; `;
      }
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    if (codes !== void 0) {
      for (const nodeCode of codes) {
        code2 += nodeCode.code + "\n";
      }
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    const { object, material } = this;
    if (material !== null) {
      NodeMaterial_default.fromMaterial(material).build(this);
    } else {
      this.addFlow("compute", object);
    }
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  getNodeUniform(uniformNode, type) {
    if (type === "float") return new FloatNodeUniform(uniformNode);
    if (type === "vec2") return new Vector2NodeUniform(uniformNode);
    if (type === "vec3") return new Vector3NodeUniform(uniformNode);
    if (type === "vec4") return new Vector4NodeUniform(uniformNode);
    if (type === "color") return new ColorNodeUniform(uniformNode);
    if (type === "mat3") return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4") return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  createNodeMaterial(type = "NodeMaterial") {
    return createNodeMaterialFromType(type);
  }
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4 && fromTypeLength > 1) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    if (fromTypeLength === 1 && toTypeLength > 1 && fromType[0] !== toType[0]) {
      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.startTime = null;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  _getMaps(referenceMap, nodeRef) {
    let maps = referenceMap.get(nodeRef);
    if (maps === void 0) {
      maps = {
        renderMap: /* @__PURE__ */ new WeakMap(),
        frameMap: /* @__PURE__ */ new WeakMap()
      };
      referenceMap.set(nodeRef, maps);
    }
    return maps;
  }
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.updateBefore(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.updateBefore(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  updateNode(node) {
    const updateType = node.getUpdateType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.update(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.update(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0) this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/core/StructTypeNode.js
var StructTypeNode = class extends Node_default {
  constructor(types) {
    super();
    this.types = types;
    this.isStructTypeNode = true;
  }
  getMemberTypes() {
    return this.types;
  }
};
var StructTypeNode_default = StructTypeNode;
addNodeClass("StructTypeNode", StructTypeNode);

// node_modules/three/examples/jsm/nodes/core/OutputStructNode.js
var OutputStructNode = class extends Node_default {
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  setup(builder) {
    super.setup(builder);
    const members = this.members;
    const types = [];
    for (let i = 0; i < members.length; i++) {
      types.push(members[i].getNodeType(builder));
    }
    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode_default(types)).name;
  }
  generate(builder, output2) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder, output2);
      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`);
    }
    return propertyName;
  }
};
var outputStruct = nodeProxy(OutputStructNode);
addNodeClass("OutputStructNode", OutputStructNode);

// node_modules/three/examples/jsm/nodes/math/HashNode.js
var HashNode = class extends Node_default {
  constructor(seedNode) {
    super();
    this.seedNode = seedNode;
  }
  setup() {
    const state = this.seedNode.toUint().mul(747796405).add(2891336453);
    const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
    const result = word.shiftRight(22).bitXor(word);
    return result.toFloat().mul(1 / 2 ** 32);
  }
};
var hash = nodeProxy(HashNode);
addNodeElement("hash", hash);
addNodeClass("HashNode", HashNode);

// node_modules/three/examples/jsm/nodes/math/MathUtils.js
var parabola = (x, k) => pow(mul(4, x.mul(sub(1, x))), k);
var gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2), k).div(2) : sub(1, parabola(mul(sub(1, x), 2), k).div(2));
var pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1, x), b))), 1 / a);
var sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1))).div(PI.mul(k.mul(x).sub(1)));
addNodeElement("parabola", parabola);
addNodeElement("gain", gain);
addNodeElement("pcurve", pcurve);
addNodeElement("sinc", sinc);

// node_modules/three/examples/jsm/nodes/math/TriNoise3D.js
var tri = tslFn(([x]) => {
  return x.fract().sub(0.5).abs();
});
var tri3 = tslFn(([p]) => {
  return vec3(tri(p.z.add(tri(p.y.mul(1)))), tri(p.z.add(tri(p.x.mul(1)))), tri(p.y.add(tri(p.x.mul(1)))));
});
var triNoise3D = tslFn(([p_immutable, spd, time]) => {
  const p = vec3(p_immutable).toVar();
  const z = float(1.4).toVar();
  const rz = float(0).toVar();
  const bp = vec3(p).toVar();
  loop({ start: float(0), end: float(3), type: "float", condition: "<=" }, () => {
    const dg = vec3(tri3(bp.mul(2))).toVar();
    p.addAssign(dg.add(time.mul(float(0.1).mul(spd))));
    bp.mulAssign(1.8);
    z.mulAssign(1.5);
    p.mulAssign(1.2);
    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
    rz.addAssign(t.div(z));
    bp.addAssign(0.14);
  });
  return rz;
});
tri.setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
});
tri3.setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
triNoise3D.setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "spd", type: "float" },
    { name: "time", type: "float" }
  ]
});

// node_modules/three/examples/jsm/nodes/utils/DiscardNode.js
var discardExpression;
var DiscardNode = class extends CondNode_default {
  constructor(condNode) {
    discardExpression = discardExpression || expression("discard");
    super(condNode, discardExpression);
  }
};
var inlineDiscard = nodeProxy(DiscardNode);
var discard = (condNode) => inlineDiscard(condNode).append();
addNodeElement("discard", discard);
addNodeClass("DiscardNode", DiscardNode);

// node_modules/three/examples/jsm/nodes/utils/FunctionOverloadingNode.js
var FunctionOverloadingNode = class extends Node_default {
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFnCall = null;
  }
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(builder) {
    const params = this.parametersNodes;
    let candidateFnCall = this._candidateFnCall;
    if (candidateFnCall === null) {
      let candidateFn = null;
      let candidateScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let score = 0;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            const input = inputs[i];
            if (param.getNodeType(builder) === input.type) {
              score++;
            } else {
              score = 0;
            }
          }
          if (score > candidateScore) {
            candidateFn = functionNode;
            candidateScore = score;
          }
        }
      }
      this._candidateFnCall = candidateFnCall = candidateFn(...params);
    }
    return candidateFnCall;
  }
};
var overloadingBaseFn = nodeProxy(FunctionOverloadingNode);
var overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
addNodeClass("FunctionOverloadingNode", FunctionOverloadingNode);

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  setup() {
    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
    const y = positionViewDirection.cross(x);
    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5);
  }
};
var matcapUV = nodeImmutable(MatcapUVNode);
addNodeClass("MatcapUVNode", MatcapUVNode);

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else if (scope === _TimerNode.FRAME) {
      this.value = frame.frameId;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
TimerNode.LOCAL = "local";
TimerNode.GLOBAL = "global";
TimerNode.DELTA = "delta";
TimerNode.FRAME = "frame";
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.LOCAL, timeScale, value));
var frameId = nodeImmutable(TimerNode, TimerNode.FRAME).toUint();
addNodeClass("TimerNode", TimerNode);

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = timerLocal()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  setup() {
    const method = this.method;
    const timeNode = nodeObject(this.timeNode);
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = timeNode.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = timeNode.fract().round();
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = timeNode.add(0.5).fract().mul(2).sub(1).abs();
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = timeNode.fract();
    }
    return outputNode;
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
OscNode.SINE = "sine";
OscNode.SQUARE = "square";
OscNode.TRIANGLE = "triangle";
OscNode.SAWTOOTH = "sawtooth";
var oscSine = nodeProxy(OscNode, OscNode.SINE);
var oscSquare = nodeProxy(OscNode, OscNode.SQUARE);
var oscTriangle = nodeProxy(OscNode, OscNode.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode, OscNode.SAWTOOTH);
addNodeClass("OscNode", OscNode);

// node_modules/three/examples/jsm/nodes/utils/PackingNode.js
var PackingNode = class _PackingNode extends TempNode_default {
  constructor(scope, node) {
    super();
    this.scope = scope;
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup() {
    const { scope, node } = this;
    let result = null;
    if (scope === _PackingNode.DIRECTION_TO_COLOR) {
      result = node.mul(0.5).add(0.5);
    } else if (scope === _PackingNode.COLOR_TO_DIRECTION) {
      result = node.mul(2).sub(1);
    }
    return result;
  }
};
PackingNode.DIRECTION_TO_COLOR = "directionToColor";
PackingNode.COLOR_TO_DIRECTION = "colorToDirection";
var directionToColor = nodeProxy(PackingNode, PackingNode.DIRECTION_TO_COLOR);
var colorToDirection = nodeProxy(PackingNode, PackingNode.COLOR_TO_DIRECTION);
addNodeElement("directionToColor", directionToColor);
addNodeElement("colorToDirection", colorToDirection);
addNodeClass("PackingNode", PackingNode);

// node_modules/three/examples/jsm/nodes/utils/RemapNode.js
var RemapNode = class extends Node_default {
  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var remap = nodeProxy(RemapNode, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode);
addNodeElement("remap", remap);
addNodeElement("remapClamp", remapClamp);
addNodeClass("RemapNode", RemapNode);

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  setup() {
    const { uvNode, rotationNode, centerNode } = this;
    const vector = uvNode.sub(centerNode);
    return vector.rotate(rotationNode).add(centerNode);
  }
};
var rotateUV = nodeProxy(RotateUVNode);
addNodeElement("rotateUV", rotateUV);
addNodeClass("RotateUVNode", RotateUVNode);

// node_modules/three/examples/jsm/nodes/utils/RotateNode.js
var RotateNode = class extends TempNode_default {
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(vec4(1, 0, 0, 0), vec4(0, cos(rotation.x), sin(rotation.x).negate(), 0), vec4(0, sin(rotation.x), cos(rotation.x), 0), vec4(0, 0, 0, 1));
      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0, sin(rotation.y), 0), vec4(0, 1, 0, 0), vec4(sin(rotation.y).negate(), 0, cos(rotation.y), 0), vec4(0, 0, 0, 1));
      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0, 0), vec4(sin(rotation.z), cos(rotation.z), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));
      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1)).xyz;
    }
  }
};
var rotate = nodeProxy(RotateNode);
addNodeElement("rotate", rotate);
addNodeClass("RotateNode", RotateNode);

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = uv(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
};
var spritesheetUV = nodeProxy(SpriteSheetUVNode);
addNodeClass("SpriteSheetUVNode", SpriteSheetUVNode);

// node_modules/three/examples/jsm/nodes/utils/StorageArrayElementNode.js
var StorageArrayElementNode = class extends ArrayElementNode_default {
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (!this.node.instanceIndex && this.node.bufferObject === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      const { node } = this;
      if (!node.instanceIndex && this.node.bufferObject === true && isAssignContext !== true) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
};
var storageElement = nodeProxy(StorageArrayElementNode);
addNodeElement("storageElement", storageElement);
addNodeClass("StorageArrayElementNode", StorageArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/TriplanarTexturesNode.js
var TriplanarTexturesNode = class extends Node_default {
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  setup() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture(textureX, tx).mul(bf.x);
    const cy = texture(textureY, ty).mul(bf.y);
    const cz = texture(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
};
var triplanarTextures = nodeProxy(TriplanarTexturesNode);
var triplanarTexture = (...params) => triplanarTextures(...params);
addNodeElement("triplanarTexture", triplanarTexture);
addNodeClass("TriplanarTexturesNode", TriplanarTexturesNode);

// node_modules/three/examples/jsm/nodes/utils/ReflectorNode.js
var _reflectorPlane = new Plane();
var _normal = new Vector3();
var _reflectorWorldPosition = new Vector3();
var _cameraWorldPosition = new Vector3();
var _rotationMatrix = new Matrix4();
var _lookAtPosition = new Vector3(0, 0, -1);
var clipPlane = new Vector4();
var _view = new Vector3();
var _target = new Vector3();
var _q = new Vector4();
var _size2 = new Vector2();
var _defaultRT = new RenderTarget();
var _defaultUV = vec2(viewportTopLeft.x.oneMinus(), viewportTopLeft.y);

// node_modules/three/examples/jsm/nodes/accessors/VertexColorNode.js
var VertexColorNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "color" + (index > 0 ? index : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result;
    if (geometryAttribute === true) {
      result = super.generate(builder);
    } else {
      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
addNodeClass("VertexColorNode", VertexColorNode);

// node_modules/three/examples/jsm/nodes/accessors/RendererReferenceNode.js
var RendererReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, renderer = null) {
    super(property2, inputType, renderer);
    this.renderer = renderer;
  }
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
};
var rendererReference = (name, type, renderer) => nodeObject(new RendererReferenceNode(name, type, renderer));
addNodeClass("RendererReferenceNode", RendererReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureBicubicNode.js
var bC = 1 / 6;
var w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3)).sub(3)).add(1));
var w1 = (a) => mul(bC, mul(a, mul(a, mul(3, a).sub(6))).add(4));
var w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3)).add(3)).add(1));
var w3 = (a) => mul(bC, pow(a, 3));
var g0 = (a) => w0(a).add(w1(a));
var g1 = (a) => w2(a).add(w3(a));
var h0 = (a) => add(-1, w1(a).div(w0(a).add(w1(a))));
var h1 = (a) => add(1, w3(a).div(w2(a).add(w3(a))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));
  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));
  return a.add(b);
};
var textureBicubicMethod = (textureNode, lodNode) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
};
var TextureBicubicNode = class extends TempNode_default {
  constructor(textureNode, blurNode = float(3)) {
    super("vec4");
    this.textureNode = textureNode;
    this.blurNode = blurNode;
  }
  setup() {
    return textureBicubicMethod(this.textureNode, this.blurNode);
  }
};
var textureBicubic = nodeProxy(TextureBicubicNode);
addNodeElement("bicubic", textureBicubic);
addNodeClass("TextureBicubicNode", TextureBicubicNode);

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var pointUV = nodeImmutable(PointUVNode);
addNodeClass("PointUVNode", PointUVNode);

// node_modules/three/examples/jsm/nodes/accessors/SceneNode.js
var SceneNode = class _SceneNode extends Node_default {
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  setup(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene);
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
addNodeClass("SceneNode", SceneNode);

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
    this.bufferObject = false;
    this._attribute = null;
    this._varying = null;
    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
      else value.isStorageBufferAttribute = true;
    }
  }
  getInputType() {
    return "storageBuffer";
  }
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  setBufferObject(value) {
    this.bufferObject = value;
    return this;
  }
  generate(builder) {
    if (builder.isAvailable("storageBuffer")) return super.generate(builder);
    const nodeType = this.getNodeType(builder);
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    const output2 = this._varying.build(builder, nodeType);
    builder.registerTransform(output2, this._attribute);
    return output2;
  }
};
addNodeClass("StorageBufferNode", StorageBufferNode);

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUConstants.js
var GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
};
var GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
};
var GPUStoreOp = {
  Store: "store",
  Discard: "discard"
};
var GPULoadOp = {
  Load: "load",
  Clear: "clear"
};
var GPUFrontFace = {
  CCW: "ccw",
  CW: "cw"
};
var GPUCullMode = {
  None: "none",
  Front: "front",
  Back: "back"
};
var GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32"
};
var GPUTextureFormat = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10uFloat: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  // Depth and stencil formats
  Stencil8: "stencil8",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
};
var GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest"
};
var GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDstColor: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
};
var GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
};
var GPUColorWriteFlags = {
  None: 0,
  Red: 1,
  Green: 2,
  Blue: 4,
  Alpha: 8,
  All: 15
};
var GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
};
var GPUBufferBindingType = {
  Uniform: "uniform",
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
};
var GPUStorageTextureAccess = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write"
};
var GPUTextureSampleType = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
};
var GPUTextureDimension = {
  OneD: "1d",
  TwoD: "2d",
  ThreeD: "3d"
};
var GPUTextureViewDimension = {
  OneD: "1d",
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  CubeArray: "cube-array",
  ThreeD: "3d"
};
var GPUTextureAspect = {
  All: "all",
  StencilOnly: "stencil-only",
  DepthOnly: "depth-only"
};
var GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance"
};
var GPUFeatureName = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable"
};

// node_modules/three/examples/jsm/nodes/accessors/StorageTextureNode.js
var StorageTextureNode = class extends TextureNode_default {
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStorageTextureNode = true;
    this.access = GPUStorageTextureAccess.WriteOnly;
  }
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
  }
  setAccess(value) {
    this.access = value;
    return this;
  }
  generate(builder, output2) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output2);
    }
    return snippet;
  }
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(builder, "uvec2");
    const storeSnippet = storeNode.build(builder, "vec4");
    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);
    builder.addLineFlowCode(snippet);
  }
};
var storageTexture = nodeProxy(StorageTextureNode);
addNodeClass("StorageTextureNode", StorageTextureNode);

// node_modules/three/examples/jsm/nodes/accessors/Texture3DNode.js
var normal = tslFn(({ texture: texture2, uv: uv2 }) => {
  const epsilon = 1e-4;
  const ret = vec3().temp();
  If(uv2.x.lessThan(epsilon), () => {
    ret.assign(vec3(1, 0, 0));
  }).elseif(uv2.y.lessThan(epsilon), () => {
    ret.assign(vec3(0, 1, 0));
  }).elseif(uv2.z.lessThan(epsilon), () => {
    ret.assign(vec3(0, 0, 1));
  }).elseif(uv2.x.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(-1, 0, 0));
  }).elseif(uv2.y.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(0, -1, 0));
  }).elseif(uv2.z.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(0, 0, -1));
  }).else(() => {
    const step2 = 0.01;
    const x = texture2.uv(uv2.add(vec3(-step2, 0, 0))).r.sub(texture2.uv(uv2.add(vec3(step2, 0, 0))).r);
    const y = texture2.uv(uv2.add(vec3(0, -step2, 0))).r.sub(texture2.uv(uv2.add(vec3(0, step2, 0))).r);
    const z = texture2.uv(uv2.add(vec3(0, 0, -step2))).r.sub(texture2.uv(uv2.add(vec3(0, 0, step2))).r);
    ret.assign(vec3(x, y, z));
  });
  return ret.normalize();
});
var Texture3DNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  getInputType() {
    return "texture3D";
  }
  getDefaultUV() {
    return vec3(0.5, 0.5, 0.5);
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  setupUV(builder, uvNode) {
    return uvNode;
  }
  generateUV(builder, uvNode) {
    return uvNode.build(builder, "vec3");
  }
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
};
var texture3D = nodeProxy(Texture3DNode);
addNodeClass("Texture3DNode", Texture3DNode);

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.reference = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
addNodeClass("UserDataNode", UserDataNode);

// node_modules/three/examples/jsm/nodes/display/BlendModeNode.js
var BurnNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].lessThan(EPSILON).cond(blend[c], base[c].oneMinus().div(blend[c]).oneMinus().max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "burnColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var DodgeNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].equal(1).cond(blend[c], base[c].div(blend[c].oneMinus()).max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "dodgeColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var ScreenNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus();
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "screenColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var OverlayNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].lessThan(0.5).cond(base[c].mul(blend[c], 2), base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus());
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "overlayColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var BlendModeNode = class _BlendModeNode extends TempNode_default {
  constructor(blendMode, baseNode, blendNode) {
    super();
    this.blendMode = blendMode;
    this.baseNode = baseNode;
    this.blendNode = blendNode;
  }
  setup() {
    const { blendMode, baseNode, blendNode } = this;
    const params = { base: baseNode, blend: blendNode };
    let outputNode = null;
    if (blendMode === _BlendModeNode.BURN) {
      outputNode = BurnNode(params);
    } else if (blendMode === _BlendModeNode.DODGE) {
      outputNode = DodgeNode(params);
    } else if (blendMode === _BlendModeNode.SCREEN) {
      outputNode = ScreenNode(params);
    } else if (blendMode === _BlendModeNode.OVERLAY) {
      outputNode = OverlayNode(params);
    }
    return outputNode;
  }
};
BlendModeNode.BURN = "burn";
BlendModeNode.DODGE = "dodge";
BlendModeNode.SCREEN = "screen";
BlendModeNode.OVERLAY = "overlay";
var burn = nodeProxy(BlendModeNode, BlendModeNode.BURN);
var dodge = nodeProxy(BlendModeNode, BlendModeNode.DODGE);
var overlay = nodeProxy(BlendModeNode, BlendModeNode.OVERLAY);
var screen = nodeProxy(BlendModeNode, BlendModeNode.SCREEN);
addNodeElement("burn", burn);
addNodeElement("dodge", dodge);
addNodeElement("overlay", overlay);
addNodeElement("screen", screen);
addNodeClass("BlendModeNode", BlendModeNode);

// node_modules/three/examples/jsm/nodes/display/BumpMapNode.js
var dHdxy_fwd = tslFn(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) => textureNode.cache().context({ getUV: (texNode) => callback(texNode.uvNode || uv()), forceUVContext: true });
  const Hll = float(sampleTexture((uvNode) => uvNode));
  return vec2(
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = tslFn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode_default {
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
};
var bumpMap = nodeProxy(BumpMapNode);
addNodeElement("bumpMap", bumpMap);
addNodeClass("BumpMapNode", BumpMapNode);

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var saturationNode = tslFn(({ color: color2, adjustment }) => {
  return adjustment.mix(luminance(color2.rgb), color2.rgb);
});
var vibranceNode = tslFn(({ color: color2, adjustment }) => {
  const average = add(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color2.rgb, mx, amt);
});
var hueNode = tslFn(({ color: color2, adjustment }) => {
  const k = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(color2.rgb.mul(cosAngle).add(k.cross(color2.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color2.rgb).mul(cosAngle.oneMinus())))));
});
var ColorAdjustmentNode = class _ColorAdjustmentNode extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  setup() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === _ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode(callParams);
    } else if (method === _ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode(callParams);
    } else if (method === _ColorAdjustmentNode.HUE) {
      outputNode = hueNode(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
ColorAdjustmentNode.SATURATION = "saturation";
ColorAdjustmentNode.VIBRANCE = "vibrance";
ColorAdjustmentNode.HUE = "hue";
var saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);
var lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);
var luminance = (color2, luma = lumaCoeffs) => dot(color2, luma);
var threshold = (color2, threshold2) => mix(vec3(0), color2, luminance(color2).sub(threshold2).max(0));
addNodeElement("saturation", saturation);
addNodeElement("vibrance", vibrance);
addNodeElement("hue", hue);
addNodeElement("threshold", threshold);
addNodeClass("ColorAdjustmentNode", ColorAdjustmentNode);

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2Arb = tslFn((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = eye_pos.dFdx();
  const q1 = eye_pos.dFdy();
  const st0 = uv2.dFdx();
  const st1 = uv2.dFdy();
  const N = surf_norm;
  const q1perp = q1.cross(N);
  const q0perp = N.cross(q0);
  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
  const det = T.dot(T).max(B.dot(B));
  const scale = faceDirection.mul(det.inverseSqrt());
  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  setup(builder) {
    const { normalMapType, scaleNode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      normalMap2 = vec3(normalMap2.xy.mul(scaleNode), normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = modelNormalMatrix.mul(normalMap2).normalize();
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = TBNViewMatrix.mul(normalMap2).normalize();
      } else {
        outputNode = perturbNormal2Arb({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap2,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var normalMap = nodeProxy(NormalMapNode);
addNodeElement("normalMap", normalMap);
addNodeClass("NormalMapNode", NormalMapNode);

// node_modules/three/examples/jsm/nodes/display/PosterizeNode.js
var PosterizeNode = class extends TempNode_default {
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var posterize = nodeProxy(PosterizeNode);
addNodeElement("posterize", posterize);
addNodeClass("PosterizeNode", PosterizeNode);

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = tslFn(({ color: color2, exposure }) => {
  return color2.mul(exposure).clamp();
});
var ReinhardToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
});
var OptimizedCineonToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
});
var RRTAndODTFit = tslFn(({ color: color2 }) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var ACESFilmicToneMappingNode = tslFn(({ color: color2, exposure }) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit({ color: color2 });
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
});
var LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, 1.1187));
var LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.088), vec3(0.0433, 0.0113, 0.8956));
var agxDefaultContrastApprox = tslFn(([x_immutable]) => {
  const x = vec3(x_immutable).toVar();
  const x2 = vec3(x.mul(x)).toVar();
  const x4 = vec3(x2.mul(x2)).toVar();
  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(232e-5))));
});
var AGXToneMappingNode = tslFn(({ color: color2, exposure }) => {
  const colortone = vec3(color2).toVar();
  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
  const AgxMinEv = float(-12.47393);
  const AgxMaxEv = float(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max(colortone, 1e-10));
  colortone.assign(log2(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow(max(vec3(0), colortone), vec3(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp(colortone, 0, 1));
  return colortone;
});
var toneMappingLib = {
  [LinearToneMapping]: LinearToneMappingNode,
  [ReinhardToneMapping]: ReinhardToneMappingNode,
  [CineonToneMapping]: OptimizedCineonToneMappingNode,
  [ACESFilmicToneMapping]: ACESFilmicToneMappingNode,
  [AgXToneMapping]: AGXToneMappingNode
};
var ToneMappingNode = class extends TempNode_default {
  constructor(toneMapping2 = NoToneMapping, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  getCacheKey() {
    let cacheKey = super.getCacheKey();
    cacheKey = "{toneMapping:" + this.toneMapping + ",nodes:" + cacheKey + "}";
    return cacheKey;
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping) return colorNode;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    const toneMappingNode = toneMappingLib[toneMapping2];
    let outputNode = null;
    if (toneMappingNode) {
      outputNode = toneMappingNode(toneMappingParams);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
var toneMappingExposure = rendererReference("toneMappingExposure", "float");
addNodeElement("toneMapping", (color2, mapping, exposure) => toneMapping(mapping, exposure, color2));
addNodeClass("ToneMappingNode", ToneMappingNode);

// node_modules/three/examples/jsm/nodes/display/ViewportSharedTextureNode.js
var _sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  updateReference() {
    return this;
  }
};
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode);
addNodeElement("viewportSharedTexture", viewportSharedTexture);
addNodeClass("ViewportSharedTextureNode", ViewportSharedTextureNode);

// node_modules/three/examples/jsm/nodes/display/PassNode.js
var _size3 = new Vector2();
var PassTextureNode = class extends TextureNode_default {
  constructor(passNode, texture2) {
    super(texture2);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
};
var PassNode = class _PassNode extends TempNode_default {
  constructor(scope, scene, camera) {
    super("vec4");
    this.scope = scope;
    this.scene = scene;
    this.camera = camera;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture2 = new DepthTexture();
    depthTexture2.isRenderTargetTexture = true;
    depthTexture2.name = "PostProcessingDepth";
    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType });
    renderTarget.texture.name = "PostProcessing";
    renderTarget.depthTexture = depthTexture2;
    this.renderTarget = renderTarget;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._textureNode = nodeObject(new PassTextureNode(this, renderTarget.texture));
    this._depthTextureNode = nodeObject(new PassTextureNode(this, depthTexture2));
    this._depthNode = null;
    this._viewZNode = null;
    this._cameraNear = uniform(0);
    this._cameraFar = uniform(0);
    this.isPassNode = true;
  }
  isGlobal() {
    return true;
  }
  getTextureNode() {
    return this._textureNode;
  }
  getTextureDepthNode() {
    return this._depthTextureNode;
  }
  getViewZNode() {
    if (this._viewZNode === null) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._viewZNode = perspectiveDepthToViewZ(this._depthTextureNode, cameraNear2, cameraFar2);
    }
    return this._viewZNode;
  }
  getDepthNode() {
    if (this._depthNode === null) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._depthNode = viewZToOrthographicDepth(this.getViewZNode(), cameraNear2, cameraFar2);
    }
    return this._depthNode;
  }
  setup() {
    return this.scope === _PassNode.COLOR ? this.getTextureNode() : this.getDepthNode();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const { scene, camera } = this;
    this._pixelRatio = renderer.getPixelRatio();
    const size = renderer.getSize(_size3);
    this.setSize(size.width, size.height);
    const currentToneMapping = renderer.toneMapping;
    const currentToneMappingNode = renderer.toneMappingNode;
    const currentRenderTarget = renderer.getRenderTarget();
    this._cameraNear.value = camera.near;
    this._cameraFar.value = camera.far;
    renderer.toneMapping = NoToneMapping;
    renderer.toneMappingNode = null;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(scene, camera);
    renderer.toneMapping = currentToneMapping;
    renderer.toneMappingNode = currentToneMappingNode;
    renderer.setRenderTarget(currentRenderTarget);
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
};
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
var texturePass = (pass2, texture2) => nodeObject(new PassTextureNode(pass2, texture2));
addNodeClass("PassNode", PassNode);

// node_modules/three/examples/jsm/objects/QuadMesh.js
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var QuadGeometry = class extends BufferGeometry {
  constructor(flipY = false) {
    super();
    const uv2 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute(uv2, 2));
  }
};
var _geometry = new QuadGeometry();
var QuadMesh = class extends Mesh {
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera;
  }
  renderAsync(renderer) {
    return renderer.renderAsync(this, _camera);
  }
  render(renderer) {
    renderer.render(this, _camera);
  }
};
var QuadMesh_default = QuadMesh;

// node_modules/three/examples/jsm/nodes/display/GaussianBlurNode.js
var quadMesh1 = new QuadMesh_default();
var quadMesh2 = new QuadMesh_default();
var GaussianBlurNode = class extends TempNode_default {
  constructor(textureNode, sigma = 2) {
    super("vec4");
    this.textureNode = textureNode;
    this.sigma = sigma;
    this.directionNode = vec2(1);
    this._invSize = uniform(new Vector2());
    this._passDirection = uniform(new Vector2());
    this._horizontalRT = new RenderTarget();
    this._horizontalRT.texture.name = "GaussianBlurNode.horizontal";
    this._verticalRT = new RenderTarget();
    this._verticalRT.texture.name = "GaussianBlurNode.vertical";
    this._textureNode = texturePass(this, this._verticalRT.texture);
    this.updateBeforeType = NodeUpdateType.RENDER;
    this.resolution = new Vector2(1, 1);
  }
  setSize(width, height) {
    width = Math.max(Math.round(width * this.resolution.x), 1);
    height = Math.max(Math.round(height * this.resolution.y), 1);
    this._invSize.value.set(1 / width, 1 / height);
    this._horizontalRT.setSize(width, height);
    this._verticalRT.setSize(width, height);
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const textureNode = this.textureNode;
    const map = textureNode.value;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentTexture = textureNode.value;
    quadMesh1.material = this._material;
    quadMesh2.material = this._material;
    this.setSize(map.image.width, map.image.height);
    const textureType = map.type;
    this._horizontalRT.texture.type = textureType;
    this._verticalRT.texture.type = textureType;
    renderer.setRenderTarget(this._horizontalRT);
    this._passDirection.value.set(1, 0);
    quadMesh1.render(renderer);
    textureNode.value = this._horizontalRT.texture;
    renderer.setRenderTarget(this._verticalRT);
    this._passDirection.value.set(0, 1);
    quadMesh2.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
    textureNode.value = currentTexture;
  }
  getTextureNode() {
    return this._textureNode;
  }
  setup(builder) {
    const textureNode = this.textureNode;
    if (textureNode.isTextureNode !== true) {
      console.error("GaussianBlurNode requires a TextureNode.");
      return vec4();
    }
    const uvNode = textureNode.uvNode || uv();
    const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
    const blur2 = tslFn(() => {
      const kernelSize = 3 + 2 * this.sigma;
      const gaussianCoefficients = this._getCoefficients(kernelSize);
      const invSize = this._invSize;
      const direction2 = vec2(this.directionNode).mul(this._passDirection);
      const weightSum = float(gaussianCoefficients[0]).toVar();
      const diffuseSum = vec4(sampleTexture(uvNode).mul(weightSum)).toVar();
      for (let i = 1; i < kernelSize; i++) {
        const x = float(i);
        const w = float(gaussianCoefficients[i]);
        const uvOffset = vec2(direction2.mul(invSize.mul(x))).toVar();
        const sample1 = vec4(sampleTexture(uvNode.add(uvOffset)));
        const sample2 = vec4(sampleTexture(uvNode.sub(uvOffset)));
        diffuseSum.addAssign(sample1.add(sample2).mul(w));
        weightSum.addAssign(mul(2, w));
      }
      return diffuseSum.div(weightSum);
    });
    const material = this._material || (this._material = builder.createNodeMaterial());
    material.fragmentNode = blur2();
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
  _getCoefficients(kernelRadius) {
    const coefficients = [];
    for (let i = 0; i < kernelRadius; i++) {
      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);
    }
    return coefficients;
  }
};
var gaussianBlur = (node, sigma) => nodeObject(new GaussianBlurNode(nodeObject(node), sigma));
addNodeElement("gaussianBlur", gaussianBlur);

// node_modules/three/examples/jsm/nodes/display/AfterImageNode.js
var _size4 = new Vector2();
var quadMeshComp = new QuadMesh_default();
var AfterImageNode = class extends TempNode_default {
  constructor(textureNode, damp = 0.96) {
    super(textureNode);
    this.textureNode = textureNode;
    this.textureNodeOld = texture();
    this.damp = uniform(damp);
    this._compRT = new RenderTarget();
    this._compRT.texture.name = "AfterImageNode.comp";
    this._oldRT = new RenderTarget();
    this._oldRT.texture.name = "AfterImageNode.old";
    this._textureNode = texturePass(this, this._compRT.texture);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  getTextureNode() {
    return this._textureNode;
  }
  setSize(width, height) {
    this._compRT.setSize(width, height);
    this._oldRT.setSize(width, height);
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const textureNode = this.textureNode;
    const map = textureNode.value;
    const textureType = map.type;
    this._compRT.texture.type = textureType;
    this._oldRT.texture.type = textureType;
    renderer.getDrawingBufferSize(_size4);
    this.setSize(_size4.x, _size4.y);
    const currentToneMapping = renderer.toneMapping;
    const currentToneMappingNode = renderer.toneMappingNode;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentTexture = textureNode.value;
    this.textureNodeOld.value = this._oldRT.texture;
    renderer.toneMapping = NoToneMapping;
    renderer.toneMappingNode = null;
    renderer.setRenderTarget(this._compRT);
    quadMeshComp.render(renderer);
    const temp2 = this._oldRT;
    this._oldRT = this._compRT;
    this._compRT = temp2;
    renderer.toneMapping = currentToneMapping;
    renderer.toneMappingNode = currentToneMappingNode;
    renderer.setRenderTarget(currentRenderTarget);
    textureNode.value = currentTexture;
  }
  setup(builder) {
    const textureNode = this.textureNode;
    const textureNodeOld = this.textureNodeOld;
    if (textureNode.isTextureNode !== true) {
      console.error("AfterImageNode requires a TextureNode.");
      return vec4();
    }
    const uvNode = textureNode.uvNode || uv();
    textureNodeOld.uvNode = uvNode;
    const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
    const when_gt = tslFn(([x_immutable, y_immutable]) => {
      const y = float(y_immutable).toVar();
      const x = vec4(x_immutable).toVar();
      return max(sign(x.sub(y)), 0);
    });
    const afterImg = tslFn(() => {
      const texelOld = vec4(textureNodeOld);
      const texelNew = vec4(sampleTexture(uvNode));
      texelOld.mulAssign(this.damp.mul(when_gt(texelOld, 0.1)));
      return max(texelNew, texelOld);
    });
    const materialComposed = this._materialComposed || (this._materialComposed = builder.createNodeMaterial());
    materialComposed.fragmentNode = afterImg();
    quadMeshComp.material = materialComposed;
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
};
var afterImage = (node, damp) => nodeObject(new AfterImageNode(nodeObject(node), damp));
addNodeElement("afterImage", afterImage);

// node_modules/three/examples/jsm/nodes/display/AnamorphicNode.js
var quadMesh = new QuadMesh_default();
var AnamorphicNode = class extends TempNode_default {
  constructor(textureNode, tresholdNode, scaleNode, samples) {
    super("vec4");
    this.textureNode = textureNode;
    this.tresholdNode = tresholdNode;
    this.scaleNode = scaleNode;
    this.colorNode = vec3(0.1, 0, 1);
    this.samples = samples;
    this.resolution = new Vector2(1, 1);
    this._renderTarget = new RenderTarget();
    this._renderTarget.texture.name = "anamorphic";
    this._invSize = uniform(new Vector2());
    this._textureNode = texturePass(this, this._renderTarget.texture);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  getTextureNode() {
    return this._textureNode;
  }
  setSize(width, height) {
    this._invSize.value.set(1 / width, 1 / height);
    width = Math.max(Math.round(width * this.resolution.x), 1);
    height = Math.max(Math.round(height * this.resolution.y), 1);
    this._renderTarget.setSize(width, height);
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const textureNode = this.textureNode;
    const map = textureNode.value;
    this._renderTarget.texture.type = map.type;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentTexture = textureNode.value;
    quadMesh.material = this._material;
    this.setSize(map.image.width, map.image.height);
    renderer.setRenderTarget(this._renderTarget);
    quadMesh.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
    textureNode.value = currentTexture;
  }
  setup(builder) {
    const textureNode = this.textureNode;
    if (textureNode.isTextureNode !== true) {
      console.error("AnamorphNode requires a TextureNode.");
      return vec4();
    }
    const uvNode = textureNode.uvNode || uv();
    const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
    const anamorph = tslFn(() => {
      const samples = this.samples;
      const halfSamples = Math.floor(samples / 2);
      const total = vec3(0).toVar();
      loop({ start: -halfSamples, end: halfSamples }, ({ i }) => {
        const softness = float(i).abs().div(halfSamples).oneMinus();
        const uv2 = vec2(uvNode.x.add(this._invSize.x.mul(i).mul(this.scaleNode)), uvNode.y);
        const color2 = sampleTexture(uv2);
        const pass2 = threshold(color2, this.tresholdNode).mul(softness);
        total.addAssign(pass2);
      });
      return total.mul(this.colorNode);
    });
    const material = this._material || (this._material = builder.createNodeMaterial());
    material.fragmentNode = anamorph();
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
};
var anamorphic = (node, threshold2 = 0.9, scale = 3, samples = 32) => nodeObject(new AnamorphicNode(nodeObject(node), nodeObject(threshold2), nodeObject(scale), samples));
addNodeElement("anamorphic", anamorphic);

// node_modules/three/examples/jsm/nodes/code/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addNodeElement("call", call);
addNodeClass("FunctionCallNode", FunctionCallNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableValueNode.js
var ScriptableValueNode = class extends Node_default {
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outpuType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val) return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var scriptableValue = nodeProxy(ScriptableValueNode);
addNodeElement("scriptableValue", scriptableValue);
addNodeClass("ScriptableValueNode", ScriptableValueNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableNode.js
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key)) return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id6) {
    return this.scriptableNode.getInputLayout(id6);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var global = new Resources();
var ScriptableNode = class extends Node_default {
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue();
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  getLocal(name) {
    return this._local.get(name);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(id6) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id6 || element2.name === id6)) {
        return element2;
      }
    }
  }
  getOutputLayout(id6) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id6 || element2.name === id6)) {
        return element2;
      }
    }
  }
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  getOutput(name) {
    return this._outputs[name];
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  getObject() {
    if (this.needsUpdate) this.dispose();
    if (this._object !== null) return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id6, value) => this.setOutput(id6, value);
    const parameters = new Parameters(this);
    const THREE = global.get("THREE");
    const TSL = global.get("TSL");
    const method = this.getMethod(this.codeNode);
    const params = [parameters, this._local, global, refresh, setOutput, THREE, TSL];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id6 = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id6) === void 0) this.setParameter(id6, null);
            this.getParameter(id6).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id6) === void 0) this.setOutput(id6, null);
            this.getOutput(id6).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate) this.dispose();
    if (this._method !== null) return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  dispose() {
    if (this._method === null) return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(value) {
    if (value === true) this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    if (this.codeNode === null) return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var scriptable = nodeProxy(ScriptableNode);
addNodeElement("scriptable", scriptable);
addNodeClass("ScriptableNode", ScriptableNode);

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  getViewZNode(builder) {
    let viewZ;
    const getViewZ = builder.context.getViewZ;
    if (getViewZ !== void 0) {
      viewZ = getViewZ(this);
    }
    return (viewZ || positionView.z).negate();
  }
  setup() {
    return this.factorNode;
  }
};
var FogNode_default = FogNode;
var fog = nodeProxy(FogNode);
addNodeElement("fog", fog);
addNodeClass("FogNode", FogNode);

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  setup(builder) {
    const viewZ = this.getViewZNode(builder);
    return smoothstep(this.nearNode, this.farNode, viewZ);
  }
};
var rangeFog = nodeProxy(FogRangeNode);
addNodeElement("rangeFog", rangeFog);
addNodeClass("FogRangeNode", FogRangeNode);

// node_modules/three/examples/jsm/nodes/fog/FogExp2Node.js
var FogExp2Node = class extends FogNode_default {
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  setup(builder) {
    const viewZ = this.getViewZNode(builder);
    const density = this.densityNode;
    return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
  }
};
var densityFog = nodeProxy(FogExp2Node);
addNodeElement("densityFog", densityFog);
addNodeClass("FogExp2Node", FogExp2Node);

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var min2 = null;
var max2 = null;
var RangeNode = class extends Node_default {
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  setup(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.isInstancedMesh === true) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min2 = min2 || new Vector4();
      max2 = max2 || new Vector4();
      min2.setScalar(0);
      max2.setScalar(0);
      if (minLength === 1) min2.setScalar(minValue);
      else if (minValue.isColor) min2.set(minValue.r, minValue.g, minValue.b);
      else min2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1) max2.setScalar(maxValue);
      else if (maxValue.isColor) max2.set(maxValue.r, maxValue.g, maxValue.b);
      else max2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array = new Float32Array(length2);
      for (let i = 0; i < length2; i++) {
        const index = i % stride;
        const minElementValue = min2.getComponent(index);
        const maxElementValue = max2.getComponent(index);
        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      output2 = buffer(array, "vec4", object.count).element(instanceIndex).convert(nodeType);
    } else {
      output2 = float(0);
    }
    return output2;
  }
};
var range = nodeProxy(RangeNode);
addNodeClass("RangeNode", RangeNode);

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.version = 1;
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet);
      }
    }
  }
};
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addNodeElement("compute", compute);
addNodeClass("ComputeNode", ComputeNode);

// node_modules/three/examples/jsm/nodes/lighting/LightNode.js
var LightNode = class _LightNode extends Node_default {
  constructor(scope = _LightNode.TARGET_DIRECTION, light = null) {
    super();
    this.scope = scope;
    this.light = light;
  }
  setup() {
    const { scope, light } = this;
    let output2 = null;
    if (scope === _LightNode.TARGET_DIRECTION) {
      output2 = cameraViewMatrix.transformDirection(objectPosition(light).sub(objectPosition(light.target)));
    }
    return output2;
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
LightNode.TARGET_DIRECTION = "targetDirection";
var lightTargetDirection = nodeProxy(LightNode, LightNode.TARGET_DIRECTION);
addNodeClass("LightNode", LightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightUtils.js
var getDistanceAttenuation = tslFn((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).cond(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});

// node_modules/three/examples/jsm/nodes/lighting/PointLightNode.js
var PointLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  setup(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightingModel = builder.context.lightingModel;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight,
      shadowMask: this.shadowMaskNode
    }, builder.stack, builder);
  }
};
addNodeClass("PointLightNode", PointLightNode);
addLightNode(PointLight, PointLightNode);

// node_modules/three/examples/jsm/nodes/lighting/DirectionalLightNode.js
var DirectionalLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  setup(builder) {
    super.setup(builder);
    const lightingModel = builder.context.lightingModel;
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight,
      shadowMask: this.shadowMaskNode
    }, builder.stack, builder);
  }
};
addNodeClass("DirectionalLightNode", DirectionalLightNode);
addLightNode(DirectionalLight, DirectionalLightNode);

// node_modules/three/examples/jsm/nodes/lighting/SpotLightNode.js
var SpotLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0);
    this.penumbraCosNode = uniform(0);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  getSpotAttenuation(angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  setup(builder) {
    super.setup(builder);
    const lightingModel = builder.context.lightingModel;
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(angleCos);
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight,
      shadowMask: this.shadowMaskNode
    }, builder.stack, builder);
  }
};
var SpotLightNode_default = SpotLightNode;
addNodeClass("SpotLightNode", SpotLightNode);
addLightNode(SpotLight, SpotLightNode);

// node_modules/three/examples/jsm/lights/IESSpotLight.js
var IESSpotLight = class extends SpotLight {
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var IESSpotLight_default = IESSpotLight;

// node_modules/three/examples/jsm/nodes/lighting/IESSpotLightNode.js
var IESSpotLightNode = class extends SpotLightNode_default {
  getSpotAttenuation(angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
addNodeClass("IESSpotLightNode", IESSpotLightNode);
addLightNode(IESSpotLight_default, IESSpotLightNode);

// node_modules/three/examples/jsm/nodes/lighting/AmbientLightNode.js
var AmbientLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  setup({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
};
addNodeClass("AmbientLightNode", AmbientLightNode);
addLightNode(AmbientLight, AmbientLightNode);

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = objectPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  setup(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalView.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
addNodeClass("HemisphereLightNode", HemisphereLightNode);
addLightNode(HemisphereLight, HemisphereLightNode);

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = tslFn((inputs) => {
  const uv2 = inputs.uv.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var CheckerNode = class extends TempNode_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  setup() {
    return checkerShaderNode({ uv: this.uvNode });
  }
};
var checker = nodeProxy(CheckerNode);
addNodeElement("checker", checker);
addNodeClass("CheckerNode", CheckerNode);

// node_modules/three/examples/jsm/nodes/materials/InstancedPointsNodeMaterial.js
var defaultValues = new PointsMaterial();
var InstancedPointsNodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.useAlphaToCoverage = true;
    this.useColor = params.vertexColors;
    this.pointWidth = 1;
    this.pointColorNode = null;
    this.setDefaultValues(defaultValues);
    this.setupShaders();
    this.setValues(params);
  }
  setupShaders() {
    const useAlphaToCoverage = this.alphaToCoverage;
    const useColor = this.useColor;
    this.vertexNode = tslFn(() => {
      varying(vec2(), "vUv").assign(uv());
      const instancePosition = attribute("instancePosition");
      const mvPos = property("vec4", "mvPos");
      mvPos.assign(modelViewMatrix.mul(vec4(instancePosition, 1)));
      const aspect = viewport.z.div(viewport.w);
      const clipPos = cameraProjectionMatrix.mul(mvPos);
      const offset = property("vec2", "offset");
      offset.assign(positionGeometry.xy);
      offset.assign(offset.mul(materialPointWidth));
      offset.assign(offset.div(viewport.z));
      offset.y.assign(offset.y.mul(aspect));
      offset.assign(offset.mul(clipPos.w));
      clipPos.assign(clipPos.add(vec4(offset, 0, 0)));
      return clipPos;
    })();
    this.fragmentNode = tslFn(() => {
      const vUv = varying(vec2(), "vUv");
      const alpha = property("float", "alpha");
      alpha.assign(1);
      const a = vUv.x;
      const b = vUv.y;
      const len2 = a.mul(a).add(b.mul(b));
      if (useAlphaToCoverage) {
        const dlen = property("float", "dlen");
        dlen.assign(len2.fwidth());
        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
      } else {
        len2.greaterThan(1).discard();
      }
      let pointColorNode;
      if (this.pointColorNode) {
        pointColorNode = this.pointColorNode;
      } else {
        if (useColor) {
          const instanceColor = attribute("instanceColor");
          pointColorNode = instanceColor.mul(materialColor);
        } else {
          pointColorNode = materialColor;
        }
      }
      return vec4(pointColorNode, alpha);
    })();
    this.needsUpdate = true;
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this.useAlphaToCoverage !== value) {
      this.useAlphaToCoverage = value;
      this.setupShaders();
    }
  }
};
addNodeMaterial("InstancedPointsNodeMaterial", InstancedPointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues2 = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
};
addNodeMaterial("LineBasicNodeMaterial", LineBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/LineDashedNodeMaterial.js
var defaultValues3 = new LineDashedMaterial();
var LineDashedNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues3);
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  setupVariants() {
    const offsetNode = this.offsetNode;
    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
    const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
    dashSize.assign(dashSizeNode);
    gapSize.assign(gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
  }
};
addNodeMaterial("LineDashedNodeMaterial", LineDashedNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/Line2NodeMaterial.js
var defaultValues4 = new LineDashedMaterial();
var Line2NodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.setDefaultValues(defaultValues4);
    this.useAlphaToCoverage = true;
    this.useColor = params.vertexColors;
    this.useDash = params.dashed;
    this.useWorldUnits = false;
    this.dashOffset = 0;
    this.lineWidth = 1;
    this.lineColorNode = null;
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(params);
  }
  setup(builder) {
    this.setupShaders();
    super.setup(builder);
  }
  setupShaders() {
    const useAlphaToCoverage = this.alphaToCoverage;
    const useColor = this.useColor;
    const useDash = this.dashed;
    const useWorldUnits = this.worldUnits;
    const trimSegment = tslFn(({ start, end }) => {
      const a = cameraProjectionMatrix.element(2).element(2);
      const b = cameraProjectionMatrix.element(3).element(2);
      const nearEstimate = b.mul(-0.5).div(a);
      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));
      return vec4(mix(start.xyz, end.xyz, alpha), end.w);
    });
    this.vertexNode = tslFn(() => {
      varyingProperty("vec2", "vUv").assign(uv());
      const instanceStart = attribute("instanceStart");
      const instanceEnd = attribute("instanceEnd");
      const start = property("vec4", "start");
      const end = property("vec4", "end");
      start.assign(modelViewMatrix.mul(vec4(instanceStart, 1)));
      end.assign(modelViewMatrix.mul(vec4(instanceEnd, 1)));
      if (useWorldUnits) {
        varyingProperty("vec3", "worldStart").assign(start.xyz);
        varyingProperty("vec3", "worldEnd").assign(end.xyz);
      }
      const aspect = viewport.z.div(viewport.w);
      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1);
      If(perspective, () => {
        If(start.z.lessThan(0).and(end.z.greaterThan(0)), () => {
          end.assign(trimSegment({ start, end }));
        }).elseif(end.z.lessThan(0).and(start.z.greaterThanEqual(0)), () => {
          start.assign(trimSegment({ start: end, end: start }));
        });
      });
      const clipStart = cameraProjectionMatrix.mul(start);
      const clipEnd = cameraProjectionMatrix.mul(end);
      const ndcStart = clipStart.xyz.div(clipStart.w);
      const ndcEnd = clipEnd.xyz.div(clipEnd.w);
      const dir = ndcEnd.xy.sub(ndcStart.xy).temp();
      dir.x.assign(dir.x.mul(aspect));
      dir.assign(dir.normalize());
      const clip = temp(vec4());
      if (useWorldUnits) {
        const worldDir = end.xyz.sub(start.xyz).normalize();
        const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();
        const worldUp = worldDir.cross(tmpFwd).normalize();
        const worldFwd = worldDir.cross(worldUp);
        const worldPos = varyingProperty("vec4", "worldPos");
        worldPos.assign(positionGeometry.y.lessThan(0.5).cond(start, end));
        const hw = materialLineWidth.mul(0.5);
        worldPos.addAssign(vec4(positionGeometry.x.lessThan(0).cond(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));
        if (!useDash) {
          worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).cond(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));
          worldPos.addAssign(vec4(worldFwd.mul(hw), 0));
          If(positionGeometry.y.greaterThan(1).or(positionGeometry.y.lessThan(0)), () => {
            worldPos.subAssign(vec4(worldFwd.mul(2).mul(hw), 0));
          });
        }
        clip.assign(cameraProjectionMatrix.mul(worldPos));
        const clipPose = temp(vec3());
        clipPose.assign(positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));
        clip.z.assign(clipPose.z.mul(clip.w));
      } else {
        const offset = property("vec2", "offset");
        offset.assign(vec2(dir.y, dir.x.negate()));
        dir.x.assign(dir.x.div(aspect));
        offset.x.assign(offset.x.div(aspect));
        offset.assign(positionGeometry.x.lessThan(0).cond(offset.negate(), offset));
        If(positionGeometry.y.lessThan(0), () => {
          offset.assign(offset.sub(dir));
        }).elseif(positionGeometry.y.greaterThan(1), () => {
          offset.assign(offset.add(dir));
        });
        offset.assign(offset.mul(materialLineWidth));
        offset.assign(offset.div(viewport.w));
        clip.assign(positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));
        offset.assign(offset.mul(clip.w));
        clip.assign(clip.add(vec4(offset, 0, 0)));
      }
      return clip;
    })();
    const closestLineToLine = tslFn(({ p1, p2, p3, p4 }) => {
      const p13 = p1.sub(p3);
      const p43 = p4.sub(p3);
      const p21 = p2.sub(p1);
      const d1343 = p13.dot(p43);
      const d4321 = p43.dot(p21);
      const d1321 = p13.dot(p21);
      const d4343 = p43.dot(p43);
      const d2121 = p21.dot(p21);
      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));
      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));
      const mua = numer.div(denom).clamp();
      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();
      return vec2(mua, mub);
    });
    this.fragmentNode = tslFn(() => {
      const vUv = varyingProperty("vec2", "vUv");
      if (useDash) {
        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;
        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
        dashSize.assign(dashSizeNode);
        gapSize.assign(gapSizeNode);
        const instanceDistanceStart = attribute("instanceDistanceStart");
        const instanceDistanceEnd = attribute("instanceDistanceEnd");
        const lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));
        const vLineDistance = varying(lineDistance.add(materialLineDashOffset));
        const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
        vUv.y.lessThan(-1).or(vUv.y.greaterThan(1)).discard();
        vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
      }
      const alpha = property("float", "alpha");
      alpha.assign(1);
      if (useWorldUnits) {
        const worldStart = varyingProperty("vec3", "worldStart");
        const worldEnd = varyingProperty("vec3", "worldEnd");
        const rayEnd = varyingProperty("vec4", "worldPos").xyz.normalize().mul(1e5);
        const lineDir = worldEnd.sub(worldStart);
        const params = closestLineToLine({ p1: worldStart, p2: worldEnd, p3: vec3(0, 0, 0), p4: rayEnd });
        const p1 = worldStart.add(lineDir.mul(params.x));
        const p2 = rayEnd.mul(params.y);
        const delta = p1.sub(p2);
        const len = delta.length();
        const norm = len.div(materialLineWidth);
        if (!useDash) {
          if (useAlphaToCoverage) {
            const dnorm = norm.fwidth();
            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());
          } else {
            norm.greaterThan(0.5).discard();
          }
        }
      } else {
        if (useAlphaToCoverage) {
          const a = vUv.x;
          const b = vUv.y.greaterThan(0).cond(vUv.y.sub(1), vUv.y.add(1));
          const len2 = a.mul(a).add(b.mul(b));
          const dlen = property("float", "dlen");
          dlen.assign(len2.fwidth());
          If(vUv.y.abs().greaterThan(1), () => {
            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
          });
        } else {
          If(vUv.y.abs().greaterThan(1), () => {
            const a = vUv.x;
            const b = vUv.y.greaterThan(0).cond(vUv.y.sub(1), vUv.y.add(1));
            const len2 = a.mul(a).add(b.mul(b));
            len2.greaterThan(1).discard();
          });
        }
      }
      let lineColorNode;
      if (this.lineColorNode) {
        lineColorNode = this.lineColorNode;
      } else {
        if (useColor) {
          const instanceColorStart = attribute("instanceColorStart");
          const instanceColorEnd = attribute("instanceColorEnd");
          const instanceColor = positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd);
          lineColorNode = instanceColor.mul(materialColor);
        } else {
          lineColorNode = materialColor;
        }
      }
      return vec4(lineColorNode, alpha);
    })();
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(value) {
    if (this.useWorldUnits !== value) {
      this.useWorldUnits = value;
      this.needsUpdate = true;
    }
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(value) {
    if (this.useDash !== value) {
      this.useDash = value;
      this.needsUpdate = true;
    }
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this.useAlphaToCoverage !== value) {
      this.useAlphaToCoverage = value;
      this.needsUpdate = true;
    }
  }
};
addNodeMaterial("Line2NodeMaterial", Line2NodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshNormalNodeMaterial.js
var defaultValues5 = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  setupDiffuseColor() {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));
  }
};
addNodeMaterial("MeshNormalNodeMaterial", MeshNormalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues6 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
};
addNodeMaterial("MeshBasicNodeMaterial", MeshBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = tslFn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = tslFn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/PhongLightingModel.js
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = tslFn(({ dotNH }) => {
  return shininess.mul(float(0.5)).add(1).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick_default({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D);
});
var PhongLightingModel = class extends LightingModel_default {
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
    }
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
};
var PhongLightingModel_default = PhongLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshLambertNodeMaterial.js
var defaultValues7 = new MeshLambertMaterial();
var MeshLambertNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues7);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhongLightingModel_default(false);
  }
};
addNodeMaterial("MeshLambertNodeMaterial", MeshLambertNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhongNodeMaterial.js
var defaultValues8 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(defaultValues8);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhongLightingModel_default();
  }
  setupVariants() {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    shininess.assign(shininessNode);
    const specularNode = this.specularNode || materialSpecular;
    specularColor.assign(specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
};
addNodeMaterial("MeshPhongNodeMaterial", MeshPhongNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = tslFn(() => {
  const dxy = normalGeometry.dFdx().abs().max(normalGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = tslFn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = tslFn(({ alpha, dotNL, dotNV }) => {
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated_Anisotropic.js
var V_GGX_SmithCorrelated_Anisotropic = tslFn(({ alphaT: alphaT2, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
  const gv = dotNL.mul(vec3(alphaT2.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
  const gl = dotNV.mul(vec3(alphaT2.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
  const v = div(0.5, gv.add(gl));
  return v.saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
});
var V_GGX_SmithCorrelated_Anisotropic_default = V_GGX_SmithCorrelated_Anisotropic;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = tslFn(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX_Anisotropic.js
var RECIPROCAL_PI = float(1 / Math.PI);
var D_GGX_Anisotropic = tslFn(({ alphaT: alphaT2, alphaB, dotNH, dotTH, dotBH }) => {
  const a2 = alphaT2.mul(alphaB);
  const v = vec3(alphaB.mul(dotTH), alphaT2.mul(dotBH), a2.mul(dotNH));
  const v2 = v.dot(v);
  const w22 = a2.div(v2);
  return RECIPROCAL_PI.mul(a2.mul(w22.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
});
var D_GGX_Anisotropic_default = D_GGX_Anisotropic;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = tslFn((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;
  const normalView2 = inputs.normalView || transformedNormalView;
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView2.dot(lightDirection).clamp();
  const dotNV = normalView2.dot(positionViewDirection).clamp();
  const dotNH = normalView2.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick_default({ f0, f90, dotVH });
  let V, D;
  if (defined(USE_IRIDESCENCE)) {
    F = iridescence.mix(F, f);
  }
  if (defined(USE_ANISOTROPY)) {
    const dotTL = anisotropyT.dot(lightDirection);
    const dotTV = anisotropyT.dot(positionViewDirection);
    const dotTH = anisotropyT.dot(halfDir);
    const dotBL = anisotropyB.dot(lightDirection);
    const dotBV = anisotropyB.dot(positionViewDirection);
    const dotBH = anisotropyB.dot(halfDir);
    V = V_GGX_SmithCorrelated_Anisotropic_default({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
    D = D_GGX_Anisotropic_default({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
  } else {
    V = V_GGX_SmithCorrelated_default({ alpha, dotNL, dotNV });
    D = D_GGX_default({ alpha, dotNH });
  }
  return F.mul(V).mul(D);
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = tslFn(({ roughness: roughness2, dotNV }) => {
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness2.mul(c0).add(c1);
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/BSDF/EnvironmentBRDF.js
var EnvironmentBRDF = tslFn((inputs) => {
  const { dotNV, specularColor: specularColor2, specularF90: specularF902, roughness: roughness2 } = inputs;
  const fab = DFGApprox_default({ dotNV, roughness: roughness2 });
  return specularColor2.mul(fab.x).add(specularF902.mul(fab.y));
});
var EnvironmentBRDF_default = EnvironmentBRDF;

// node_modules/three/examples/jsm/nodes/functions/BSDF/Schlick_to_F0.js
var Schlick_to_F0 = tslFn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
var Schlick_to_F0_default = Schlick_to_F0;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Sheen.js
var D_Charlie = tslFn(({ roughness: roughness2, dotNH }) => {
  const alpha = roughness2.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var V_Neubelt = tslFn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
});
var BRDF_Sheen = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const D = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D).mul(V);
});
var BRDF_Sheen_default = BRDF_Sheen;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var getVolumeTransmissionRay = tslFn(([n, v, thickness2, ior2, modelMatrix]) => {
  const refractionVector = vec3(refract(v.negate(), normalize(n), div(1, ior2)));
  const modelScale2 = vec3(
    length(modelMatrix[0].xyz),
    length(modelMatrix[1].xyz),
    length(modelMatrix[2].xyz)
  );
  return normalize(refractionVector).mul(thickness2.mul(modelScale2));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
});
var applyIorToRoughness = tslFn(([roughness2, ior2]) => {
  return roughness2.mul(clamp(ior2.mul(2).sub(2), 0, 1));
}).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
});
var singleViewportMipTexture = viewportMipTexture();
var getTransmissionSample = tslFn(([fragCoord, roughness2, ior2]) => {
  const transmissionSample = singleViewportMipTexture.uv(fragCoord);
  const lod = log2(float(viewportResolution.x)).mul(applyIorToRoughness(roughness2, ior2));
  return transmissionSample.bicubic(lod);
});
var volumeAttenuation = tslFn(([transmissionDistance, attenuationColor2, attenuationDistance2]) => {
  If(attenuationDistance2.notEqual(0), () => {
    const attenuationCoefficient = log(attenuationColor2).negate().div(attenuationDistance2);
    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));
    return transmittance;
  });
  return vec3(1);
}).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
});
var getIBLVolumeRefraction = tslFn(([n, v, roughness2, diffuseColor2, specularColor2, specularF902, position, modelMatrix, viewMatrix, projMatrix, ior2, thickness2, attenuationColor2, attenuationDistance2, dispersion2]) => {
  let transmittedLight, transmittance;
  if (dispersion2) {
    transmittedLight = vec4().toVar();
    transmittance = vec3().toVar();
    const halfSpread = ior2.sub(1).mul(dispersion2.mul(0.025));
    const iors = vec3(ior2.sub(halfSpread), ior2, ior2.add(halfSpread));
    loop({ start: 0, end: 3 }, ({ i }) => {
      const ior3 = iors.element(i);
      const transmissionRay = getVolumeTransmissionRay(n, v, thickness2, ior3, modelMatrix);
      const refractedRayExit = position.add(transmissionRay);
      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1);
      refractionCoords.divAssign(2);
      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
      const transmissionSample = getTransmissionSample(refractionCoords, roughness2, ior3);
      transmittedLight.element(i).assign(transmissionSample.element(i));
      transmittedLight.a.addAssign(transmissionSample.a);
      transmittance.element(i).assign(diffuseColor2.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor2, attenuationDistance2).element(i)));
    });
    transmittedLight.a.divAssign(3);
  } else {
    const transmissionRay = getVolumeTransmissionRay(n, v, thickness2, ior2, modelMatrix);
    const refractedRayExit = position.add(transmissionRay);
    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
    refractionCoords.addAssign(1);
    refractionCoords.divAssign(2);
    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
    transmittedLight = getTransmissionSample(refractionCoords, roughness2, ior2);
    transmittance = diffuseColor2.mul(volumeAttenuation(length(transmissionRay), attenuationColor2, attenuationDistance2));
  }
  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
  const dotNV = n.dot(v).clamp();
  const F = vec3(EnvironmentBRDF_default({
    // n, v, specularColor, specularF90, roughness
    dotNV,
    specularColor: specularColor2,
    specularF90: specularF902,
    roughness: roughness2
  }));
  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3);
  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
});
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb = XYZ_TO_REC709.mul(xyz);
  return rgb;
};
var evalIridescence = tslFn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
  const iridescenceIOR2 = mix(outsideIOR, eta2, smoothstep(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR2).pow2().mul(float(1).sub(cosTheta1.pow2()));
  const cosTheta2Sq = float(1).sub(sinTheta2Sq);
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);
  const R12 = F_Schlick_default({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR2.lessThan(outsideIOR).cond(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.toVec3());
  const R23 = F_Schlick_default({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR2).cond(Math.PI, 0)
  );
  const OPD = iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  let I = C0;
  let Cm = Rs.sub(T121);
  for (let m = 1; m <= 2; ++m) {
    Cm = Cm.mul(r123);
    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
    I = I.add(Cm.mul(Sm));
  }
  return I.max(vec3(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
});
var IBLSheenBRDF = tslFn(({ normal: normal2, viewDir, roughness: roughness2 }) => {
  const dotNV = normal2.dot(viewDir).saturate();
  const r2 = roughness2.pow2();
  const a = cond(
    roughness2.lessThan(0.25),
    float(-339.2).mul(r2).add(float(161.4).mul(roughness2)).sub(25.9),
    float(-8.48).mul(r2).add(float(14.3).mul(roughness2)).sub(9.95)
  );
  const b = cond(
    roughness2.lessThan(0.25),
    float(44).mul(r2).sub(float(23.7).mul(roughness2)).add(3.26),
    float(1.97).mul(r2).sub(float(3.27).mul(roughness2)).add(0.72)
  );
  const DG = cond(roughness2.lessThan(0.25), 0, float(0.1).mul(roughness2).sub(0.025)).add(a.mul(dotNV).add(b).exp());
  return DG.mul(1 / Math.PI).saturate();
});
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = float(1);
var PhysicalLightingModel = class extends LightingModel_default {
  constructor(clearcoat2 = false, sheen2 = false, iridescence2 = false, anisotropy2 = false, transmission2 = false, dispersion2 = false) {
    super();
    this.clearcoat = clearcoat2;
    this.sheen = sheen2;
    this.iridescence = iridescence2;
    this.anisotropy = anisotropy2;
    this.transmission = transmission2;
    this.dispersion = dispersion2;
    this.clearcoatRadiance = null;
    this.clearcoatSpecularDirect = null;
    this.clearcoatSpecularIndirect = null;
    this.sheenSpecularDirect = null;
    this.sheenSpecularIndirect = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
  }
  start(context2) {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().temp("clearcoatRadiance");
      this.clearcoatSpecularDirect = vec3().temp("clearcoatSpecularDirect");
      this.clearcoatSpecularIndirect = vec3().temp("clearcoatSpecularIndirect");
    }
    if (this.sheen === true) {
      this.sheenSpecularDirect = vec3().temp("sheenSpecularDirect");
      this.sheenSpecularIndirect = vec3().temp("sheenSpecularIndirect");
    }
    if (this.iridescence === true) {
      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();
      this.iridescenceFresnel = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: specularColor
      });
      this.iridescenceF0 = Schlick_to_F0_default({ f: this.iridescenceFresnel, f90: 1, dotVH: dotNVi });
    }
    if (this.transmission === true) {
      const position = positionWorld;
      const v = cameraPosition.sub(positionWorld).normalize();
      const n = transformedNormalWorld;
      context2.backdrop = getIBLVolumeRefraction(
        n,
        v,
        roughness,
        diffuseColor,
        specularColor,
        specularF90,
        // specularF90
        position,
        // positionWorld
        modelWorldMatrix,
        // modelMatrix
        cameraViewMatrix,
        // viewMatrix
        cameraProjectionMatrix,
        // projMatrix
        ior,
        thickness,
        attenuationColor,
        attenuationDistance,
        this.dispersion ? dispersion : null
      );
      context2.backdropAlpha = transmission;
      diffuseColor.a.mulAssign(mix(1, context2.backdrop.a, transmission));
    }
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF902) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const fab = DFGApprox_default({ roughness, dotNV });
    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
    const FssEss = Fr.mul(fab.x).add(specularF902.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    if (this.sheen === true) {
      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen_default({ lightDirection })));
    }
    if (this.clearcoat === true) {
      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX_default({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView })));
    }
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_default({ lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
  indirectSpecular({ radiance, iblIrradiance, reflectedLight }) {
    if (this.sheen === true) {
      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(
        sheen,
        IBLSheenBRDF({
          normal: transformedNormalView,
          viewDir: positionViewDirection,
          roughness: sheenRoughness
        })
      ));
    }
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF_default({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
    }
    const singleScattering = vec3().temp("singleScattering");
    const multiScattering = vec3().temp("multiScattering");
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    this.computeMultiscattering(singleScattering, multiScattering, specularF90);
    const totalScattering = singleScattering.add(multiScattering);
    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
  }
  ambientOcclusion({ ambientOcclusion, reflectedLight }) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    if (this.clearcoat === true) {
      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
    }
    if (this.sheen === true) {
      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
  finish(context2) {
    const { outgoingLight } = context2;
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick_default({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90
      });
      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      outgoingLight.assign(sheenLight);
    }
  }
};
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues9 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(defaultValues9);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhysicalLightingModel_default();
  }
  setupSpecular() {
    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);
    specularColor.assign(specularColorNode);
    specularF90.assign(1);
  }
  setupVariants() {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    metalness.assign(metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default({ roughness: roughnessNode });
    roughness.assign(roughnessNode);
    this.setupSpecular();
    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
};
var MeshStandardNodeMaterial_default = MeshStandardNodeMaterial;
addNodeMaterial("MeshStandardNodeMaterial", MeshStandardNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues10 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.iorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.dispersionNode = null;
    this.anisotropyNode = null;
    this.setDefaultValues(defaultValues10);
    this.setValues(parameters);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  setupSpecular() {
    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
    ior.assign(iorNode);
    specularColor.assign(mix(min(pow2(ior.sub(1).div(ior.add(1))).mul(materialSpecularColor), vec3(1)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));
    specularF90.assign(mix(materialSpecularIntensity, 1, metalness));
  }
  setupLightingModel() {
    return new PhysicalLightingModel_default(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  setupVariants(builder) {
    super.setupVariants(builder);
    if (this.useClearcoat) {
      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
      clearcoat.assign(clearcoatNode);
      clearcoatRoughness.assign(getRoughness_default({ roughness: clearcoatRoughnessNode }));
    }
    if (this.useSheen) {
      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
      sheen.assign(sheenNode);
      sheenRoughness.assign(sheenRoughnessNode);
    }
    if (this.useIridescence) {
      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
      iridescence.assign(iridescenceNode);
      iridescenceIOR.assign(iridescenceIORNode);
      iridescenceThickness.assign(iridescenceThicknessNode);
    }
    if (this.useAnisotropy) {
      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();
      anisotropy.assign(anisotropyV.length());
      If(anisotropy.equal(0), () => {
        anisotropyV.assign(vec2(1, 0));
      }).else(() => {
        anisotropyV.divAssign(anisotropy);
        anisotropy.assign(anisotropy.saturate());
      });
      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1));
      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));
      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));
    }
    if (this.useTransmission) {
      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;
      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;
      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;
      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;
      transmission.assign(transmissionNode);
      thickness.assign(thicknessNode);
      attenuationDistance.assign(attenuationDistanceNode);
      attenuationColor.assign(attenuationColorNode);
      if (this.useDispersion) {
        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;
        dispersion.assign(dispersionNode);
      }
    }
  }
  setupNormal(builder) {
    super.setupNormal(builder);
    const clearcoatNormalNode = this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
    transformedClearcoatNormalView.assign(clearcoatNormalNode);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    this.dispersionNode = source.dispersionNode;
    this.anisotropyNode = source.anisotropyNode;
    return super.copy(source);
  }
};
var MeshPhysicalNodeMaterial_default = MeshPhysicalNodeMaterial;
addNodeMaterial("MeshPhysicalNodeMaterial", MeshPhysicalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshSSSNodeMaterial.js
var SSSLightingModel = class extends PhysicalLightingModel_default {
  constructor(useClearcoat, useSheen, useIridescence, useSSS) {
    super(useClearcoat, useSheen, useIridescence);
    this.useSSS = useSSS;
  }
  direct({ lightDirection, lightColor, reflectedLight }, stack2, builder) {
    if (this.useSSS === true) {
      const material = builder.material;
      const { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;
      const scatteringHalf = lightDirection.add(transformedNormalView.mul(thicknessDistortionNode)).normalize();
      const scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));
      const scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));
      reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));
    }
    super.direct({ lightDirection, lightColor, reflectedLight }, stack2, builder);
  }
};
var MeshSSSNodeMaterial = class extends MeshPhysicalNodeMaterial_default {
  constructor(parameters) {
    super(parameters);
    this.thicknessColorNode = null;
    this.thicknessDistortionNode = float(0.1);
    this.thicknessAmbientNode = float(0);
    this.thicknessAttenuationNode = float(0.1);
    this.thicknessPowerNode = float(2);
    this.thicknessScaleNode = float(10);
  }
  get useSSS() {
    return this.thicknessColorNode !== null;
  }
  setupLightingModel() {
    return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS);
  }
  copy(source) {
    this.thicknessColorNode = source.thicknessColorNode;
    this.thicknessDistortionNode = source.thicknessDistortionNode;
    this.thicknessAmbientNode = source.thicknessAmbientNode;
    this.thicknessAttenuationNode = source.thicknessAttenuationNode;
    this.thicknessPowerNode = source.thicknessPowerNode;
    this.thicknessScaleNode = source.thicknessScaleNode;
    return super.copy(source);
  }
};
addNodeMaterial("MeshSSSNodeMaterial", MeshSSSNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/ToonLightingModel.js
var getGradientIrradiance = tslFn(({ normal: normal2, lightDirection, builder }) => {
  const dotNL = normal2.dot(lightDirection);
  const coord = vec2(dotNL.mul(0.5).add(0.5), 0);
  if (builder.material.gradientMap) {
    const gradientMap = materialReference("gradientMap", "texture").context({ getUV: () => coord });
    return vec3(gradientMap.r);
  } else {
    const fw = coord.fwidth().mul(0.5);
    return mix(vec3(0.7), vec3(1), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
  }
});
var ToonLightingModel = class extends LightingModel_default {
  direct({ lightDirection, lightColor, reflectedLight }, stack2, builder) {
    const irradiance = getGradientIrradiance({ normal: normalGeometry, lightDirection, builder }).mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
};
var ToonLightingModel_default = ToonLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshToonNodeMaterial.js
var defaultValues11 = new MeshToonMaterial();
var MeshToonNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshToonNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues11);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new ToonLightingModel_default();
  }
};
addNodeMaterial("MeshToonNodeMaterial", MeshToonNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshMatcapNodeMaterial.js
var defaultValues12 = new MeshMatcapMaterial();
var MeshMatcapNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshMatcapNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues12);
    this.setValues(parameters);
  }
  setupVariants(builder) {
    const uv2 = matcapUV;
    let matcapColor;
    if (builder.material.matcap) {
      matcapColor = materialReference("matcap", "texture").context({ getUV: () => uv2 });
    } else {
      matcapColor = vec3(mix(0.2, 0.8, uv2.y));
    }
    diffuseColor.rgb.mulAssign(matcapColor.rgb);
  }
};
addNodeMaterial("MeshMatcapNodeMaterial", MeshMatcapNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues13 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.transparent = true;
    this.sizeNode = null;
    this.setDefaultValues(defaultValues13);
    this.setValues(parameters);
  }
  copy(source) {
    this.sizeNode = source.sizeNode;
    return super.copy(source);
  }
};
addNodeMaterial("PointsNodeMaterial", PointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues14 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues14);
    this.setValues(parameters);
  }
  setupPosition({ object, context: context2 }) {
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale = scale.mul(scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (object.center && object.center.isVector2 === true) {
      alignedPosition = alignedPosition.sub(uniform(object.center).sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale);
    const rotation = float(rotationNode || materialRotation);
    const rotatedPosition = alignedPosition.rotate(rotation);
    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
    const modelViewProjection2 = cameraProjectionMatrix.mul(mvPosition);
    context2.vertex = vertex;
    return modelViewProjection2;
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
addNodeMaterial("SpriteNodeMaterial", SpriteNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/ShadowMaskModel.js
var ShadowMaskModel = class extends LightingModel_default {
  constructor() {
    super();
    this.shadowNode = float(1).toVar("shadowMask");
  }
  direct({ shadowMask }) {
    this.shadowNode.mulAssign(shadowMask);
  }
  finish(context2) {
    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
    context2.outgoingLight.rgb.assign(diffuseColor.rgb);
  }
};
var ShadowMaskModel_default = ShadowMaskModel;

// node_modules/three/examples/jsm/nodes/materials/ShadowNodeMaterial.js
var defaultValues15 = new ShadowMaterial();
var ShadowNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isShadowNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues15);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new ShadowMaskModel_default();
  }
};
addNodeMaterial("ShadowNodeMaterial", ShadowNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/VolumeNodeMaterial.js
var VolumeNodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.isVolumeNodeMaterial = true;
    this.testNode = null;
    this.setValues(params);
  }
  setup(builder) {
    const map = texture3D(this.map, null, 0);
    const hitBox = tslFn(({ orig, dir }) => {
      const box_min = vec3(-0.5);
      const box_max = vec3(0.5);
      const inv_dir = dir.reciprocal();
      const tmin_tmp = box_min.sub(orig).mul(inv_dir);
      const tmax_tmp = box_max.sub(orig).mul(inv_dir);
      const tmin = min(tmin_tmp, tmax_tmp);
      const tmax = max(tmin_tmp, tmax_tmp);
      const t0 = max(tmin.x, max(tmin.y, tmin.z));
      const t1 = min(tmax.x, min(tmax.y, tmax.z));
      return vec2(t0, t1);
    });
    this.fragmentNode = tslFn(() => {
      const vOrigin = varying(vec3(modelWorldMatrixInverse.mul(vec4(cameraPosition, 1))));
      const vDirection = varying(positionGeometry.sub(vOrigin));
      const rayDir = vDirection.normalize();
      const bounds = property("vec2", "bounds").assign(hitBox({ orig: vOrigin, dir: rayDir }));
      bounds.x.greaterThan(bounds.y).discard();
      bounds.assign(vec2(max(bounds.x, 0), bounds.y));
      const p = property("vec3", "p").assign(vOrigin.add(bounds.x.mul(rayDir)));
      const inc = property("vec3", "inc").assign(vec3(rayDir.abs().reciprocal()));
      const delta = property("float", "delta").assign(min(inc.x, min(inc.y, inc.z)));
      delta.divAssign(materialReference("steps", "float"));
      const ac = property("vec4", "ac").assign(vec4(materialReference("base", "color"), 0));
      loop({ type: "float", start: bounds.x, end: bounds.y, update: "+= delta" }, () => {
        const d = property("float", "d").assign(map.uv(p.add(0.5)).r);
        if (this.testNode !== null) {
          this.testNode({ map, mapValue: d, probe: p, finalColor: ac }).append();
        } else {
          ac.a.assign(1);
          Break();
        }
        p.addAssign(rayDir.mul(delta));
      });
      ac.a.equal(0).discard();
      return vec4(ac);
    })();
    super.setup(builder);
  }
};
addNodeMaterial("VolumeNodeMaterial", VolumeNodeMaterial);

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const material = createNodeMaterialFromType(type);
  if (material !== void 0) {
    return material;
  }
  return superFromTypeFunction.call(this, type);
};

// node_modules/three/examples/jsm/nodes/core/NodeParser.js
var NodeParser = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeParser_default = NodeParser;

// node_modules/three/examples/jsm/nodes/core/NodeFunction.js
var NodeFunction = class {
  constructor(type, inputs, name = "", presicion = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.presicion = presicion;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var NodeFunction_default = NodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js
var declarationRegexp = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count) === false) i++;
      else count = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput_default(type2, name2, count, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const presicion = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      presicion,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse(source);
    super(type, inputs, name, presicion);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, presicion } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (presicion !== "") {
        declarationCode = `${presicion} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeFunction_default = GLSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeParser.js
var GLSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new GLSLNodeFunction_default(source);
  }
};
var GLSLNodeParser_default = GLSLNodeParser;

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_select = tslFn(([b_immutable, t_immutable, f_immutable]) => {
  const f = float(f_immutable).toVar();
  const t = float(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return cond(b, t, f);
});
var mx_negate_if = tslFn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return cond(b, val.negate(), val);
});
var mx_floor = tslFn(([x_immutable]) => {
  const x = float(x_immutable).toVar();
  return int(floor(x));
});
var mx_floorfrac = tslFn(([x_immutable, i]) => {
  const x = float(x_immutable).toVar();
  i.assign(mx_floor(x));
  return x.sub(float(i));
});
var mx_bilerp_0 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
});
var mx_bilerp_1 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
});
var mx_bilerp = overloadingFn([mx_bilerp_0, mx_bilerp_1]);
var mx_trilerp_0 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = float(v7_immutable).toVar();
  const v6 = float(v6_immutable).toVar();
  const v5 = float(v5_immutable).toVar();
  const v4 = float(v4_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
});
var mx_trilerp_1 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = vec3(v7_immutable).toVar();
  const v6 = vec3(v6_immutable).toVar();
  const v5 = vec3(v5_immutable).toVar();
  const v4 = vec3(v4_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
});
var mx_trilerp = overloadingFn([mx_trilerp_0, mx_trilerp_1]);
var mx_gradient_float_0 = tslFn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uint(hash_immutable).toVar();
  const h = uint(hash2.bitAnd(uint(7))).toVar();
  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
  const v = float(mul(2, mx_select(h.lessThan(uint(4)), y, x))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
});
var mx_gradient_float_1 = tslFn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uint(hash_immutable).toVar();
  const h = uint(hash2.bitAnd(uint(15))).toVar();
  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
});
var mx_gradient_float = overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
var mx_gradient_vec3_0 = tslFn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash2.x, x, y), mx_gradient_float(hash2.y, x, y), mx_gradient_float(hash2.z, x, y));
});
var mx_gradient_vec3_1 = tslFn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash2.x, x, y, z), mx_gradient_float(hash2.y, x, y, z), mx_gradient_float(hash2.z, x, y, z));
});
var mx_gradient_vec3 = overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
var mx_gradient_scale2d_0 = tslFn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.6616, v);
});
var mx_gradient_scale3d_0 = tslFn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.982, v);
});
var mx_gradient_scale2d_1 = tslFn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.6616, v);
});
var mx_gradient_scale2d = overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
var mx_gradient_scale3d_1 = tslFn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.982, v);
});
var mx_gradient_scale3d = overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
var mx_rotl32 = tslFn(([x_immutable, k_immutable]) => {
  const k = int(k_immutable).toVar();
  const x = uint(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
});
var mx_bjmix = tslFn(([a, b, c]) => {
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(4)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(6)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a);
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(16)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(19)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a);
});
var mx_bjfinal = tslFn(([a_immutable, b_immutable, c_immutable]) => {
  const c = uint(c_immutable).toVar();
  const b = uint(b_immutable).toVar();
  const a = uint(a_immutable).toVar();
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(14)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(11)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(25)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(16)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(4)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(14)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(24)));
  return c;
});
var mx_bits_to_01 = tslFn(([bits_immutable]) => {
  const bits = uint(bits_immutable).toVar();
  return float(bits).div(float(uint(int(4294967295))));
});
var mx_fade = tslFn(([t_immutable]) => {
  const t = float(t_immutable).toVar();
  return t.mul(t.mul(t.mul(t.mul(t.mul(6).sub(15)).add(10))));
});
var mx_hash_int_0 = tslFn(([x_immutable]) => {
  const x = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13)))).toVar();
  return mx_bjfinal(seed.add(uint(x)), seed, seed);
});
var mx_hash_int_1 = tslFn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_2 = tslFn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(3)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_3 = tslFn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(4)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_4 = tslFn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int(yy_immutable).toVar();
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(5)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  b.addAssign(uint(yy));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int = overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
var mx_hash_vec3_0 = tslFn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
});
var mx_hash_vec3_1 = tslFn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y, z)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
});
var mx_hash_vec3 = overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
var mx_perlin_noise_float_0 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
});
var mx_perlin_noise_float_1 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
});
var mx_perlin_noise_float = overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
var mx_perlin_noise_vec3_0 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
});
var mx_perlin_noise_vec3_1 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
});
var mx_perlin_noise_vec3 = overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
var mx_cell_noise_float_0 = tslFn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
});
var mx_cell_noise_float_1 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
});
var mx_cell_noise_float_2 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
});
var mx_cell_noise_float_3 = tslFn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
});
var mx_cell_noise_float = overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
var mx_cell_noise_vec3_0 = tslFn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
});
var mx_cell_noise_vec3_1 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
});
var mx_cell_noise_vec3_2 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
});
var mx_cell_noise_vec3_3 = tslFn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
});
var mx_cell_noise_vec3 = overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
var mx_fractal_noise_float = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = float(0).toVar();
  const amplitude = float(1).toVar();
  loop({ start: int(0), end: octaves }, ({ i }) => {
    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
});
var mx_fractal_noise_vec3 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = vec3(0).toVar();
  const amplitude = float(1).toVar();
  loop({ start: int(0), end: octaves }, ({ i }) => {
    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
});
var mx_fractal_noise_vec2 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish), mx_fractal_noise_float(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
});
var mx_fractal_noise_vec4 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const c = vec3(mx_fractal_noise_vec3(p, octaves, lacunarity, diminish)).toVar();
  const f = float(mx_fractal_noise_float(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
  return vec4(c, f);
});
var mx_worley_distance_0 = tslFn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
  const off = vec2(tmp.x, tmp.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
  const diff = vec2(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y));
  });
  If(metric.equal(int(3)), () => {
    return max(abs(diff.x), abs(diff.y));
  });
  return dot(diff, diff);
});
var mx_worley_distance_1 = tslFn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const zoff = int(zoff_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
  const diff = vec3(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y).add(abs(diff.z)));
  });
  If(metric.equal(int(3)), () => {
    return max(max(abs(diff.x), abs(diff.y)), abs(diff.z));
  });
  return dot(diff, diff);
});
var mx_worley_distance = overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
var mx_worley_noise_float_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = float(1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      sqdist.assign(min(sqdist, dist));
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec2_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).elseif(dist.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec3_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).elseif(dist.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist);
      }).elseif(dist.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_float_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = float(1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        sqdist.assign(min(sqdist, dist));
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_float = overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
var mx_worley_noise_vec2_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).elseif(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec2 = overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
var mx_worley_noise_vec3_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).elseif(dist.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).elseif(dist.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec3 = overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
mx_select.setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
mx_negate_if.setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
mx_floor.setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
mx_bilerp_0.setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
mx_bilerp_1.setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
mx_trilerp_0.setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
mx_trilerp_1.setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
mx_gradient_float_0.setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
mx_gradient_float_1.setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
mx_gradient_vec3_0.setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
mx_gradient_vec3_1.setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
mx_gradient_scale2d_0.setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
mx_gradient_scale3d_0.setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
mx_gradient_scale2d_1.setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
mx_gradient_scale3d_1.setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
mx_rotl32.setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
mx_bjfinal.setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
mx_bits_to_01.setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
mx_fade.setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
mx_hash_int_0.setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
mx_hash_int_1.setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
mx_hash_int_2.setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
mx_hash_int_3.setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
mx_hash_int_4.setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
mx_hash_vec3_0.setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
mx_hash_vec3_1.setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
mx_perlin_noise_float_0.setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_perlin_noise_float_1.setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_perlin_noise_vec3_0.setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_perlin_noise_vec3_1.setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_float_0.setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
mx_cell_noise_float_1.setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_cell_noise_float_2.setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_float_3.setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
mx_cell_noise_vec3_0.setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
mx_cell_noise_vec3_1.setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_cell_noise_vec3_2.setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_vec3_3.setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
mx_fractal_noise_float.setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec3.setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec2.setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec4.setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_worley_distance_0.setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_distance_1.setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_float_0.setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec2_0.setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec3_0.setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_float_1.setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec2_1.setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec3_1.setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js
var mx_hsvtorgb = tslFn(([hsv_immutable]) => {
  const hsv = vec3(hsv_immutable).toVar();
  const h = float(hsv.x).toVar();
  const s = float(hsv.y).toVar();
  const v = float(hsv.z).toVar();
  If(s.lessThan(1e-4), () => {
    return vec3(v, v, v);
  }).else(() => {
    h.assign(mul(6, h.sub(floor(h))));
    const hi = int(trunc(h)).toVar();
    const f = float(h.sub(float(hi))).toVar();
    const p = float(v.mul(sub(1, s))).toVar();
    const q = float(v.mul(sub(1, s.mul(f)))).toVar();
    const t = float(v.mul(sub(1, s.mul(sub(1, f))))).toVar();
    If(hi.equal(int(0)), () => {
      return vec3(v, t, p);
    }).elseif(hi.equal(int(1)), () => {
      return vec3(q, v, p);
    }).elseif(hi.equal(int(2)), () => {
      return vec3(p, v, t);
    }).elseif(hi.equal(int(3)), () => {
      return vec3(p, q, v);
    }).elseif(hi.equal(int(4)), () => {
      return vec3(t, p, v);
    });
    return vec3(v, p, q);
  });
});
var mx_rgbtohsv = tslFn(([c_immutable]) => {
  const c = vec3(c_immutable).toVar();
  const r = float(c.x).toVar();
  const g = float(c.y).toVar();
  const b = float(c.z).toVar();
  const mincomp = float(min(r, min(g, b))).toVar();
  const maxcomp = float(max(r, max(g, b))).toVar();
  const delta = float(maxcomp.sub(mincomp)).toVar();
  const h = float().toVar(), s = float().toVar(), v = float().toVar();
  v.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s.assign(delta.div(maxcomp));
  }).else(() => {
    s.assign(0);
  });
  If(s.lessThanEqual(0), () => {
    h.assign(0);
  }).else(() => {
    If(r.greaterThanEqual(maxcomp), () => {
      h.assign(g.sub(b).div(delta));
    }).elseif(g.greaterThanEqual(maxcomp), () => {
      h.assign(add(2, b.sub(r).div(delta)));
    }).else(() => {
      h.assign(add(4, r.sub(g).div(delta)));
    });
    h.mulAssign(1 / 6);
    If(h.lessThan(0), () => {
      h.addAssign(1);
    });
  });
  return vec3(h, s, v);
});
mx_hsvtorgb.setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
});
mx_rgbtohsv.setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
});

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_transform_color.js
var mx_srgb_texture_to_lin_rec709 = tslFn(([color_immutable]) => {
  const color2 = vec3(color_immutable).toVar();
  const isAbove = bvec3(greaterThan(color2, vec3(0.04045))).toVar();
  const linSeg = vec3(color2.div(12.92)).toVar();
  const powSeg = vec3(pow(max(color2.add(vec3(0.055)), vec3(0)).div(1.055), vec3(2.4))).toVar();
  return mix(linSeg, powSeg, isAbove);
});
mx_srgb_texture_to_lin_rec709.setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});

// node_modules/three/examples/jsm/renderers/common/RenderList.js
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
var RenderList = class {
  constructor() {
    this.renderItems = [];
    this.renderItemsIndex = 0;
    this.opaque = [];
    this.transparent = [];
    this.bundles = [];
    this.lightsNode = new LightsNode_default([]);
    this.lightsArray = [];
    this.occlusionQueryCount = 0;
  }
  begin() {
    this.renderItemsIndex = 0;
    this.opaque.length = 0;
    this.transparent.length = 0;
    this.bundles.length = 0;
    this.lightsArray.length = 0;
    this.occlusionQueryCount = 0;
    return this;
  }
  getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = this.renderItems[this.renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      this.renderItems[this.renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    this.renderItemsIndex++;
    return renderItem;
  }
  push(object, geometry, material, groupOrder, z, group) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (object.occlusionTest === true) this.occlusionQueryCount++;
    (material.transparent === true || material.transmission > 0 ? this.transparent : this.opaque).push(renderItem);
  }
  unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? this.transparent : this.opaque).unshift(renderItem);
  }
  pushBundle(group) {
    this.bundles.push(group);
  }
  pushLight(light) {
    this.lightsArray.push(light);
  }
  getLightsNode() {
    return this.lightsNode.fromLights(this.lightsArray);
  }
  sort(customOpaqueSort, customTransparentSort) {
    if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
    if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  finish() {
    this.lightsNode.fromLights(this.lightsArray);
    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
      const renderItem = this.renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.groupOrder = null;
      renderItem.renderOrder = null;
      renderItem.z = null;
      renderItem.group = null;
    }
  }
};
var RenderList_default = RenderList;

// node_modules/three/examples/jsm/renderers/common/RenderLists.js
var RenderLists = class {
  constructor() {
    this.lists = new ChainMap();
  }
  get(scene, camera) {
    const lists = this.lists;
    const keys = [scene, camera];
    let list = lists.get(keys);
    if (list === void 0) {
      list = new RenderList_default();
      lists.set(keys, list);
    }
    return list;
  }
  dispose() {
    this.lists = new ChainMap();
  }
};
var RenderLists_default = RenderLists;

// node_modules/three/examples/jsm/renderers/common/RenderContext.js
var id3 = 0;
var RenderContext = class {
  constructor() {
    this.id = id3++;
    this.color = true;
    this.clearColor = true;
    this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };
    this.depth = true;
    this.clearDepth = true;
    this.clearDepthValue = 1;
    this.stencil = false;
    this.clearStencil = true;
    this.clearStencilValue = 1;
    this.viewport = false;
    this.viewportValue = new Vector4();
    this.scissor = false;
    this.scissorValue = new Vector4();
    this.textures = null;
    this.depthTexture = null;
    this.activeCubeFace = 0;
    this.sampleCount = 1;
    this.width = 0;
    this.height = 0;
    this.isRenderContext = true;
  }
};
var RenderContext_default = RenderContext;

// node_modules/three/examples/jsm/renderers/common/RenderContexts.js
var RenderContexts = class {
  constructor() {
    this.chainMaps = {};
  }
  get(scene, camera, renderTarget = null) {
    const chainKey = [scene, camera];
    let attachmentState;
    if (renderTarget === null) {
      attachmentState = "default";
    } else {
      const format = renderTarget.texture.format;
      const count = renderTarget.count;
      attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
    }
    const chainMap = this.getChainMap(attachmentState);
    let renderState = chainMap.get(chainKey);
    if (renderState === void 0) {
      renderState = new RenderContext_default();
      chainMap.set(chainKey, renderState);
    }
    if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    return renderState;
  }
  getChainMap(attachmentState) {
    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
  }
  dispose() {
    this.chainMaps = {};
  }
};
var RenderContexts_default = RenderContexts;

// node_modules/three/examples/jsm/renderers/common/Textures.js
var _size5 = new Vector3();
var Textures = class extends DataMap_default {
  constructor(renderer, backend, info) {
    super();
    this.renderer = renderer;
    this.backend = backend;
    this.info = info;
  }
  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
    const renderTargetData = this.get(renderTarget);
    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
    const texture2 = renderTarget.texture;
    const textures = renderTarget.textures;
    const size = this.getSize(texture2);
    const mipWidth = size.width >> activeMipmapLevel;
    const mipHeight = size.height >> activeMipmapLevel;
    let depthTexture2 = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
    let textureNeedsUpdate = false;
    if (depthTexture2 === void 0) {
      depthTexture2 = new DepthTexture();
      depthTexture2.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
      depthTexture2.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType;
      depthTexture2.image.width = mipWidth;
      depthTexture2.image.height = mipHeight;
      depthTextureMips[activeMipmapLevel] = depthTexture2;
    }
    if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {
      textureNeedsUpdate = true;
      depthTexture2.needsUpdate = true;
      depthTexture2.image.width = mipWidth;
      depthTexture2.image.height = mipHeight;
    }
    renderTargetData.width = size.width;
    renderTargetData.height = size.height;
    renderTargetData.textures = textures;
    renderTargetData.depthTexture = depthTexture2;
    renderTargetData.depth = renderTarget.depthBuffer;
    renderTargetData.stencil = renderTarget.stencilBuffer;
    renderTargetData.renderTarget = renderTarget;
    if (renderTargetData.sampleCount !== sampleCount) {
      textureNeedsUpdate = true;
      depthTexture2.needsUpdate = true;
      renderTargetData.sampleCount = sampleCount;
    }
    const options = { sampleCount };
    for (let i = 0; i < textures.length; i++) {
      const texture3 = textures[i];
      if (textureNeedsUpdate) texture3.needsUpdate = true;
      this.updateTexture(texture3, options);
    }
    this.updateTexture(depthTexture2, options);
    if (renderTargetData.initialized !== true) {
      renderTargetData.initialized = true;
      const onDispose = () => {
        renderTarget.removeEventListener("dispose", onDispose);
        if (textures !== void 0) {
          for (let i = 0; i < textures.length; i++) {
            this._destroyTexture(textures[i]);
          }
        } else {
          this._destroyTexture(texture2);
        }
        this._destroyTexture(depthTexture2);
      };
      renderTarget.addEventListener("dispose", onDispose);
    }
  }
  updateTexture(texture2, options = {}) {
    const textureData = this.get(texture2);
    if (textureData.initialized === true && textureData.version === texture2.version) return;
    const isRenderTarget = texture2.isRenderTargetTexture || texture2.isDepthTexture || texture2.isFramebufferTexture;
    const backend = this.backend;
    if (isRenderTarget && textureData.initialized === true) {
      backend.destroySampler(texture2);
      backend.destroyTexture(texture2);
    }
    if (texture2.isFramebufferTexture) {
      const renderer = this.renderer;
      const renderTarget = renderer.getRenderTarget();
      if (renderTarget) {
        texture2.type = renderTarget.texture.type;
      } else {
        texture2.type = UnsignedByteType;
      }
    }
    const { width, height, depth: depth2 } = this.getSize(texture2);
    options.width = width;
    options.height = height;
    options.depth = depth2;
    options.needsMipmaps = this.needsMipmaps(texture2);
    options.levels = options.needsMipmaps ? this.getMipLevels(texture2, width, height) : 1;
    if (isRenderTarget || texture2.isStorageTexture === true) {
      backend.createSampler(texture2);
      backend.createTexture(texture2, options);
    } else {
      const needsCreate = textureData.initialized !== true;
      if (needsCreate) backend.createSampler(texture2);
      if (texture2.version > 0) {
        const image = texture2.image;
        if (image === void 0) {
          console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
        } else if (image.complete === false) {
          console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
        } else {
          if (texture2.images) {
            const images = [];
            for (const image2 of texture2.images) {
              images.push(image2);
            }
            options.images = images;
          } else {
            options.image = image;
          }
          if (textureData.isDefaultTexture === void 0 || textureData.isDefaultTexture === true) {
            backend.createTexture(texture2, options);
            textureData.isDefaultTexture = false;
          }
          if (texture2.source.dataReady === true) backend.updateTexture(texture2, options);
          if (options.needsMipmaps && texture2.mipmaps.length === 0) backend.generateMipmaps(texture2);
        }
      } else {
        backend.createDefaultTexture(texture2);
        textureData.isDefaultTexture = true;
      }
    }
    if (textureData.initialized !== true) {
      textureData.initialized = true;
      this.info.memory.textures++;
      const onDispose = () => {
        texture2.removeEventListener("dispose", onDispose);
        this._destroyTexture(texture2);
        this.info.memory.textures--;
      };
      texture2.addEventListener("dispose", onDispose);
    }
    textureData.version = texture2.version;
  }
  getSize(texture2, target = _size5) {
    let image = texture2.images ? texture2.images[0] : texture2.image;
    if (image) {
      if (image.image !== void 0) image = image.image;
      target.width = image.width;
      target.height = image.height;
      target.depth = texture2.isCubeTexture ? 6 : image.depth || 1;
    } else {
      target.width = target.height = target.depth = 1;
    }
    return target;
  }
  getMipLevels(texture2, width, height) {
    let mipLevelCount;
    if (texture2.isCompressedTexture) {
      mipLevelCount = texture2.mipmaps.length;
    } else {
      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    return mipLevelCount;
  }
  needsMipmaps(texture2) {
    if (this.isEnvironmentTexture(texture2)) return true;
    return texture2.isCompressedTexture === true || texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter;
  }
  isEnvironmentTexture(texture2) {
    const mapping = texture2.mapping;
    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
  }
  _destroyTexture(texture2) {
    this.backend.destroySampler(texture2);
    this.backend.destroyTexture(texture2);
    this.delete(texture2);
  }
};
var Textures_default = Textures;

// node_modules/three/examples/jsm/renderers/common/Color4.js
var Color4 = class extends Color {
  constructor(r, g, b, a = 1) {
    super(r, g, b);
    this.a = a;
  }
  set(r, g, b, a = 1) {
    this.a = a;
    return super.set(r, g, b);
  }
  copy(color2) {
    if (color2.a !== void 0) this.a = color2.a;
    return super.copy(color2);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
};
var Color4_default = Color4;

// node_modules/three/examples/jsm/renderers/common/Background.js
var _clearColor2 = new Color4_default();
var Background = class extends DataMap_default {
  constructor(renderer, nodes) {
    super();
    this.renderer = renderer;
    this.nodes = nodes;
  }
  update(scene, renderList, renderContext) {
    const renderer = this.renderer;
    const background = this.nodes.getBackgroundNode(scene) || scene.background;
    let forceClear = false;
    if (background === null) {
      renderer._clearColor.getRGB(_clearColor2, LinearSRGBColorSpace);
      _clearColor2.a = renderer._clearColor.a;
    } else if (background.isColor === true) {
      background.getRGB(_clearColor2, LinearSRGBColorSpace);
      _clearColor2.a = 1;
      forceClear = true;
    } else if (background.isNode === true) {
      const sceneData = this.get(scene);
      const backgroundNode = background;
      _clearColor2.copy(renderer._clearColor);
      let backgroundMesh = sceneData.backgroundMesh;
      if (backgroundMesh === void 0) {
        const backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {
          // @TODO: Add Texture2D support using node context
          getUV: () => normalWorld,
          getTextureLevel: () => backgroundBlurriness
        });
        let viewProj = modelViewProjection();
        viewProj = viewProj.setZ(viewProj.w);
        const nodeMaterial = new NodeMaterial_default();
        nodeMaterial.side = BackSide;
        nodeMaterial.depthTest = false;
        nodeMaterial.depthWrite = false;
        nodeMaterial.fog = false;
        nodeMaterial.vertexNode = viewProj;
        nodeMaterial.fragmentNode = backgroundMeshNode;
        sceneData.backgroundMeshNode = backgroundMeshNode;
        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);
        backgroundMesh.frustumCulled = false;
        backgroundMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
      }
      const backgroundCacheKey = backgroundNode.getCacheKey();
      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
        sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);
        backgroundMesh.material.needsUpdate = true;
        sceneData.backgroundCacheKey = backgroundCacheKey;
      }
      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null);
    } else {
      console.error("THREE.Renderer: Unsupported background configuration.", background);
    }
    if (renderer.autoClear === true || forceClear === true) {
      _clearColor2.multiplyScalar(_clearColor2.a);
      const clearColorValue = renderContext.clearColorValue;
      clearColorValue.r = _clearColor2.r;
      clearColorValue.g = _clearColor2.g;
      clearColorValue.b = _clearColor2.b;
      clearColorValue.a = _clearColor2.a;
      renderContext.depthClearValue = renderer._clearDepth;
      renderContext.stencilClearValue = renderer._clearStencil;
      renderContext.clearColor = renderer.autoClearColor === true;
      renderContext.clearDepth = renderer.autoClearDepth === true;
      renderContext.clearStencil = renderer.autoClearStencil === true;
    } else {
      renderContext.clearColor = false;
      renderContext.clearDepth = false;
      renderContext.clearStencil = false;
    }
  }
};
var Background_default = Background;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeBuilderState.js
var NodeBuilderState = class {
  constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, transforms = []) {
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.computeShader = computeShader;
    this.transforms = transforms;
    this.nodeAttributes = nodeAttributes;
    this.bindings = bindings;
    this.updateNodes = updateNodes;
    this.updateBeforeNodes = updateBeforeNodes;
    this.usedTimes = 0;
  }
  createBindings() {
    const bindingsArray = [];
    for (const instanceBinding of this.bindings) {
      let binding = instanceBinding;
      if (instanceBinding.shared !== true) {
        binding = instanceBinding.clone();
      }
      bindingsArray.push(binding);
    }
    return bindingsArray;
  }
};
var NodeBuilderState_default = NodeBuilderState;

// node_modules/three/examples/jsm/renderers/common/nodes/Nodes.js
var Nodes = class extends DataMap_default {
  constructor(renderer, backend) {
    super();
    this.renderer = renderer;
    this.backend = backend;
    this.nodeFrame = new NodeFrame_default();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.callHashCache = new ChainMap();
    this.groupsData = new ChainMap();
  }
  updateGroup(nodeUniformsGroup) {
    const groupNode = nodeUniformsGroup.groupNode;
    const name = groupNode.name;
    if (name === objectGroup.name) return true;
    if (name === renderGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const renderId = this.nodeFrame.renderId;
      if (uniformsGroupData.renderId !== renderId) {
        uniformsGroupData.renderId = renderId;
        return true;
      }
      return false;
    }
    if (name === frameGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const frameId2 = this.nodeFrame.frameId;
      if (uniformsGroupData.frameId !== frameId2) {
        uniformsGroupData.frameId = frameId2;
        return true;
      }
      return false;
    }
    const groupChain = [groupNode, nodeUniformsGroup];
    let groupData = this.groupsData.get(groupChain);
    if (groupData === void 0) this.groupsData.set(groupChain, groupData = {});
    if (groupData.version !== groupNode.version) {
      groupData.version = groupNode.version;
      return true;
    }
    return false;
  }
  getForRenderCacheKey(renderObject) {
    return renderObject.initialCacheKey;
  }
  getForRender(renderObject) {
    const renderObjectData = this.get(renderObject);
    let nodeBuilderState = renderObjectData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const { nodeBuilderCache } = this;
      const cacheKey = this.getForRenderCacheKey(renderObject);
      nodeBuilderState = nodeBuilderCache.get(cacheKey);
      if (nodeBuilderState === void 0) {
        const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer, renderObject.scene);
        nodeBuilder.material = renderObject.material;
        nodeBuilder.context.material = renderObject.material;
        nodeBuilder.lightsNode = renderObject.lightsNode;
        nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);
        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
        nodeBuilder.clippingContext = renderObject.clippingContext;
        nodeBuilder.build();
        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
        nodeBuilderCache.set(cacheKey, nodeBuilderState);
      }
      nodeBuilderState.usedTimes++;
      renderObjectData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  delete(object) {
    if (object.isRenderObject) {
      const nodeBuilderState = this.get(object).nodeBuilderState;
      nodeBuilderState.usedTimes--;
      if (nodeBuilderState.usedTimes === 0) {
        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
      }
    }
    return super.delete(object);
  }
  getForCompute(computeNode) {
    const computeData = this.get(computeNode);
    let nodeBuilderState = computeData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
      nodeBuilder.build();
      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
      computeData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  _createNodeBuilderState(nodeBuilder) {
    return new NodeBuilderState_default(
      nodeBuilder.vertexShader,
      nodeBuilder.fragmentShader,
      nodeBuilder.computeShader,
      nodeBuilder.getAttributesArray(),
      nodeBuilder.getBindings(),
      nodeBuilder.updateNodes,
      nodeBuilder.updateBeforeNodes,
      nodeBuilder.transforms
    );
  }
  getEnvironmentNode(scene) {
    return scene.environmentNode || this.get(scene).environmentNode || null;
  }
  getBackgroundNode(scene) {
    return scene.backgroundNode || this.get(scene).backgroundNode || null;
  }
  getFogNode(scene) {
    return scene.fogNode || this.get(scene).fogNode || null;
  }
  getCacheKey(scene, lightsNode2) {
    const chain = [scene, lightsNode2];
    const callId = this.renderer.info.calls;
    let cacheKeyData = this.callHashCache.get(chain);
    if (cacheKeyData === void 0 || cacheKeyData.callId !== callId) {
      const environmentNode = this.getEnvironmentNode(scene);
      const fogNode = this.getFogNode(scene);
      const cacheKey = [];
      if (lightsNode2) cacheKey.push(lightsNode2.getCacheKey());
      if (environmentNode) cacheKey.push(environmentNode.getCacheKey());
      if (fogNode) cacheKey.push(fogNode.getCacheKey());
      cacheKeyData = {
        callId,
        cacheKey: cacheKey.join(",")
      };
      this.callHashCache.set(chain, cacheKeyData);
    }
    return cacheKeyData.cacheKey;
  }
  updateScene(scene) {
    this.updateEnvironment(scene);
    this.updateFog(scene);
    this.updateBackground(scene);
  }
  get isToneMappingState() {
    return this.renderer.getRenderTarget() ? false : true;
  }
  updateBackground(scene) {
    const sceneData = this.get(scene);
    const background = scene.background;
    if (background) {
      if (sceneData.background !== background) {
        let backgroundNode = null;
        if (background.isCubeTexture === true || (background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping)) {
          backgroundNode = pmremTexture(background, normalWorld);
        } else if (background.isTexture === true) {
          backgroundNode = texture(background, viewportBottomLeft).setUpdateMatrix(true);
        } else if (background.isColor !== true) {
          console.error("WebGPUNodes: Unsupported background configuration.", background);
        }
        sceneData.backgroundNode = backgroundNode;
        sceneData.background = background;
      }
    } else if (sceneData.backgroundNode) {
      delete sceneData.backgroundNode;
      delete sceneData.background;
    }
  }
  updateFog(scene) {
    const sceneData = this.get(scene);
    const fog2 = scene.fog;
    if (fog2) {
      if (sceneData.fog !== fog2) {
        let fogNode = null;
        if (fog2.isFogExp2) {
          fogNode = densityFog(reference("color", "color", fog2), reference("density", "float", fog2));
        } else if (fog2.isFog) {
          fogNode = rangeFog(reference("color", "color", fog2), reference("near", "float", fog2), reference("far", "float", fog2));
        } else {
          console.error("WebGPUNodes: Unsupported fog configuration.", fog2);
        }
        sceneData.fogNode = fogNode;
        sceneData.fog = fog2;
      }
    } else {
      delete sceneData.fogNode;
      delete sceneData.fog;
    }
  }
  updateEnvironment(scene) {
    const sceneData = this.get(scene);
    const environment = scene.environment;
    if (environment) {
      if (sceneData.environment !== environment) {
        let environmentNode = null;
        if (environment.isCubeTexture === true) {
          environmentNode = cubeTexture(environment);
        } else if (environment.isTexture === true) {
          environmentNode = texture(environment);
        } else {
          console.error("Nodes: Unsupported environment configuration.", environment);
        }
        sceneData.environmentNode = environmentNode;
        sceneData.environment = environment;
      }
    } else if (sceneData.environmentNode) {
      delete sceneData.environmentNode;
      delete sceneData.environment;
    }
  }
  getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
    const nodeFrame = this.nodeFrame;
    nodeFrame.renderer = renderer;
    nodeFrame.scene = scene;
    nodeFrame.object = object;
    nodeFrame.camera = camera;
    nodeFrame.material = material;
    return nodeFrame;
  }
  getNodeFrameForRender(renderObject) {
    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
  }
  getOutputNode(outputTexture) {
    let output2 = texture(outputTexture, viewportTopLeft);
    if (this.isToneMappingState) {
      if (this.renderer.toneMappingNode) {
        output2 = vec4(this.renderer.toneMappingNode.context({ color: output2.rgb }), output2.a);
      } else if (this.renderer.toneMapping !== NoToneMapping) {
        output2 = output2.toneMapping(this.renderer.toneMapping);
      }
    }
    if (this.renderer.currentColorSpace === SRGBColorSpace) {
      output2 = output2.linearToColorSpace(this.renderer.currentColorSpace);
    }
    return output2;
  }
  updateBefore(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateBeforeNodes) {
      nodeFrame.updateBeforeNode(node);
    }
  }
  updateForCompute(computeNode) {
    const nodeFrame = this.getNodeFrame();
    const nodeBuilder = this.getForCompute(computeNode);
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  updateForRender(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  dispose() {
    super.dispose();
    this.nodeFrame = new NodeFrame_default();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
  }
};
var Nodes_default = Nodes;

// node_modules/three/examples/jsm/renderers/common/RenderBundle.js
var RenderBundle = class {
  constructor(scene, camera) {
    this.scene = scene;
    this.camera = camera;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
};
var RenderBundle_default = RenderBundle;

// node_modules/three/examples/jsm/renderers/common/RenderBundles.js
var RenderBundles = class {
  constructor() {
    this.lists = new ChainMap();
  }
  get(scene, camera) {
    const lists = this.lists;
    const keys = [scene, camera];
    let list = lists.get(keys);
    if (list === void 0) {
      list = new RenderBundle_default(scene, camera);
      lists.set(keys, list);
    }
    return list;
  }
  dispose() {
    this.lists = new ChainMap();
  }
};
var RenderBundles_default = RenderBundles;

// node_modules/three/examples/jsm/renderers/common/Renderer.js
var _scene = new Scene();
var _drawingBufferSize = new Vector2();
var _screen = new Vector4();
var _frustum = new Frustum();
var _projScreenMatrix = new Matrix4();
var _vector3 = new Vector3();
var _quad = new QuadMesh_default(new NodeMaterial_default());
var Renderer = class {
  constructor(backend, parameters = {}) {
    this.isRenderer = true;
    const {
      logarithmicDepthBuffer = false,
      alpha = true
    } = parameters;
    this.domElement = backend.getDomElement();
    this.backend = backend;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.alpha = alpha;
    this.logarithmicDepthBuffer = logarithmicDepthBuffer;
    this.outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.sortObjects = true;
    this.depth = true;
    this.stencil = false;
    this.clippingPlanes = [];
    this.info = new Info_default();
    this.toneMappingNode = null;
    this._pixelRatio = 1;
    this._width = this.domElement.width;
    this._height = this.domElement.height;
    this._viewport = new Vector4(0, 0, this._width, this._height);
    this._scissor = new Vector4(0, 0, this._width, this._height);
    this._scissorTest = false;
    this._attributes = null;
    this._geometries = null;
    this._nodes = null;
    this._animation = null;
    this._bindings = null;
    this._objects = null;
    this._pipelines = null;
    this._bundles = null;
    this._renderLists = null;
    this._renderContexts = null;
    this._textures = null;
    this._background = null;
    this._currentRenderContext = null;
    this._opaqueSort = null;
    this._transparentSort = null;
    this._frameBufferTarget = null;
    const alphaClear = this.alpha === true ? 0 : 1;
    this._clearColor = new Color4_default(0, 0, 0, alphaClear);
    this._clearDepth = 1;
    this._clearStencil = 0;
    this._renderTarget = null;
    this._activeCubeFace = 0;
    this._activeMipmapLevel = 0;
    this._renderObjectFunction = null;
    this._currentRenderObjectFunction = null;
    this._currentRenderBundle = null;
    this._handleObjectFunction = this._renderObjectDirect;
    this._initialized = false;
    this._initPromise = null;
    this._compilationPromises = null;
    this.shadowMap = {
      enabled: false,
      type: null
    };
    this.xr = {
      enabled: false
    };
  }
  async init() {
    if (this._initialized) {
      throw new Error("Renderer: Backend has already been initialized.");
    }
    if (this._initPromise !== null) {
      return this._initPromise;
    }
    this._initPromise = new Promise(async (resolve, reject) => {
      const backend = this.backend;
      try {
        await backend.init(this);
      } catch (error) {
        reject(error);
        return;
      }
      this._nodes = new Nodes_default(this, backend);
      this._animation = new Animation_default(this._nodes, this.info);
      this._attributes = new Attributes_default(backend);
      this._background = new Background_default(this, this._nodes);
      this._geometries = new Geometries_default(this._attributes, this.info);
      this._textures = new Textures_default(this, backend, this.info);
      this._pipelines = new Pipelines_default(backend, this._nodes);
      this._bindings = new Bindings_default(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);
      this._objects = new RenderObjects_default(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);
      this._renderLists = new RenderLists_default();
      this._bundles = new RenderBundles_default();
      this._renderContexts = new RenderContexts_default();
      this._initialized = true;
      resolve();
    });
    return this._initPromise;
  }
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  async compileAsync(scene, camera, targetScene = null) {
    if (this._initialized === false) await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const previousCompilationPromises = this._compilationPromises;
    const sceneRef = scene.isScene === true ? scene : _scene;
    if (targetScene === null) targetScene = scene;
    const renderTarget = this._renderTarget;
    const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
    const activeMipmapLevel = this._activeMipmapLevel;
    const compilationPromises = [];
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this.renderObject;
    this._handleObjectFunction = this._createObjectPipeline;
    this._compilationPromises = compilationPromises;
    nodeFrame.renderId++;
    nodeFrame.update();
    renderContext.depth = this.depth;
    renderContext.stencil = this.stencil;
    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext_default();
    renderContext.clippingContext.updateGlobal(this, camera);
    sceneRef.onBeforeRender(this, scene, camera, renderTarget);
    const renderList = this._renderLists.get(scene, camera);
    renderList.begin();
    this._projectObject(scene, camera, 0, renderList);
    if (targetScene !== scene) {
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          renderList.pushLight(object);
        }
      });
    }
    renderList.finish();
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
    }
    this._nodes.updateScene(sceneRef);
    this._background.update(sceneRef, renderList, renderContext);
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const lightsNode2 = renderList.lightsNode;
    if (opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode2);
    if (transparentObjects.length > 0) this._renderObjects(transparentObjects, camera, sceneRef, lightsNode2);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    this._compilationPromises = previousCompilationPromises;
    this._handleObjectFunction = this._renderObjectDirect;
    await Promise.all(compilationPromises);
  }
  async renderAsync(scene, camera) {
    if (this._initialized === false) await this.init();
    const renderContext = this._renderScene(scene, camera);
    await this.backend.resolveTimestampAsync(renderContext, "render");
  }
  _renderBundle(bundle, sceneRef, lightsNode2) {
    const { object, camera, renderList } = bundle;
    const renderContext = this._currentRenderContext;
    const renderContextData = this.backend.get(renderContext);
    const renderBundle = this._bundles.get(object, camera);
    const renderBundleData = this.backend.get(renderBundle);
    if (renderBundleData.renderContexts === void 0) renderBundleData.renderContexts = /* @__PURE__ */ new Set();
    const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || object.needsUpdate === true;
    renderBundleData.renderContexts.add(renderContext);
    if (renderBundleNeedsUpdate) {
      if (renderContextData.renderObjects === void 0 || object.needsUpdate === true) {
        const nodeFrame = this._nodes.nodeFrame;
        renderContextData.renderObjects = [];
        renderContextData.renderBundles = [];
        renderContextData.scene = sceneRef;
        renderContextData.camera = camera;
        renderContextData.renderId = nodeFrame.renderId;
        renderContextData.registerBundlesPhase = true;
      }
      this._currentRenderBundle = renderBundle;
      const opaqueObjects = renderList.opaque;
      if (opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode2);
      this._currentRenderBundle = null;
      object.needsUpdate = false;
    } else {
      const renderContext2 = this._currentRenderContext;
      const renderContextData2 = this.backend.get(renderContext2);
      for (let i = 0, l = renderContextData2.renderObjects.length; i < l; i++) {
        const renderObject = renderContextData2.renderObjects[i];
        this._nodes.updateBefore(renderObject);
        renderObject.object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, renderObject.object.matrixWorld);
        renderObject.object.normalMatrix.getNormalMatrix(renderObject.object.modelViewMatrix);
        this._nodes.updateForRender(renderObject);
        this._bindings.updateForRender(renderObject);
        this.backend.draw(renderObject, this.info);
      }
    }
  }
  render(scene, camera) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.");
      return this.renderAsync(scene, camera);
    }
    this._renderScene(scene, camera);
  }
  _getFrameBufferTarget() {
    const { currentColorSpace } = this;
    const useToneMapping = this._renderTarget === null && (this.toneMapping !== NoToneMapping || this.toneMappingNode !== null);
    const useColorSpace = currentColorSpace !== LinearSRGBColorSpace && currentColorSpace !== NoColorSpace;
    if (useToneMapping === false && useColorSpace === false) return null;
    const { width, height } = this.getDrawingBufferSize(_drawingBufferSize);
    const { depth: depth2, stencil } = this;
    let frameBufferTarget = this._frameBufferTarget;
    if (frameBufferTarget === null) {
      frameBufferTarget = new RenderTarget(width, height, {
        depthBuffer: depth2,
        stencilBuffer: stencil,
        type: HalfFloatType,
        // FloatType
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        generateMipmaps: false,
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        samples: this.backend.parameters.antialias ? 4 : 0
      });
      frameBufferTarget.isPostProcessingRenderTarget = true;
      this._frameBufferTarget = frameBufferTarget;
    }
    frameBufferTarget.depthBuffer = depth2;
    frameBufferTarget.stencilBuffer = stencil;
    frameBufferTarget.setSize(width, height);
    frameBufferTarget.viewport.copy(this._viewport);
    frameBufferTarget.scissor.copy(this._scissor);
    frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);
    frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);
    frameBufferTarget.scissorTest = this._scissorTest;
    return frameBufferTarget;
  }
  _renderScene(scene, camera, useFrameBufferTarget = true) {
    const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const sceneRef = scene.isScene === true ? scene : _scene;
    const outputRenderTarget = this._renderTarget;
    const activeCubeFace = this._activeCubeFace;
    const activeMipmapLevel = this._activeMipmapLevel;
    let renderTarget;
    if (frameBufferTarget !== null) {
      renderTarget = frameBufferTarget;
      this.setRenderTarget(renderTarget);
    } else {
      renderTarget = outputRenderTarget;
    }
    const renderContext = this._renderContexts.get(scene, camera, renderTarget);
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
    this.info.calls++;
    this.info.render.calls++;
    nodeFrame.renderId = this.info.calls;
    const coordinateSystem = this.coordinateSystem;
    if (camera.coordinateSystem !== coordinateSystem) {
      camera.coordinateSystem = coordinateSystem;
      camera.updateProjectionMatrix();
    }
    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
    let viewport2 = this._viewport;
    let scissor = this._scissor;
    let pixelRatio = this._pixelRatio;
    if (renderTarget !== null) {
      viewport2 = renderTarget.viewport;
      scissor = renderTarget.scissor;
      pixelRatio = 1;
    }
    this.getDrawingBufferSize(_drawingBufferSize);
    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
    const minDepth = viewport2.minDepth === void 0 ? 0 : viewport2.minDepth;
    const maxDepth = viewport2.maxDepth === void 0 ? 1 : viewport2.maxDepth;
    renderContext.viewportValue.copy(viewport2).multiplyScalar(pixelRatio).floor();
    renderContext.viewportValue.width >>= activeMipmapLevel;
    renderContext.viewportValue.height >>= activeMipmapLevel;
    renderContext.viewportValue.minDepth = minDepth;
    renderContext.viewportValue.maxDepth = maxDepth;
    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;
    renderContext.scissorValue.width >>= activeMipmapLevel;
    renderContext.scissorValue.height >>= activeMipmapLevel;
    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext_default();
    renderContext.clippingContext.updateGlobal(this, camera);
    sceneRef.onBeforeRender(this, scene, camera, renderTarget);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
    const renderList = this._renderLists.get(scene, camera);
    renderList.begin();
    this._projectObject(scene, camera, 0, renderList);
    renderList.finish();
    if (this.sortObjects === true) {
      renderList.sort(this._opaqueSort, this._transparentSort);
    }
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
      renderContext.width = this.domElement.width;
      renderContext.height = this.domElement.height;
      renderContext.depth = this.depth;
      renderContext.stencil = this.stencil;
    }
    renderContext.width >>= activeMipmapLevel;
    renderContext.height >>= activeMipmapLevel;
    renderContext.activeCubeFace = activeCubeFace;
    renderContext.activeMipmapLevel = activeMipmapLevel;
    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
    this._nodes.updateScene(sceneRef);
    this._background.update(sceneRef, renderList, renderContext);
    this.backend.beginRender(renderContext);
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const bundles = renderList.bundles;
    const lightsNode2 = renderList.lightsNode;
    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode2);
    if (opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode2);
    if (transparentObjects.length > 0) this._renderObjects(transparentObjects, camera, sceneRef, lightsNode2);
    this.backend.finishRender(renderContext);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    if (frameBufferTarget !== null) {
      this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
      _quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
      this._renderScene(_quad, _quad.camera, false);
    }
    sceneRef.onAfterRender(this, scene, camera, renderTarget);
    return renderContext;
  }
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  async setAnimationLoop(callback) {
    if (this._initialized === false) await this.init();
    this._animation.setAnimationLoop(callback);
  }
  async getArrayBufferAsync(attribute2) {
    return await this.backend.getArrayBufferAsync(attribute2);
  }
  getContext() {
    return this.backend.getContext();
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(target) {
    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(target) {
    return target.set(this._width, this._height);
  }
  setPixelRatio(value = 1) {
    this._pixelRatio = value;
    this.setSize(this._width, this._height, false);
  }
  setDrawingBufferSize(width, height, pixelRatio) {
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this.domElement.width = Math.floor(width * pixelRatio);
    this.domElement.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
    if (this._initialized) this.backend.updateSize();
  }
  setSize(width, height, updateStyle = true) {
    this._width = width;
    this._height = height;
    this.domElement.width = Math.floor(width * this._pixelRatio);
    this.domElement.height = Math.floor(height * this._pixelRatio);
    if (updateStyle === true) {
      this.domElement.style.width = width + "px";
      this.domElement.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
    if (this._initialized) this.backend.updateSize();
  }
  setOpaqueSort(method) {
    this._opaqueSort = method;
  }
  setTransparentSort(method) {
    this._transparentSort = method;
  }
  getScissor(target) {
    const scissor = this._scissor;
    target.x = scissor.x;
    target.y = scissor.y;
    target.width = scissor.width;
    target.height = scissor.height;
    return target;
  }
  setScissor(x, y, width, height) {
    const scissor = this._scissor;
    if (x.isVector4) {
      scissor.copy(x);
    } else {
      scissor.set(x, y, width, height);
    }
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(boolean) {
    this._scissorTest = boolean;
    this.backend.setScissorTest(boolean);
  }
  getViewport(target) {
    return target.copy(this._viewport);
  }
  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
    const viewport2 = this._viewport;
    if (x.isVector4) {
      viewport2.copy(x);
    } else {
      viewport2.set(x, y, width, height);
    }
    viewport2.minDepth = minDepth;
    viewport2.maxDepth = maxDepth;
  }
  getClearColor(target) {
    return target.copy(this._clearColor);
  }
  setClearColor(color2, alpha = 1) {
    this._clearColor.set(color2);
    this._clearColor.a = alpha;
  }
  getClearAlpha() {
    return this._clearColor.a;
  }
  setClearAlpha(alpha) {
    this._clearColor.a = alpha;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(depth2) {
    this._clearDepth = depth2;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(stencil) {
    this._clearStencil = stencil;
  }
  isOccluded(object) {
    const renderContext = this._currentRenderContext;
    return renderContext && this.backend.isOccluded(renderContext, object);
  }
  clear(color2 = true, depth2 = true, stencil = true) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.");
      return this.clearAsync(color2, depth2, stencil);
    }
    const renderTarget = this._renderTarget || this._getFrameBufferTarget();
    let renderTargetData = null;
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget);
      renderTargetData = this._textures.get(renderTarget);
    }
    this.backend.clear(color2, depth2, stencil, renderTargetData);
    if (renderTarget !== null && this._renderTarget === null) {
      _quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
      this._renderScene(_quad, _quad.camera, false);
    }
  }
  clearColor() {
    return this.clear(true, false, false);
  }
  clearDepth() {
    return this.clear(false, true, false);
  }
  clearStencil() {
    return this.clear(false, false, true);
  }
  async clearAsync(color2 = true, depth2 = true, stencil = true) {
    if (this._initialized === false) await this.init();
    this.clear(color2, depth2, stencil);
  }
  clearColorAsync() {
    return this.clearAsync(true, false, false);
  }
  clearDepthAsync() {
    return this.clearAsync(false, true, false);
  }
  clearStencilAsync() {
    return this.clearAsync(false, false, true);
  }
  get currentColorSpace() {
    const renderTarget = this._renderTarget;
    if (renderTarget !== null) {
      const texture2 = renderTarget.texture;
      return (Array.isArray(texture2) ? texture2[0] : texture2).colorSpace;
    }
    return this.outputColorSpace;
  }
  dispose() {
    this.info.dispose();
    this._animation.dispose();
    this._objects.dispose();
    this._pipelines.dispose();
    this._nodes.dispose();
    this._bindings.dispose();
    this._renderLists.dispose();
    this._renderContexts.dispose();
    this._textures.dispose();
    this.setRenderTarget(null);
    this.setAnimationLoop(null);
  }
  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    this._renderTarget = renderTarget;
    this._activeCubeFace = activeCubeFace;
    this._activeMipmapLevel = activeMipmapLevel;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderObjectFunction(renderObjectFunction) {
    this._renderObjectFunction = renderObjectFunction;
  }
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  async computeAsync(computeNodes) {
    if (this._initialized === false) await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    this.info.calls++;
    this.info.compute.calls++;
    this.info.compute.computeCalls++;
    nodeFrame.renderId = this.info.calls;
    const backend = this.backend;
    const pipelines = this._pipelines;
    const bindings = this._bindings;
    const nodes = this._nodes;
    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
    if (computeList[0] === void 0 || computeList[0].isComputeNode !== true) {
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    }
    backend.beginCompute(computeNodes);
    for (const computeNode of computeList) {
      if (pipelines.has(computeNode) === false) {
        const dispose = () => {
          computeNode.removeEventListener("dispose", dispose);
          pipelines.delete(computeNode);
          bindings.delete(computeNode);
          nodes.delete(computeNode);
        };
        computeNode.addEventListener("dispose", dispose);
        computeNode.onInit({ renderer: this });
      }
      nodes.updateForCompute(computeNode);
      bindings.updateForCompute(computeNode);
      const computeBindings = bindings.getForCompute(computeNode);
      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);
      backend.compute(computeNodes, computeNode, computeBindings, computePipeline);
    }
    backend.finishCompute(computeNodes);
    await this.backend.resolveTimestampAsync(computeNodes, "compute");
    nodeFrame.renderId = previousRenderId;
  }
  async hasFeatureAsync(name) {
    if (this._initialized === false) await this.init();
    return this.backend.hasFeature(name);
  }
  hasFeature(name) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.");
      return false;
    }
    return this.backend.hasFeature(name);
  }
  copyFramebufferToTexture(framebufferTexture) {
    const renderContext = this._currentRenderContext;
    this._textures.updateTexture(framebufferTexture);
    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext);
  }
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
    this._textures.updateTexture(srcTexture);
    this._textures.updateTexture(dstTexture);
    this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
  }
  readRenderTargetPixelsAsync(renderTarget, x, y, width, height, index = 0) {
    return this.backend.copyTextureToBuffer(renderTarget.textures[index], x, y, width, height);
  }
  _projectObject(object, camera, groupOrder, renderList) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        renderList.pushLight(object);
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (this.sortObjects === true) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = object.geometry;
          const material = object.material;
          if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isLineLoop) {
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          const geometry = object.geometry;
          const material = object.material;
          if (this.sortObjects === true) {
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _vector3.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                renderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    if (object.static === true) {
      const baseRenderList = renderList;
      renderList = this._renderLists.get(object, camera);
      renderList.begin();
      baseRenderList.pushBundle({
        object,
        camera,
        renderList
      });
      renderList.finish();
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this._projectObject(children[i], camera, groupOrder, renderList);
    }
  }
  _renderBundles(bundles, sceneRef, lightsNode2) {
    for (const bundle of bundles) {
      this._renderBundle(bundle, sceneRef, lightsNode2);
    }
  }
  _renderObjects(renderList, camera, scene, lightsNode2) {
    for (let i = 0, il = renderList.length; i < il; i++) {
      const renderItem = renderList[i];
      const { object, geometry, material, group } = renderItem;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            const vp = camera2.viewport;
            const minDepth = vp.minDepth === void 0 ? 0 : vp.minDepth;
            const maxDepth = vp.maxDepth === void 0 ? 1 : vp.maxDepth;
            const viewportValue = this._currentRenderContext.viewportValue;
            viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();
            viewportValue.minDepth = minDepth;
            viewportValue.maxDepth = maxDepth;
            this.backend.updateViewport(this._currentRenderContext);
            this._currentRenderObjectFunction(object, scene, camera2, geometry, material, group, lightsNode2);
          }
        }
      } else {
        this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode2);
      }
    }
  }
  renderObject(object, scene, camera, geometry, material, group, lightsNode2) {
    let overridePositionNode;
    let overrideFragmentNode;
    let overrideDepthNode;
    object.onBeforeRender(this, scene, camera, geometry, material, group);
    material.onBeforeRender(this, scene, camera, geometry, material, group);
    if (scene.overrideMaterial !== null) {
      const overrideMaterial2 = scene.overrideMaterial;
      if (material.positionNode && material.positionNode.isNode) {
        overridePositionNode = overrideMaterial2.positionNode;
        overrideMaterial2.positionNode = material.positionNode;
      }
      if (overrideMaterial2.isShadowNodeMaterial) {
        overrideMaterial2.side = material.shadowSide === null ? material.side : material.shadowSide;
        if (material.depthNode && material.depthNode.isNode) {
          overrideDepthNode = overrideMaterial2.depthNode;
          overrideMaterial2.depthNode = material.depthNode;
        }
        if (material.shadowNode && material.shadowNode.isNode) {
          overrideFragmentNode = overrideMaterial2.fragmentNode;
          overrideMaterial2.fragmentNode = material.shadowNode;
        }
        if (this.localClippingEnabled) {
          if (material.clipShadows) {
            if (overrideMaterial2.clippingPlanes !== material.clippingPlanes) {
              overrideMaterial2.clippingPlanes = material.clippingPlanes;
              overrideMaterial2.needsUpdate = true;
            }
            if (overrideMaterial2.clipIntersection !== material.clipIntersection) {
              overrideMaterial2.clipIntersection = material.clipIntersection;
            }
          } else if (Array.isArray(overrideMaterial2.clippingPlanes)) {
            overrideMaterial2.clippingPlanes = null;
            overrideMaterial2.needsUpdate = true;
          }
        }
      }
      material = overrideMaterial2;
    }
    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
      material.side = BackSide;
      this._handleObjectFunction(object, material, scene, camera, lightsNode2, group, "backSide");
      material.side = FrontSide;
      this._handleObjectFunction(object, material, scene, camera, lightsNode2, group);
      material.side = DoubleSide;
    } else {
      this._handleObjectFunction(object, material, scene, camera, lightsNode2, group);
    }
    if (overridePositionNode !== void 0) {
      scene.overrideMaterial.positionNode = overridePositionNode;
    }
    if (overrideDepthNode !== void 0) {
      scene.overrideMaterial.depthNode = overrideDepthNode;
    }
    if (overrideFragmentNode !== void 0) {
      scene.overrideMaterial.fragmentNode = overrideFragmentNode;
    }
    object.onAfterRender(this, scene, camera, geometry, material, group);
  }
  _renderObjectDirect(object, material, scene, camera, lightsNode2, group, passId) {
    const renderObject = this._objects.get(object, material, scene, camera, lightsNode2, this._currentRenderContext, passId);
    renderObject.drawRange = group || object.geometry.drawRange;
    this._nodes.updateBefore(renderObject);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    this._nodes.updateForRender(renderObject);
    this._geometries.updateForRender(renderObject);
    this._bindings.updateForRender(renderObject);
    this._pipelines.updateForRender(renderObject);
    if (this._currentRenderBundle !== null && this._currentRenderBundle.needsUpdate === true) {
      const renderObjectData = this.backend.get(renderObject);
      renderObjectData.bundleEncoder = void 0;
      renderObjectData.lastPipelineGPU = void 0;
    }
    this.backend.draw(renderObject, this.info);
    if (this._currentRenderBundle !== null) {
      const renderContextData = this.backend.get(this._currentRenderContext);
      renderContextData.renderObjects.push(renderObject);
    }
  }
  _createObjectPipeline(object, material, scene, camera, lightsNode2, passId) {
    const renderObject = this._objects.get(object, material, scene, camera, lightsNode2, this._currentRenderContext, passId);
    this._nodes.updateBefore(renderObject);
    this._nodes.updateForRender(renderObject);
    this._geometries.updateForRender(renderObject);
    this._bindings.updateForRender(renderObject);
    this._pipelines.getForRender(renderObject, this._compilationPromises);
  }
  get compute() {
    return this.computeAsync;
  }
  get compile() {
    return this.compileAsync;
  }
};
var Renderer_default = Renderer;

// node_modules/three/examples/jsm/renderers/common/Binding.js
var Binding = class {
  constructor(name = "") {
    this.name = name;
    this.visibility = 0;
  }
  setVisibility(visibility) {
    this.visibility |= visibility;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
};
var Binding_default = Binding;

// node_modules/three/examples/jsm/renderers/common/BufferUtils.js
function getFloatLength(floatLength) {
  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;
}

// node_modules/three/examples/jsm/renderers/common/Buffer.js
var Buffer = class extends Binding_default {
  constructor(name, buffer2 = null) {
    super(name);
    this.isBuffer = true;
    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
    this._buffer = buffer2;
  }
  get byteLength() {
    return getFloatLength(this._buffer.byteLength);
  }
  get buffer() {
    return this._buffer;
  }
  update() {
    return true;
  }
};
var Buffer_default = Buffer;

// node_modules/three/examples/jsm/renderers/common/UniformBuffer.js
var UniformBuffer = class extends Buffer_default {
  constructor(name, buffer2 = null) {
    super(name, buffer2);
    this.isUniformBuffer = true;
  }
};
var UniformBuffer_default = UniformBuffer;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniformBuffer.js
var _id2 = 0;
var NodeUniformBuffer = class extends UniformBuffer_default {
  constructor(nodeUniform) {
    super("UniformBuffer_" + _id2++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
};
var NodeUniformBuffer_default = NodeUniformBuffer;

// node_modules/three/examples/jsm/renderers/common/UniformsGroup.js
var UniformsGroup = class extends UniformBuffer_default {
  constructor(name) {
    super(name);
    this.isUniformsGroup = true;
    this.uniforms = [];
  }
  addUniform(uniform2) {
    this.uniforms.push(uniform2);
    return this;
  }
  removeUniform(uniform2) {
    const index = this.uniforms.indexOf(uniform2);
    if (index !== -1) {
      this.uniforms.splice(index, 1);
    }
    return this;
  }
  get buffer() {
    let buffer2 = this._buffer;
    if (buffer2 === null) {
      const byteLength = this.byteLength;
      buffer2 = new Float32Array(new ArrayBuffer(byteLength));
      this._buffer = buffer2;
    }
    return buffer2;
  }
  get byteLength() {
    let offset = 0;
    for (let i = 0, l = this.uniforms.length; i < l; i++) {
      const uniform2 = this.uniforms[i];
      const { boundary, itemSize } = uniform2;
      const chunkOffset = offset % GPU_CHUNK_BYTES;
      const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;
      if (chunkOffset !== 0 && remainingSizeInChunk - boundary < 0) {
        offset += GPU_CHUNK_BYTES - chunkOffset;
      } else if (chunkOffset % boundary !== 0) {
        offset += chunkOffset % boundary;
      }
      uniform2.offset = offset / this.bytesPerElement;
      offset += itemSize * this.bytesPerElement;
    }
    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
  }
  update() {
    let updated = false;
    for (const uniform2 of this.uniforms) {
      if (this.updateByType(uniform2) === true) {
        updated = true;
      }
    }
    return updated;
  }
  updateByType(uniform2) {
    if (uniform2.isFloatUniform) return this.updateNumber(uniform2);
    if (uniform2.isVector2Uniform) return this.updateVector2(uniform2);
    if (uniform2.isVector3Uniform) return this.updateVector3(uniform2);
    if (uniform2.isVector4Uniform) return this.updateVector4(uniform2);
    if (uniform2.isColorUniform) return this.updateColor(uniform2);
    if (uniform2.isMatrix3Uniform) return this.updateMatrix3(uniform2);
    if (uniform2.isMatrix4Uniform) return this.updateMatrix4(uniform2);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", uniform2);
  }
  updateNumber(uniform2) {
    let updated = false;
    const a = this.buffer;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    if (a[offset] !== v) {
      a[offset] = v;
      updated = true;
    }
    return updated;
  }
  updateVector2(uniform2) {
    let updated = false;
    const a = this.buffer;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      updated = true;
    }
    return updated;
  }
  updateVector3(uniform2) {
    let updated = false;
    const a = this.buffer;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      a[offset + 2] = v.z;
      updated = true;
    }
    return updated;
  }
  updateVector4(uniform2) {
    let updated = false;
    const a = this.buffer;
    const v = uniform2.getValue();
    const offset = uniform2.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      a[offset + 2] = v.z;
      a[offset + 3] = v.w;
      updated = true;
    }
    return updated;
  }
  updateColor(uniform2) {
    let updated = false;
    const a = this.buffer;
    const c = uniform2.getValue();
    const offset = uniform2.offset;
    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {
      a[offset + 0] = c.r;
      a[offset + 1] = c.g;
      a[offset + 2] = c.b;
      updated = true;
    }
    return updated;
  }
  updateMatrix3(uniform2) {
    let updated = false;
    const a = this.buffer;
    const e = uniform2.getValue().elements;
    const offset = uniform2.offset;
    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {
      a[offset + 0] = e[0];
      a[offset + 1] = e[1];
      a[offset + 2] = e[2];
      a[offset + 4] = e[3];
      a[offset + 5] = e[4];
      a[offset + 6] = e[5];
      a[offset + 8] = e[6];
      a[offset + 9] = e[7];
      a[offset + 10] = e[8];
      updated = true;
    }
    return updated;
  }
  updateMatrix4(uniform2) {
    let updated = false;
    const a = this.buffer;
    const e = uniform2.getValue().elements;
    const offset = uniform2.offset;
    if (arraysEqual(a, e, offset) === false) {
      a.set(e, offset);
      updated = true;
    }
    return updated;
  }
};
function arraysEqual(a, b, offset) {
  for (let i = 0, l = b.length; i < l; i++) {
    if (a[offset + i] !== b[i]) return false;
  }
  return true;
}
var UniformsGroup_default = UniformsGroup;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniformsGroup.js
var id4 = 0;
var NodeUniformsGroup = class extends UniformsGroup_default {
  constructor(name, groupNode) {
    super(name);
    this.id = id4++;
    this.groupNode = groupNode;
    this.isNodeUniformsGroup = true;
  }
  get shared() {
    return this.groupNode.shared;
  }
  getNodes() {
    const nodes = [];
    for (const uniform2 of this.uniforms) {
      const node = uniform2.nodeUniform.node;
      if (!node) throw new Error("NodeUniformsGroup: Uniform has no node.");
      nodes.push(node);
    }
    return nodes;
  }
};
var NodeUniformsGroup_default = NodeUniformsGroup;

// node_modules/three/examples/jsm/renderers/common/SampledTexture.js
var id5 = 0;
var SampledTexture = class extends Binding_default {
  constructor(name, texture2) {
    super(name);
    this.id = id5++;
    this.texture = texture2;
    this.version = texture2 ? texture2.version : 0;
    this.store = false;
    this.isSampledTexture = true;
  }
  get needsBindingsUpdate() {
    const { texture: texture2, version } = this;
    return texture2.isVideoTexture ? true : version !== texture2.version;
  }
  update() {
    const { texture: texture2, version } = this;
    if (version !== texture2.version) {
      this.version = texture2.version;
      return true;
    }
    return false;
  }
};

// node_modules/three/examples/jsm/renderers/common/nodes/NodeSampledTexture.js
var NodeSampledTexture = class extends SampledTexture {
  constructor(name, textureNode, access = null) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.access = access;
  }
  get needsBindingsUpdate() {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate;
  }
  update() {
    const { textureNode } = this;
    if (this.texture !== textureNode.value) {
      this.texture = textureNode.value;
      return true;
    }
    return super.update();
  }
};
var NodeSampledCubeTexture = class extends NodeSampledTexture {
  constructor(name, textureNode, access) {
    super(name, textureNode, access);
    this.isSampledCubeTexture = true;
  }
};
var NodeSampledTexture3D = class extends NodeSampledTexture {
  constructor(name, textureNode, access) {
    super(name, textureNode, access);
    this.isSampledTexture3D = true;
  }
};

// node_modules/three/examples/jsm/renderers/webgl/nodes/GLSLNodeBuilder.js
var glslMethods = {
  [MathNode_default.ATAN2]: "atan",
  textureDimensions: "textureSize",
  equals: "equal"
};
var precisionLib = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
var supports = {
  instance: true,
  swizzleAssign: true
};
var defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler3D;
precision mediump sampler2DArray;
precision lowp sampler2DShadow;
`;
var GLSLNodeBuilder = class extends NodeBuilder_default {
  constructor(object, renderer, scene = null) {
    super(object, renderer, new GLSLNodeParser_default(), scene);
    this.uniformGroups = {};
    this.transforms = [];
  }
  getMethod(method) {
    return glslMethods[method] || method;
  }
  getPropertyName(node, shaderStage) {
    return super.getPropertyName(node, shaderStage);
  }
  getOutputStructName() {
    return "";
  }
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(this.getType(input.type) + " " + input.name);
    }
    const code2 = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(", ")} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;
    return code2;
  }
  setupPBO(storageBufferNode) {
    const attribute2 = storageBufferNode.value;
    if (attribute2.pbo === void 0) {
      const originalArray = attribute2.array;
      const numElements = attribute2.count * attribute2.itemSize;
      const { itemSize } = attribute2;
      let format = RedFormat;
      if (itemSize === 2) {
        format = RGFormat;
      } else if (itemSize === 3) {
        format = RGBFormat;
      } else if (itemSize === 4) {
        format = RGBAFormat;
      }
      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));
      let height = Math.ceil(numElements / itemSize / width);
      if (width * height * itemSize < numElements) height++;
      const newSize = width * height * itemSize;
      const newArray = new Float32Array(newSize);
      newArray.set(originalArray, 0);
      attribute2.array = newArray;
      const pboTexture = new DataTexture(attribute2.array, width, height, format, FloatType);
      pboTexture.needsUpdate = true;
      pboTexture.isPBOTexture = true;
      const pbo = new UniformNode_default(pboTexture);
      pbo.setPrecision("high");
      attribute2.pboNode = pbo;
      attribute2.pbo = pbo.value;
      this.getUniformFromNode(attribute2.pboNode, "texture", this.shaderStage, this.context.label);
    }
  }
  generatePBO(storageArrayElementNode) {
    const { node, indexNode } = storageArrayElementNode;
    const attribute2 = node.value;
    if (this.renderer.backend.has(attribute2)) {
      const attributeData = this.renderer.backend.get(attribute2);
      attributeData.pbo = attribute2.pbo;
    }
    const nodeUniform = this.getUniformFromNode(attribute2.pboNode, "texture", this.shaderStage, this.context.label);
    const textureName = this.getPropertyName(nodeUniform);
    indexNode.increaseUsage(this);
    const indexSnippet = indexNode.build(this, "uint");
    const elementNodeData = this.getDataFromNode(storageArrayElementNode);
    let propertyName = elementNodeData.propertyName;
    if (propertyName === void 0) {
      const nodeVar = this.getVarFromNode(storageArrayElementNode);
      propertyName = this.getPropertyName(nodeVar);
      const bufferNodeData = this.getDataFromNode(node);
      let propertySizeName = bufferNodeData.propertySizeName;
      if (propertySizeName === void 0) {
        propertySizeName = propertyName + "Size";
        this.getVarFromNode(node, propertySizeName, "uint");
        this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`);
        bufferNodeData.propertySizeName = propertySizeName;
      }
      const { itemSize } = attribute2;
      const channel = "." + vectorComponents.join("").slice(0, itemSize);
      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
      const snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, "0");
      this.addLineFlowCode(`${propertyName} = ${snippet + channel}`);
      elementNodeData.propertyName = propertyName;
    }
    return propertyName;
  }
  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = "0") {
    if (depthSnippet) {
      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
    } else {
      return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
    }
  }
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet) {
    if (texture2.isDepthTexture) {
      return `texture( ${textureProperty}, ${uvSnippet} ).x`;
    } else {
      if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
      return `texture( ${textureProperty}, ${uvSnippet} )`;
    }
  }
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet) {
    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
  }
  generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet) {
    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
  }
  generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
    } else {
      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`${this.getVar(variable.type, variable.name)};`);
      }
    }
    return snippets.join("\n	");
  }
  getUniforms(shaderStage) {
    const uniforms2 = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const uniformGroups = {};
    for (const uniform2 of uniforms2) {
      let snippet = null;
      let group = false;
      if (uniform2.type === "texture") {
        const texture2 = uniform2.node.value;
        if (texture2.compareFunction) {
          snippet = `sampler2DShadow ${uniform2.name};`;
        } else if (texture2.isDataArrayTexture === true) {
          snippet = `sampler2DArray ${uniform2.name};`;
        } else {
          snippet = `sampler2D ${uniform2.name};`;
        }
      } else if (uniform2.type === "cubeTexture") {
        snippet = `samplerCube ${uniform2.name};`;
      } else if (uniform2.type === "texture3D") {
        snippet = `sampler3D ${uniform2.name};`;
      } else if (uniform2.type === "buffer") {
        const bufferNode = uniform2.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? bufferCount : "";
        snippet = `${bufferNode.name} {
	${bufferType} ${uniform2.name}[${bufferCountSnippet}];
};
`;
      } else {
        const vectorType = this.getVectorType(uniform2.type);
        snippet = `${vectorType} ${uniform2.name};`;
        group = true;
      }
      const precision = uniform2.node.precision;
      if (precision !== null) {
        snippet = precisionLib[precision] + " " + snippet;
      }
      if (group) {
        snippet = "	" + snippet;
        const groupName = uniform2.groupNode.name;
        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);
        groupSnippets.push(snippet);
      } else {
        snippet = "uniform " + snippet;
        bindingSnippets.push(snippet);
      }
    }
    let output2 = "";
    for (const name in uniformGroups) {
      const groupSnippets = uniformGroups[name];
      output2 += this._getGLSLUniformStruct(shaderStage + "_" + name, groupSnippets.join("\n")) + "\n";
    }
    output2 += bindingSnippets.join("\n");
    return output2;
  }
  getTypeFromAttribute(attribute2) {
    let nodeType = super.getTypeFromAttribute(attribute2);
    if (/^[iu]/.test(nodeType) && attribute2.gpuType !== IntType) {
      let dataAttribute = attribute2;
      if (attribute2.isInterleavedBufferAttribute) dataAttribute = attribute2.data;
      const array = dataAttribute.array;
      if ((array instanceof Uint32Array || array instanceof Int32Array || array instanceof Uint16Array || array instanceof Int16Array) === false) {
        nodeType = nodeType.slice(1);
      }
    }
    return nodeType;
  }
  getAttributes(shaderStage) {
    let snippet = "";
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const attributes = this.getAttributesArray();
      let location = 0;
      for (const attribute2 of attributes) {
        snippet += `layout( location = ${location++} ) in ${attribute2.type} ${attribute2.name};
`;
      }
    }
    return snippet;
  }
  getStructMembers(struct) {
    const snippets = [];
    const members = struct.getMemberTypes();
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      snippets.push(`layout( location = ${i} ) out ${member} m${i};`);
    }
    return snippets.join("\n");
  }
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    if (structs.length === 0) {
      return "layout( location = 0 ) out vec4 fragColor;\n";
    }
    for (let index = 0, length2 = structs.length; index < length2; index++) {
      const struct = structs[index];
      let snippet = "\n";
      snippet += this.getStructMembers(struct);
      snippet += "\n";
      snippets.push(snippet);
    }
    return snippets.join("\n\n");
  }
  getVaryings(shaderStage) {
    let snippet = "";
    const varyings = this.varyings;
    if (shaderStage === "vertex" || shaderStage === "compute") {
      for (const varying2 of varyings) {
        if (shaderStage === "compute") varying2.needsInterpolation = true;
        const type = varying2.type;
        const flat = type === "int" || type === "uint" ? "flat " : "";
        snippet += `${flat}${varying2.needsInterpolation ? "out" : "/*out*/"} ${type} ${varying2.name};
`;
      }
    } else if (shaderStage === "fragment") {
      for (const varying2 of varyings) {
        if (varying2.needsInterpolation) {
          const type = varying2.type;
          const flat = type === "int" || type === "uint" ? "flat " : "";
          snippet += `${flat}in ${type} ${varying2.name};
`;
        }
      }
    }
    return snippet;
  }
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  getFragDepth() {
    return "gl_FragDepth";
  }
  isAvailable(name) {
    return supports[name] === true;
  }
  isFlipY() {
    return true;
  }
  registerTransform(varyingName, attributeNode) {
    this.transforms.push({ varyingName, attributeNode });
  }
  getTransforms() {
    const transforms = this.transforms;
    let snippet = "";
    for (let i = 0; i < transforms.length; i++) {
      const transform = transforms[i];
      const attributeName = this.getPropertyName(transform.attributeNode);
      snippet += `${transform.varyingName} = ${attributeName};
	`;
    }
    return snippet;
  }
  _getGLSLUniformStruct(name, vars) {
    return `
layout( std140 ) uniform ${name} {
${vars}
};`;
  }
  _getGLSLVertexCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
  }
  _getGLSLFragmentCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    for (const shaderStage in shadersData) {
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0) flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n	";
          if (shaderStage === "vertex") {
            flow += "gl_Position = ";
            flow += `${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (!node.outputNode.isOutputStructNode) {
              flow += "fragColor = ";
              flow += `${flowSlotData.result};`;
            }
          }
        }
      }
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.transforms = this.getTransforms(shaderStage);
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getGLSLVertexCode(shadersData.compute);
    }
  }
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let uniformGPU = nodeData.uniformGPU;
    if (uniformGPU === void 0) {
      if (type === "texture") {
        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node);
        this.bindings[shaderStage].push(uniformGPU);
      } else if (type === "cubeTexture") {
        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node);
        this.bindings[shaderStage].push(uniformGPU);
      } else if (type === "texture3D") {
        uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node);
        this.bindings[shaderStage].push(uniformGPU);
      } else if (type === "buffer") {
        node.name = `NodeBuffer_${node.id}`;
        uniformNode.name = `buffer${node.id}`;
        const buffer2 = new NodeUniformBuffer_default(node);
        buffer2.name = node.name;
        this.bindings[shaderStage].push(buffer2);
        uniformGPU = buffer2;
      } else {
        const group = node.groupNode;
        const groupName = group.name;
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup_default(shaderStage + "_" + groupName, group);
          uniformsStage[groupName] = uniformsGroup;
          this.bindings[shaderStage].push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
};
var GLSLNodeBuilder_default = GLSLNodeBuilder;

// node_modules/three/examples/jsm/renderers/common/Backend.js
var vector2 = null;
var vector4 = null;
var color4 = null;
var Backend = class {
  constructor(parameters = {}) {
    this.parameters = Object.assign({}, parameters);
    this.data = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.domElement = null;
  }
  async init(renderer) {
    this.renderer = renderer;
  }
  // render context
  begin(renderContext) {
  }
  finish(renderContext) {
  }
  // render object
  draw(renderObject, info) {
  }
  // program
  createProgram(program) {
  }
  destroyProgram(program) {
  }
  // bindings
  createBindings(renderObject) {
  }
  updateBindings(renderObject) {
  }
  // pipeline
  createRenderPipeline(renderObject) {
  }
  createComputePipeline(computeNode, pipeline) {
  }
  destroyPipeline(pipeline) {
  }
  // cache key
  needsRenderUpdate(renderObject) {
  }
  // return Boolean ( fast test )
  getRenderCacheKey(renderObject) {
  }
  // return String
  // node builder
  createNodeBuilder(renderObject) {
  }
  // return NodeBuilder (ADD IT)
  // textures
  createSampler(texture2) {
  }
  createDefaultTexture(texture2) {
  }
  createTexture(texture2) {
  }
  copyTextureToBuffer(texture2, x, y, width, height) {
  }
  // attributes
  createAttribute(attribute2) {
  }
  createIndexAttribute(attribute2) {
  }
  updateAttribute(attribute2) {
  }
  destroyAttribute(attribute2) {
  }
  // canvas
  getContext() {
  }
  updateSize() {
  }
  // utils
  resolveTimestampAsync(renderContext, type) {
  }
  hasFeatureAsync(name) {
  }
  // return Boolean
  hasFeature(name) {
  }
  // return Boolean
  getInstanceCount(renderObject) {
    const { object, geometry } = renderObject;
    return geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.isInstancedMesh ? object.count : 1;
  }
  getDrawingBufferSize() {
    vector2 = vector2 || new Vector2();
    return this.renderer.getDrawingBufferSize(vector2);
  }
  getScissor() {
    vector4 = vector4 || new Vector4();
    return this.renderer.getScissor(vector4);
  }
  setScissorTest(boolean) {
  }
  getClearColor() {
    const renderer = this.renderer;
    color4 = color4 || new Color4_default();
    renderer.getClearColor(color4);
    color4.getRGB(color4, this.renderer.currentColorSpace);
    return color4;
  }
  getDomElement() {
    let domElement = this.domElement;
    if (domElement === null) {
      domElement = this.parameters.canvas !== void 0 ? this.parameters.canvas : createCanvasElement();
      if ("setAttribute" in domElement) domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
      this.domElement = domElement;
    }
    return domElement;
  }
  // resource properties
  set(object, value) {
    this.data.set(object, value);
  }
  get(object) {
    let map = this.data.get(object);
    if (map === void 0) {
      map = {};
      this.data.set(object, map);
    }
    return map;
  }
  has(object) {
    return this.data.has(object);
  }
  delete(object) {
    this.data.delete(object);
  }
};
var Backend_default = Backend;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLAttributeUtils.js
var _id3 = 0;
var DualAttributeData = class {
  constructor(attributeData, dualBuffer) {
    this.buffers = [attributeData.bufferGPU, dualBuffer];
    this.type = attributeData.type;
    this.bufferType = attributeData.bufferType;
    this.pbo = attributeData.pbo;
    this.byteLength = attributeData.byteLength;
    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
    this.version = attributeData.version;
    this.isInteger = attributeData.isInteger;
    this.activeBufferIndex = 0;
    this.baseId = attributeData.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
};
var WebGLAttributeUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createAttribute(attribute2, bufferType) {
    const backend = this.backend;
    const { gl } = backend;
    const array = attribute2.array;
    const usage = attribute2.usage || gl.STATIC_DRAW;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
    const bufferData = backend.get(bufferAttribute2);
    let bufferGPU = bufferData.bufferGPU;
    if (bufferGPU === void 0) {
      bufferGPU = this._createBuffer(gl, bufferType, array, usage);
      bufferData.bufferGPU = bufferGPU;
      bufferData.bufferType = bufferType;
      bufferData.version = bufferAttribute2.version;
    }
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute2.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + array);
    }
    let attributeData = {
      bufferGPU,
      bufferType,
      type,
      byteLength: array.byteLength,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute2.version,
      pbo: attribute2.pbo,
      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || type === gl.UNSIGNED_SHORT || attribute2.gpuType === IntType,
      id: _id3++
    };
    if (attribute2.isStorageBufferAttribute || attribute2.isStorageInstancedBufferAttribute) {
      const bufferGPUDual = this._createBuffer(gl, bufferType, array, usage);
      attributeData = new DualAttributeData(attributeData, bufferGPUDual);
    }
    backend.set(attribute2, attributeData);
  }
  updateAttribute(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    const array = attribute2.array;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
    const bufferData = backend.get(bufferAttribute2);
    const bufferType = bufferData.bufferType;
    const updateRanges = attribute2.isInterleavedBufferAttribute ? attribute2.data.updateRanges : attribute2.updateRanges;
    gl.bindBuffer(bufferType, bufferData.bufferGPU);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range2 = updateRanges[i];
        gl.bufferSubData(
          bufferType,
          range2.start * array.BYTES_PER_ELEMENT,
          array,
          range2.start,
          range2.count
        );
      }
      bufferAttribute2.clearUpdateRanges();
    }
    gl.bindBuffer(bufferType, null);
    bufferData.version = bufferAttribute2.version;
  }
  destroyAttribute(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    if (attribute2.isInterleavedBufferAttribute) {
      backend.delete(attribute2.data);
    }
    const attributeData = backend.get(attribute2);
    gl.deleteBuffer(attributeData.bufferGPU);
    backend.delete(attribute2);
  }
  async getArrayBufferAsync(attribute2) {
    const backend = this.backend;
    const { gl } = backend;
    const bufferAttribute2 = attribute2.isInterleavedBufferAttribute ? attribute2.data : attribute2;
    const { bufferGPU } = backend.get(bufferAttribute2);
    const array = attribute2.array;
    const byteLength = array.byteLength;
    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
    const writeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new attribute2.array.constructor(array.length);
    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
    gl.deleteBuffer(writeBuffer);
    return dstBuffer.buffer;
  }
  _createBuffer(gl, bufferType, array, usage) {
    const bufferGPU = gl.createBuffer();
    gl.bindBuffer(bufferType, bufferGPU);
    gl.bufferData(bufferType, array, usage);
    gl.bindBuffer(bufferType, null);
    return bufferGPU;
  }
};
var WebGLAttributeUtils_default = WebGLAttributeUtils;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLState.js
var initialized = false;
var equationToGL;
var factorToGL;
var WebGLState = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.enabled = {};
    this.currentFlipSided = null;
    this.currentCullFace = null;
    this.currentProgram = null;
    this.currentBlendingEnabled = false;
    this.currentBlending = null;
    this.currentBlendSrc = null;
    this.currentBlendDst = null;
    this.currentBlendSrcAlpha = null;
    this.currentBlendDstAlpha = null;
    this.currentPremultipledAlpha = null;
    this.currentPolygonOffsetFactor = null;
    this.currentPolygonOffsetUnits = null;
    this.currentColorMask = null;
    this.currentDepthFunc = null;
    this.currentDepthMask = null;
    this.currentStencilFunc = null;
    this.currentStencilRef = null;
    this.currentStencilFuncMask = null;
    this.currentStencilFail = null;
    this.currentStencilZFail = null;
    this.currentStencilZPass = null;
    this.currentStencilMask = null;
    this.currentLineWidth = null;
    this.currentBoundFramebuffers = {};
    this.currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
    this.currentTextureSlot = null;
    this.currentBoundTextures = {};
    if (initialized === false) {
      this._init(this.gl);
      initialized = true;
    }
  }
  _init(gl) {
    equationToGL = {
      [AddEquation]: gl.FUNC_ADD,
      [SubtractEquation]: gl.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    factorToGL = {
      [ZeroFactor]: gl.ZERO,
      [OneFactor]: gl.ONE,
      [SrcColorFactor]: gl.SRC_COLOR,
      [SrcAlphaFactor]: gl.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl.DST_COLOR,
      [DstAlphaFactor]: gl.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
    };
  }
  enable(id6) {
    const { enabled } = this;
    if (enabled[id6] !== true) {
      this.gl.enable(id6);
      enabled[id6] = true;
    }
  }
  disable(id6) {
    const { enabled } = this;
    if (enabled[id6] !== false) {
      this.gl.disable(id6);
      enabled[id6] = false;
    }
  }
  setFlipSided(flipSided) {
    if (this.currentFlipSided !== flipSided) {
      const { gl } = this;
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      this.currentFlipSided = flipSided;
    }
  }
  setCullFace(cullFace) {
    const { gl } = this;
    if (cullFace !== CullFaceNone) {
      this.enable(gl.CULL_FACE);
      if (cullFace !== this.currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      this.disable(gl.CULL_FACE);
    }
    this.currentCullFace = cullFace;
  }
  setLineWidth(width) {
    const { currentLineWidth, gl } = this;
    if (width !== currentLineWidth) {
      gl.lineWidth(width);
      this.currentLineWidth = width;
    }
  }
  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    const { gl } = this;
    if (blending === NoBlending) {
      if (this.currentBlendingEnabled === true) {
        this.disable(gl.BLEND);
        this.currentBlendingEnabled = false;
      }
      return;
    }
    if (this.currentBlendingEnabled === false) {
      this.enable(gl.BLEND);
      this.currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          this.currentBlendEquation = AddEquation;
          this.currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        this.currentBlendSrc = null;
        this.currentBlendDst = null;
        this.currentBlendSrcAlpha = null;
        this.currentBlendDstAlpha = null;
        this.currentBlending = blending;
        this.currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      this.currentBlendEquation = blendEquation;
      this.currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      this.currentBlendSrc = blendSrc;
      this.currentBlendDst = blendDst;
      this.currentBlendSrcAlpha = blendSrcAlpha;
      this.currentBlendDstAlpha = blendDstAlpha;
    }
    this.currentBlending = blending;
    this.currentPremultipledAlpha = false;
  }
  setColorMask(colorMask) {
    if (this.currentColorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      this.currentColorMask = colorMask;
    }
  }
  setDepthTest(depthTest) {
    const { gl } = this;
    if (depthTest) {
      this.enable(gl.DEPTH_TEST);
    } else {
      this.disable(gl.DEPTH_TEST);
    }
  }
  setDepthMask(depthMask) {
    if (this.currentDepthMask !== depthMask) {
      this.gl.depthMask(depthMask);
      this.currentDepthMask = depthMask;
    }
  }
  setDepthFunc(depthFunc) {
    if (this.currentDepthFunc !== depthFunc) {
      const { gl } = this;
      switch (depthFunc) {
        case NeverDepth:
          gl.depthFunc(gl.NEVER);
          break;
        case AlwaysDepth:
          gl.depthFunc(gl.ALWAYS);
          break;
        case LessDepth:
          gl.depthFunc(gl.LESS);
          break;
        case LessEqualDepth:
          gl.depthFunc(gl.LEQUAL);
          break;
        case EqualDepth:
          gl.depthFunc(gl.EQUAL);
          break;
        case GreaterEqualDepth:
          gl.depthFunc(gl.GEQUAL);
          break;
        case GreaterDepth:
          gl.depthFunc(gl.GREATER);
          break;
        case NotEqualDepth:
          gl.depthFunc(gl.NOTEQUAL);
          break;
        default:
          gl.depthFunc(gl.LEQUAL);
      }
      this.currentDepthFunc = depthFunc;
    }
  }
  setStencilTest(stencilTest) {
    const { gl } = this;
    if (stencilTest) {
      this.enable(gl.STENCIL_TEST);
    } else {
      this.disable(gl.STENCIL_TEST);
    }
  }
  setStencilMask(stencilMask) {
    if (this.currentStencilMask !== stencilMask) {
      this.gl.stencilMask(stencilMask);
      this.currentStencilMask = stencilMask;
    }
  }
  setStencilFunc(stencilFunc, stencilRef, stencilMask) {
    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {
      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
      this.currentStencilFunc = stencilFunc;
      this.currentStencilRef = stencilRef;
      this.currentStencilFuncMask = stencilMask;
    }
  }
  setStencilOp(stencilFail, stencilZFail, stencilZPass) {
    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {
      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
      this.currentStencilFail = stencilFail;
      this.currentStencilZFail = stencilZFail;
      this.currentStencilZPass = stencilZPass;
    }
  }
  setMaterial(material, frontFaceCW) {
    const { gl } = this;
    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    this.setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    this.setDepthFunc(material.depthFunc);
    this.setDepthTest(material.depthTest);
    this.setDepthMask(material.depthWrite);
    this.setColorMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    this.setStencilTest(stencilWrite);
    if (stencilWrite) {
      this.setStencilMask(material.stencilWriteMask);
      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setPolygonOffset(polygonOffset, factor, units) {
    const { gl } = this;
    if (polygonOffset) {
      this.enable(gl.POLYGON_OFFSET_FILL);
      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        this.currentPolygonOffsetFactor = factor;
        this.currentPolygonOffsetUnits = units;
      }
    } else {
      this.disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  useProgram(program) {
    if (this.currentProgram !== program) {
      this.gl.useProgram(program);
      this.currentProgram = program;
      return true;
    }
    return false;
  }
  // framebuffer
  bindFramebuffer(target, framebuffer) {
    const { gl, currentBoundFramebuffers } = this;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  drawBuffers(renderContext, framebuffer) {
    const { gl } = this;
    let drawBuffers = [];
    let needsUpdate = false;
    if (renderContext.textures !== null) {
      drawBuffers = this.currentDrawbuffers.get(framebuffer);
      if (drawBuffers === void 0) {
        drawBuffers = [];
        this.currentDrawbuffers.set(framebuffer, drawBuffers);
      }
      const textures = renderContext.textures;
      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i = 0, il = textures.length; i < il; i++) {
          drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers[0] !== gl.BACK) {
        drawBuffers[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers);
    }
  }
  // texture
  activeTexture(webglSlot) {
    const { gl, currentTextureSlot, maxTextures } = this;
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      this.currentTextureSlot = webglSlot;
    }
  }
  bindTexture(webglType, webglTexture, webglSlot) {
    const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        this.currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  unbindTexture() {
    const { gl, currentTextureSlot, currentBoundTextures } = this;
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
};
var WebGLState_default = WebGLState;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLUtils.js
var WebGLUtils = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.extensions = backend.extensions;
  }
  convert(p, colorSpace = NoColorSpace) {
    const { gl, extensions } = this;
    let extension;
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) {
      return gl.HALF_FLOAT;
    }
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (colorSpace === SRGBColorSpace) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      return gl.UNSIGNED_INT_24_8;
    }
    return gl[p] !== void 0 ? gl[p] : null;
  }
  _clientWaitAsync() {
    const { gl } = this;
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    return new Promise((resolve, reject) => {
      function test() {
        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (res === gl.WAIT_FAILED) {
          gl.deleteSync(sync);
          reject();
          return;
        }
        if (res === gl.TIMEOUT_EXPIRED) {
          requestAnimationFrame(test);
          return;
        }
        gl.deleteSync(sync);
        resolve();
      }
      test();
    });
  }
};
var WebGLUtils_default = WebGLUtils;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLTextureUtils.js
var initialized2 = false;
var wrappingToGL;
var filterToGL;
var compareToGL;
var WebGLTextureUtils = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.defaultTextures = {};
    if (initialized2 === false) {
      this._init(this.gl);
      initialized2 = true;
    }
  }
  _init(gl) {
    wrappingToGL = {
      [RepeatWrapping]: gl.REPEAT,
      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT
    };
    filterToGL = {
      [NearestFilter]: gl.NEAREST,
      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: gl.LINEAR,
      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR
    };
    compareToGL = {
      [NeverCompare]: gl.NEVER,
      [AlwaysCompare]: gl.ALWAYS,
      [LessCompare]: gl.LESS,
      [LessEqualCompare]: gl.LEQUAL,
      [EqualCompare]: gl.EQUAL,
      [GreaterEqualCompare]: gl.GEQUAL,
      [GreaterCompare]: gl.GREATER,
      [NotEqualCompare]: gl.NOTEQUAL
    };
  }
  filterFallback(f) {
    const { gl } = this;
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return gl.NEAREST;
    }
    return gl.LINEAR;
  }
  getGLTextureType(texture2) {
    const { gl } = this;
    let glTextureType;
    if (texture2.isCubeTexture === true) {
      glTextureType = gl.TEXTURE_CUBE_MAP;
    } else if (texture2.isDataArrayTexture === true) {
      glTextureType = gl.TEXTURE_2D_ARRAY;
    } else if (texture2.isData3DTexture === true) {
      glTextureType = gl.TEXTURE_3D;
    } else {
      glTextureType = gl.TEXTURE_2D;
    }
    return glTextureType;
  }
  getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    const { gl, extensions } = this;
    if (internalFormatName !== null) {
      if (gl[internalFormatName] !== void 0) return gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === gl.RED) {
      if (glType === gl.FLOAT) internalFormat = gl.R32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RED_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RG) {
      if (glType === gl.FLOAT) internalFormat = gl.RG32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RGB) {
      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8 : gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
    }
    if (glFormat === gl.RGBA) {
      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
    }
    if (glFormat === gl.DEPTH_COMPONENT) {
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH24_STENCIL8;
      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
    }
    if (glFormat === gl.DEPTH_STENCIL) {
      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
    }
    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  setTextureParameters(textureType, texture2) {
    const { gl, extensions, backend } = this;
    const { currentAnisotropy } = backend.get(texture2);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture2.wrapS]);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture2.wrapT]);
    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
      gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture2.wrapR]);
    }
    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture2.magFilter]);
    const minFilter = !texture2.isVideoTexture && texture2.minFilter === LinearFilter ? LinearMipmapLinearFilter : texture2.minFilter;
    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
    if (texture2.compareFunction) {
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture2.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture2.magFilter === NearestFilter) return;
      if (texture2.minFilter !== NearestMipmapLinearFilter && texture2.minFilter !== LinearMipmapLinearFilter) return;
      if (texture2.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture2.anisotropy > 1 || currentAnisotropy !== texture2.anisotropy) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture2.anisotropy, backend.getMaxAnisotropy()));
        backend.get(texture2).currentAnisotropy = texture2.anisotropy;
      }
    }
  }
  createDefaultTexture(texture2) {
    const { gl, backend, defaultTextures } = this;
    const glTextureType = this.getGLTextureType(texture2);
    let textureGPU = defaultTextures[glTextureType];
    if (textureGPU === void 0) {
      textureGPU = gl.createTexture();
      backend.state.bindTexture(glTextureType, textureGPU);
      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      defaultTextures[glTextureType] = textureGPU;
    }
    backend.set(texture2, {
      textureGPU,
      glTextureType,
      isDefault: true
    });
  }
  createTexture(texture2, options) {
    const { gl, backend } = this;
    const { levels, width, height, depth: depth2 } = options;
    const glFormat = backend.utils.convert(texture2.format, texture2.colorSpace);
    const glType = backend.utils.convert(texture2.type);
    const glInternalFormat = this.getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, texture2.isVideoTexture);
    const textureGPU = gl.createTexture();
    const glTextureType = this.getGLTextureType(texture2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture2.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture2.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    this.setTextureParameters(glTextureType, texture2);
    if (texture2.isDataArrayTexture) {
      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth2);
    } else if (texture2.isData3DTexture) {
      gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth2);
    } else if (!texture2.isVideoTexture) {
      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
    }
    backend.set(texture2, {
      textureGPU,
      glTextureType,
      glFormat,
      glType,
      glInternalFormat
    });
  }
  copyBufferToTexture(buffer2, texture2) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType, glFormat, glType } = backend.get(texture2);
    const { width, height } = texture2.source.data;
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
    backend.state.unbindTexture();
  }
  updateTexture(texture2, options) {
    const { gl } = this;
    const { width, height } = options;
    const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get(texture2);
    if (texture2.isRenderTargetTexture || textureGPU === void 0)
      return;
    const getImage = (source) => {
      if (source.isDataTexture) {
        return source.image.data;
      } else if (source instanceof ImageBitmap || source instanceof OffscreenCanvas || source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {
        return source;
      }
      return source.data;
    };
    this.backend.state.bindTexture(glTextureType, textureGPU);
    if (texture2.isCompressedTexture) {
      const mipmaps = texture2.mipmaps;
      for (let i = 0; i < mipmaps.length; i++) {
        const mipmap = mipmaps[i];
        if (texture2.isCompressedArrayTexture) {
          const image = options.image;
          if (texture2.format !== gl.RGBA) {
            if (glFormat !== null) {
              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
          }
        } else {
          if (glFormat !== null) {
            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
          } else {
            console.warn("Unsupported compressed texture format");
          }
        }
      }
    } else if (texture2.isCubeTexture) {
      const images = options.images;
      for (let i = 0; i < 6; i++) {
        const image = getImage(images[i]);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);
      }
    } else if (texture2.isDataArrayTexture) {
      const image = options.image;
      gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
    } else if (texture2.isData3DTexture) {
      const image = options.image;
      gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
    } else if (texture2.isVideoTexture) {
      texture2.update();
      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);
    } else {
      const image = getImage(options.image);
      gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);
    }
  }
  generateMipmaps(texture2) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType } = backend.get(texture2);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.generateMipmap(glTextureType);
  }
  deallocateRenderBuffers(renderTarget) {
    const { gl, backend } = this;
    if (renderTarget) {
      const renderContextData = backend.get(renderTarget);
      renderContextData.renderBufferStorageSetup = void 0;
      if (renderContextData.framebuffer) {
        gl.deleteFramebuffer(renderContextData.framebuffer);
        renderContextData.framebuffer = void 0;
      }
      if (renderContextData.depthRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
        renderContextData.depthRenderbuffer = void 0;
      }
      if (renderContextData.stencilRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
        renderContextData.stencilRenderbuffer = void 0;
      }
      if (renderContextData.msaaFrameBuffer) {
        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
        renderContextData.msaaFrameBuffer = void 0;
      }
      if (renderContextData.msaaRenderbuffers) {
        for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {
          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);
        }
        renderContextData.msaaRenderbuffers = void 0;
      }
    }
  }
  destroyTexture(texture2) {
    const { gl, backend } = this;
    const { textureGPU, renderTarget } = backend.get(texture2);
    this.deallocateRenderBuffers(renderTarget);
    gl.deleteTexture(textureGPU);
    backend.delete(texture2);
  }
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
    const { gl, backend } = this;
    const { state } = this.backend;
    const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get(dstTexture);
    let width, height, minX, minY;
    let dstX, dstY;
    if (srcRegion !== null) {
      width = srcRegion.max.x - srcRegion.min.x;
      height = srcRegion.max.y - srcRegion.min.y;
      minX = srcRegion.min.x;
      minY = srcRegion.min.y;
    } else {
      width = srcTexture.image.width;
      height = srcTexture.image.height;
      minX = 0;
      minY = 0;
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
    } else {
      dstX = 0;
      dstY = 0;
    }
    state.bindTexture(glTextureType, dstTextureGPU);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
    if (srcTexture.isDataTexture) {
      gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        gl.compressedTexSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, glFormat, glType, image);
      }
    }
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps) gl.generateMipmap(gl.TEXTURE_2D);
    state.unbindTexture();
  }
  copyFramebufferToTexture(texture2, renderContext) {
    const { gl } = this;
    const { state } = this.backend;
    const { textureGPU } = this.backend.get(texture2);
    const width = texture2.image.width;
    const height = texture2.image.height;
    const requireDrawFrameBuffer = texture2.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;
    if (requireDrawFrameBuffer) {
      let mask;
      let attachment;
      if (texture2.isDepthTexture === true) {
        mask = gl.DEPTH_BUFFER_BIT;
        attachment = gl.DEPTH_ATTACHMENT;
        if (renderContext.stencil) {
          mask |= gl.STENCIL_BUFFER_BIT;
        }
      } else {
        mask = gl.COLOR_BUFFER_BIT;
        attachment = gl.COLOR_ATTACHMENT0;
      }
      const fb = gl.createFramebuffer();
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);
      gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
      gl.deleteFramebuffer(fb);
    } else {
      state.bindTexture(gl.TEXTURE_2D, textureGPU);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, width, height);
      state.unbindTexture();
    }
    if (texture2.generateMipmaps) this.generateMipmaps(texture2);
    this.backend._setFramebuffer(renderContext);
  }
  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  setupRenderBufferStorage(renderbuffer, renderContext) {
    const { gl } = this;
    const renderTarget = renderContext.renderTarget;
    const { samples, depthTexture: depthTexture2, depthBuffer, stencilBuffer, width, height } = renderTarget;
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    if (depthBuffer && !stencilBuffer) {
      let glInternalFormat = gl.DEPTH_COMPONENT24;
      if (samples > 0) {
        if (depthTexture2 && depthTexture2.isDepthTexture) {
          if (depthTexture2.type === gl.FLOAT) {
            glInternalFormat = gl.DEPTH_COMPONENT32F;
          }
        }
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    } else if (depthBuffer && stencilBuffer) {
      if (samples > 0) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    }
  }
  async copyTextureToBuffer(texture2, x, y, width, height) {
    const { backend, gl } = this;
    const { textureGPU, glFormat, glType } = this.backend.get(texture2);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0);
    const typedArrayType = this._getTypedArrayType(glType);
    const bytesPerTexel = this._getBytesPerTexel(glFormat);
    const elementCount = width * height;
    const byteLength = elementCount * bytesPerTexel;
    const buffer2 = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer2);
    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    gl.deleteFramebuffer(fb);
    return dstBuffer;
  }
  _getTypedArrayType(glType) {
    const { gl } = this;
    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
    if (glType === gl.UNSIGNED_INT) return Uint32Array;
    if (glType === gl.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${glType}`);
  }
  _getBytesPerTexel(glFormat) {
    const { gl } = this;
    if (glFormat === gl.RGBA) return 4;
    if (glFormat === gl.RGB) return 3;
    if (glFormat === gl.ALPHA) return 1;
  }
};
var WebGLTextureUtils_default = WebGLTextureUtils;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLExtensions.js
var WebGLExtensions = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.availableExtensions = this.gl.getSupportedExtensions();
    this.extensions = {};
  }
  get(name) {
    let extension = this.extensions[name];
    if (extension === void 0) {
      extension = this.gl.getExtension(name);
    }
    return extension;
  }
  has(name) {
    return this.availableExtensions.includes(name);
  }
};
var WebGLExtensions_default = WebGLExtensions;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLCapabilities.js
var WebGLCapabilities = class {
  constructor(backend) {
    this.backend = backend;
    this.maxAnisotropy = null;
  }
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const gl = this.backend.gl;
    const extensions = this.backend.extensions;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      this.maxAnisotropy = 0;
    }
    return this.maxAnisotropy;
  }
};
var WebGLCapabilities_default = WebGLCapabilities;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLConstants.js
var GLFeatureName = {
  "WEBGL_compressed_texture_astc": "texture-compression-astc",
  "WEBGL_compressed_texture_etc": "texture-compression-etc2",
  "WEBGL_compressed_texture_etc1": "texture-compression-etc1",
  "WEBGL_compressed_texture_pvrtc": "texture-compression-pvrtc",
  "WEBKIT_WEBGL_compressed_texture_pvrtc": "texture-compression-pvrtc",
  "WEBGL_compressed_texture_s3tc": "texture-compression-bc",
  "EXT_texture_compression_bptc": "texture-compression-bptc",
  "EXT_disjoint_timer_query_webgl2": "timestamp-query"
};

// node_modules/three/examples/jsm/renderers/webgl/WebGLBufferRenderer.js
var WebGLBufferRenderer = class {
  constructor(backend) {
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.info = backend.renderer.info;
    this.mode = null;
    this.index = 0;
    this.type = null;
    this.object = null;
  }
  render(start, count) {
    const { gl, mode, object, type, info, index } = this;
    if (index !== 0) {
      gl.drawElements(mode, count, type, start);
    } else {
      gl.drawArrays(mode, start, count);
    }
    info.update(object, count, mode, 1);
  }
  renderInstances(start, count, primcount) {
    const { gl, mode, type, index, object, info } = this;
    if (primcount === 0) return;
    if (index !== 0) {
      gl.drawElementsInstanced(mode, count, type, start, primcount);
    } else {
      gl.drawArraysInstanced(mode, start, count, primcount);
    }
    info.update(object, count, mode, primcount);
  }
  renderMultiDraw(starts, counts, drawCount) {
    const { extensions, mode, object, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < drawCount; i++) {
        this.render(starts[i], counts[i]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);
      } else {
        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
      }
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      info.update(object, elementCount, mode, 1);
    }
  }
  renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    const { extensions, mode, object, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < drawCount; i++) {
        this.renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);
      } else {
        extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      }
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      for (let i = 0; i < primcount.length; i++) {
        info.update(object, elementCount, mode, primcount[i]);
      }
    }
  }
  //
};

// node_modules/three/examples/jsm/renderers/webgl/WebGLBackend.js
var WebGLBackend = class extends Backend_default {
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGLBackend = true;
  }
  init(renderer) {
    super.init(renderer);
    const parameters = this.parameters;
    const glContext = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgl2");
    this.gl = glContext;
    this.extensions = new WebGLExtensions_default(this);
    this.capabilities = new WebGLCapabilities_default(this);
    this.attributeUtils = new WebGLAttributeUtils_default(this);
    this.textureUtils = new WebGLTextureUtils_default(this);
    this.bufferRenderer = new WebGLBufferRenderer(this);
    this.state = new WebGLState_default(this);
    this.utils = new WebGLUtils_default(this);
    this.vaoCache = {};
    this.transformFeedbackCache = {};
    this.discard = false;
    this.trackTimestamp = parameters.trackTimestamp === true;
    this.extensions.get("EXT_color_buffer_float");
    this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2");
    this.parallel = this.extensions.get("KHR_parallel_shader_compile");
    this._currentContext = null;
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  async getArrayBufferAsync(attribute2) {
    return await this.attributeUtils.getArrayBufferAsync(attribute2);
  }
  initTimestampQuery(renderContext) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const renderContextData = this.get(renderContext);
    if (this.queryRunning) {
      if (!renderContextData.queryQueue) renderContextData.queryQueue = [];
      renderContextData.queryQueue.push(renderContext);
      return;
    }
    if (renderContextData.activeQuery) {
      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);
      renderContextData.activeQuery = null;
    }
    renderContextData.activeQuery = this.gl.createQuery();
    if (renderContextData.activeQuery !== null) {
      this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery);
      this.queryRunning = true;
    }
  }
  // timestamp utils
  prepareTimestampBuffer(renderContext) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const renderContextData = this.get(renderContext);
    if (renderContextData.activeQuery) {
      this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);
      if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];
      renderContextData.gpuQueries.push({ query: renderContextData.activeQuery });
      renderContextData.activeQuery = null;
      this.queryRunning = false;
      if (renderContextData.queryQueue && renderContextData.queryQueue.length > 0) {
        const nextRenderContext = renderContextData.queryQueue.shift();
        this.initTimestampQuery(nextRenderContext);
      }
    }
  }
  async resolveTimestampAsync(renderContext, type = "render") {
    if (!this.disjoint || !this.trackTimestamp) return;
    const renderContextData = this.get(renderContext);
    if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];
    for (let i = 0; i < renderContextData.gpuQueries.length; i++) {
      const queryInfo = renderContextData.gpuQueries[i];
      const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);
      const disjoint = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
      if (available && !disjoint) {
        const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);
        const duration = Number(elapsed) / 1e6;
        this.gl.deleteQuery(queryInfo.query);
        renderContextData.gpuQueries.splice(i, 1);
        i--;
        this.renderer.info.updateTimestamp(type, duration);
      }
    }
  }
  getContext() {
    return this.gl;
  }
  beginRender(renderContext) {
    const { gl } = this;
    const renderContextData = this.get(renderContext);
    this.initTimestampQuery(renderContext);
    renderContextData.previousContext = this._currentContext;
    this._currentContext = renderContext;
    this._setFramebuffer(renderContext);
    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    } else {
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    if (renderContext.scissor) {
      const { x, y, width, height } = renderContext.scissorValue;
      gl.scissor(x, y, width, height);
    }
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      renderContextData.lastOcclusionObject = null;
      renderContextData.occlusionQueries = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryIndex = 0;
    }
  }
  finishRender(renderContext) {
    const { gl, state } = this;
    const renderContextData = this.get(renderContext);
    const previousContext = renderContextData.previousContext;
    const textures = renderContext.textures;
    if (textures !== null) {
      for (let i = 0; i < textures.length; i++) {
        const texture2 = textures[i];
        if (texture2.generateMipmaps) {
          this.generateMipmaps(texture2);
        }
      }
    }
    this._currentContext = previousContext;
    if (renderContext.textures !== null && renderContext.renderTarget) {
      const renderTargetContextData = this.get(renderContext.renderTarget);
      const { samples } = renderContext.renderTarget;
      const fb = renderTargetContextData.framebuffer;
      const mask = gl.COLOR_BUFFER_BIT;
      if (samples > 0) {
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        const textures2 = renderContext.textures;
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        for (let i = 0; i < textures2.length; i++) {
          gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);
          gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);
        }
      }
    }
    if (previousContext !== null) {
      this._setFramebuffer(previousContext);
      if (previousContext.viewport) {
        this.updateViewport(previousContext);
      } else {
        const gl2 = this.gl;
        gl2.viewport(0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
      }
    }
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      const renderContextData2 = this.get(renderContext);
      if (occlusionQueryCount > renderContextData2.occlusionQueryIndex) {
        const { gl: gl2 } = this;
        gl2.endQuery(gl2.ANY_SAMPLES_PASSED);
      }
      this.resolveOccludedAsync(renderContext);
    }
    this.prepareTimestampBuffer(renderContext);
  }
  resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueries && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      const { gl } = this;
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueries = null;
      const check = () => {
        let completed = 0;
        for (let i = 0; i < currentOcclusionQueries.length; i++) {
          const query = currentOcclusionQueries[i];
          if (query === null) continue;
          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
            if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0) occluded.add(currentOcclusionQueryObjects[i]);
            currentOcclusionQueries[i] = null;
            gl.deleteQuery(query);
            completed++;
          }
        }
        if (completed < currentOcclusionQueries.length) {
          requestAnimationFrame(check);
        } else {
          renderContextData.occluded = occluded;
        }
      };
      check();
    }
  }
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  updateViewport(renderContext) {
    const gl = this.gl;
    const { x, y, width, height } = renderContext.viewportValue;
    gl.viewport(x, y, width, height);
  }
  setScissorTest(boolean) {
    const gl = this.gl;
    if (boolean) {
      gl.enable(gl.SCISSOR_TEST);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  clear(color2, depth2, stencil, descriptor = null, setFrameBuffer = true) {
    const { gl } = this;
    if (descriptor === null) {
      descriptor = {
        textures: null,
        clearColorValue: this.getClearColor()
      };
    }
    let clear = 0;
    if (color2) clear |= gl.COLOR_BUFFER_BIT;
    if (depth2) clear |= gl.DEPTH_BUFFER_BIT;
    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
    if (clear !== 0) {
      const clearColor = descriptor.clearColorValue || this.getClearColor();
      if (depth2) this.state.setDepthMask(true);
      if (descriptor.textures === null) {
        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
        gl.clear(clear);
      } else {
        if (setFrameBuffer) this._setFramebuffer(descriptor);
        if (color2) {
          for (let i = 0; i < descriptor.textures.length; i++) {
            gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);
          }
        }
        if (depth2 && stencil) {
          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);
        } else if (depth2) {
          gl.clearBufferfv(gl.DEPTH, 0, [1]);
        } else if (stencil) {
          gl.clearBufferiv(gl.STENCIL, 0, [0]);
        }
      }
    }
  }
  beginCompute(computeGroup) {
    const gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.initTimestampQuery(computeGroup);
  }
  compute(computeGroup, computeNode, bindings, pipeline) {
    const gl = this.gl;
    if (!this.discard) {
      gl.enable(gl.RASTERIZER_DISCARD);
      this.discard = true;
    }
    const { programGPU, transformBuffers, attributes } = this.get(pipeline);
    const vaoKey = this._getVaoKey(null, attributes);
    const vaoGPU = this.vaoCache[vaoKey];
    if (vaoGPU === void 0) {
      this._createVao(null, attributes);
    } else {
      gl.bindVertexArray(vaoGPU);
    }
    gl.useProgram(programGPU);
    this._bindUniforms(bindings);
    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    gl.beginTransformFeedback(gl.POINTS);
    if (attributes[0].isStorageInstancedBufferAttribute) {
      gl.drawArraysInstanced(gl.POINTS, 0, 1, computeNode.count);
    } else {
      gl.drawArrays(gl.POINTS, 0, computeNode.count);
    }
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    for (let i = 0; i < transformBuffers.length; i++) {
      const dualAttributeData = transformBuffers[i];
      if (dualAttributeData.pbo) {
        this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);
      }
      dualAttributeData.switchBuffers();
    }
  }
  finishCompute(computeGroup) {
    const gl = this.gl;
    this.discard = false;
    gl.disable(gl.RASTERIZER_DISCARD);
    this.prepareTimestampBuffer(computeGroup);
  }
  draw(renderObject, info) {
    const { object, pipeline, material, context: context2 } = renderObject;
    const { programGPU } = this.get(pipeline);
    const { gl, state } = this;
    const contextData = this.get(context2);
    this._bindUniforms(renderObject.getBindings());
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW);
    gl.useProgram(programGPU);
    let vaoGPU = renderObject.staticVao;
    if (vaoGPU === void 0) {
      const vaoKey = this._getVaoKey(renderObject.getIndex(), renderObject.getAttributes());
      vaoGPU = this.vaoCache[vaoKey];
      if (vaoGPU === void 0) {
        let staticVao;
        ({ vaoGPU, staticVao } = this._createVao(renderObject.getIndex(), renderObject.getAttributes()));
        if (staticVao) renderObject.staticVao = vaoGPU;
      }
    }
    gl.bindVertexArray(vaoGPU);
    const index = renderObject.getIndex();
    const geometry = renderObject.geometry;
    const drawRange = renderObject.drawRange;
    const firstVertex = drawRange.start;
    const lastObject = contextData.lastOcclusionObject;
    if (lastObject !== object && lastObject !== void 0) {
      if (lastObject !== null && lastObject.occlusionTest === true) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
        contextData.occlusionQueryIndex++;
      }
      if (object.occlusionTest === true) {
        const query = gl.createQuery();
        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
      }
      contextData.lastOcclusionObject = object;
    }
    const renderer = this.bufferRenderer;
    if (object.isPoints) renderer.mode = gl.POINTS;
    else if (object.isLineSegments) renderer.mode = gl.LINES;
    else if (object.isLine) renderer.mode = gl.LINE_STRIP;
    else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;
    else {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());
        renderer.mode = gl.LINES;
      } else {
        renderer.mode = gl.TRIANGLES;
      }
    }
    let count;
    renderer.object = object;
    if (index !== null) {
      const indexData = this.get(index);
      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;
      renderer.index = index.count;
      renderer.type = indexData.type;
      count = indexCount;
    } else {
      renderer.index = 0;
      const vertexCount = drawRange.count !== Infinity ? drawRange.count : geometry.attributes.position.count;
      count = vertexCount;
    }
    const instanceCount = this.getInstanceCount(renderObject);
    if (object.isBatchedMesh) {
      if (object._multiDrawInstances !== null) {
        renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
      } else {
        renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
      }
    } else if (instanceCount > 1) {
      renderer.renderInstances(firstVertex, count, instanceCount);
    } else {
      renderer.render(firstVertex, count);
    }
    gl.bindVertexArray(null);
  }
  needsRenderUpdate() {
    return false;
  }
  getRenderCacheKey(renderObject) {
    return renderObject.id;
  }
  // textures
  createDefaultTexture(texture2) {
    this.textureUtils.createDefaultTexture(texture2);
  }
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  destroyTexture(texture2) {
    this.textureUtils.destroyTexture(texture2);
  }
  copyTextureToBuffer(texture2, x, y, width, height) {
    return this.textureUtils.copyTextureToBuffer(texture2, x, y, width, height);
  }
  createSampler() {
  }
  destroySampler() {
  }
  // node builder
  createNodeBuilder(object, renderer, scene = null) {
    return new GLSLNodeBuilder_default(object, renderer, scene);
  }
  // program
  createProgram(program) {
    const gl = this.gl;
    const { stage, code: code2 } = program;
    const shader = stage === "fragment" ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(shader, code2);
    gl.compileShader(shader);
    this.set(program, {
      shaderGPU: shader
    });
  }
  destroyProgram() {
    console.warn("Abstract class.");
  }
  createRenderPipeline(renderObject, promises) {
    const gl = this.gl;
    const pipeline = renderObject.pipeline;
    const { fragmentProgram, vertexProgram } = pipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(vertexProgram).shaderGPU;
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.linkProgram(programGPU);
    this.set(pipeline, {
      programGPU,
      fragmentShader,
      vertexShader
    });
    if (promises !== null && this.parallel) {
      const p = new Promise((resolve) => {
        const parallel = this.parallel;
        const checkStatus = () => {
          if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {
            this._completeCompile(renderObject, pipeline);
            resolve();
          } else {
            requestAnimationFrame(checkStatus);
          }
        };
        checkStatus();
      });
      promises.push(p);
      return;
    }
    this._completeCompile(renderObject, pipeline);
  }
  _completeCompile(renderObject, pipeline) {
    const gl = this.gl;
    const pipelineData = this.get(pipeline);
    const { programGPU, fragmentShader, vertexShader } = pipelineData;
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      console.error("THREE.WebGLBackend:", gl.getProgramInfoLog(programGPU));
      console.error("THREE.WebGLBackend:", gl.getShaderInfoLog(fragmentShader));
      console.error("THREE.WebGLBackend:", gl.getShaderInfoLog(vertexShader));
    }
    gl.useProgram(programGPU);
    this._setupBindings(renderObject.getBindings(), programGPU);
    this.set(pipeline, {
      programGPU
    });
  }
  createComputePipeline(computePipeline, bindings) {
    const gl = this.gl;
    const fragmentProgram = {
      stage: "fragment",
      code: "#version 300 es\nprecision highp float;\nvoid main() {}"
    };
    this.createProgram(fragmentProgram);
    const { computeProgram } = computePipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(computeProgram).shaderGPU;
    const transforms = computeProgram.transforms;
    const transformVaryingNames = [];
    const transformAttributeNodes = [];
    for (let i = 0; i < transforms.length; i++) {
      const transform = transforms[i];
      transformVaryingNames.push(transform.varyingName);
      transformAttributeNodes.push(transform.attributeNode);
    }
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.transformFeedbackVaryings(
      programGPU,
      transformVaryingNames,
      gl.SEPARATE_ATTRIBS
    );
    gl.linkProgram(programGPU);
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      console.error("THREE.WebGLBackend:", gl.getProgramInfoLog(programGPU));
      console.error("THREE.WebGLBackend:", gl.getShaderInfoLog(fragmentShader));
      console.error("THREE.WebGLBackend:", gl.getShaderInfoLog(vertexShader));
    }
    gl.useProgram(programGPU);
    this.createBindings(bindings);
    this._setupBindings(bindings, programGPU);
    const attributeNodes = computeProgram.attributes;
    const attributes = [];
    const transformBuffers = [];
    for (let i = 0; i < attributeNodes.length; i++) {
      const attribute2 = attributeNodes[i].node.attribute;
      attributes.push(attribute2);
      if (!this.has(attribute2)) this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
    }
    for (let i = 0; i < transformAttributeNodes.length; i++) {
      const attribute2 = transformAttributeNodes[i].attribute;
      if (!this.has(attribute2)) this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
      const attributeData = this.get(attribute2);
      transformBuffers.push(attributeData);
    }
    this.set(computePipeline, {
      programGPU,
      transformBuffers,
      attributes
    });
  }
  createBindings(bindings) {
    this.updateBindings(bindings);
  }
  updateBindings(bindings) {
    const { gl } = this;
    let groupIndex = 0;
    let textureIndex = 0;
    for (const binding of bindings) {
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const bufferGPU = gl.createBuffer();
        const data = binding.buffer;
        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, groupIndex, bufferGPU);
        this.set(binding, {
          index: groupIndex++,
          bufferGPU
        });
      } else if (binding.isSampledTexture) {
        const { textureGPU, glTextureType } = this.get(binding.texture);
        this.set(binding, {
          index: textureIndex++,
          textureGPU,
          glTextureType
        });
      }
    }
  }
  updateBinding(binding) {
    const gl = this.gl;
    if (binding.isUniformsGroup || binding.isUniformBuffer) {
      const bindingData = this.get(binding);
      const bufferGPU = bindingData.bufferGPU;
      const data = binding.buffer;
      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
    }
  }
  // attributes
  createIndexAttribute(attribute2) {
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ELEMENT_ARRAY_BUFFER);
  }
  createAttribute(attribute2) {
    if (this.has(attribute2)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute2, gl.ARRAY_BUFFER);
  }
  createStorageAttribute(attribute2) {
  }
  updateAttribute(attribute2) {
    this.attributeUtils.updateAttribute(attribute2);
  }
  destroyAttribute(attribute2) {
    this.attributeUtils.destroyAttribute(attribute2);
  }
  updateSize() {
  }
  hasFeature(name) {
    const keysMatching = Object.keys(GLFeatureName).filter((key) => GLFeatureName[key] === name);
    const extensions = this.extensions;
    for (let i = 0; i < keysMatching.length; i++) {
      if (extensions.has(keysMatching[i])) return true;
    }
    return false;
  }
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  copyTextureToTexture(position, srcTexture, dstTexture, level) {
    this.textureUtils.copyTextureToTexture(position, srcTexture, dstTexture, level);
  }
  copyFramebufferToTexture(texture2, renderContext) {
    this.textureUtils.copyFramebufferToTexture(texture2, renderContext);
  }
  _setFramebuffer(renderContext) {
    const { gl, state } = this;
    let currentFrameBuffer = null;
    if (renderContext.textures !== null) {
      const renderTarget = renderContext.renderTarget;
      const renderTargetContextData = this.get(renderTarget);
      const { samples, depthBuffer, stencilBuffer } = renderTarget;
      const cubeFace = this.renderer._activeCubeFace;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      let msaaFb = renderTargetContextData.msaaFrameBuffer;
      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
      let fb;
      if (isCube) {
        if (renderTargetContextData.cubeFramebuffers === void 0) {
          renderTargetContextData.cubeFramebuffers = [];
        }
        fb = renderTargetContextData.cubeFramebuffers[cubeFace];
      } else {
        fb = renderTargetContextData.framebuffer;
      }
      if (fb === void 0) {
        fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.FRAMEBUFFER, fb);
        const textures = renderContext.textures;
        if (isCube) {
          renderTargetContextData.cubeFramebuffers[cubeFace] = fb;
          const { textureGPU } = this.get(textures[0]);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);
        } else {
          for (let i = 0; i < textures.length; i++) {
            const texture2 = textures[i];
            const textureData = this.get(texture2);
            textureData.renderTarget = renderContext.renderTarget;
            const attachment = gl.COLOR_ATTACHMENT0 + i;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0);
          }
          renderTargetContextData.framebuffer = fb;
          state.drawBuffers(renderContext, fb);
        }
        if (renderContext.depthTexture !== null) {
          const textureData = this.get(renderContext.depthTexture);
          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);
        }
      }
      if (samples > 0) {
        if (msaaFb === void 0) {
          const invalidationArray = [];
          msaaFb = gl.createFramebuffer();
          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
          const msaaRenderbuffers = [];
          const textures = renderContext.textures;
          for (let i = 0; i < textures.length; i++) {
            msaaRenderbuffers[i] = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);
            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);
            if (depthBuffer) {
              const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
              invalidationArray.push(depthStyle);
            }
            const texture2 = renderContext.textures[i];
            const textureData = this.get(texture2);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, renderContext.width, renderContext.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);
          }
          renderTargetContextData.msaaFrameBuffer = msaaFb;
          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
          if (depthRenderbuffer === void 0) {
            depthRenderbuffer = gl.createRenderbuffer();
            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, renderContext);
            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            invalidationArray.push(depthStyle);
          }
          renderTargetContextData.invalidationArray = invalidationArray;
        }
        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
      } else {
        currentFrameBuffer = fb;
      }
    }
    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
  }
  _getVaoKey(index, attributes) {
    let key = [];
    if (index !== null) {
      const indexData = this.get(index);
      key += ":" + indexData.id;
    }
    for (let i = 0; i < attributes.length; i++) {
      const attributeData = this.get(attributes[i]);
      key += ":" + attributeData.id;
    }
    return key;
  }
  _createVao(index, attributes) {
    const { gl } = this;
    const vaoGPU = gl.createVertexArray();
    let key = "";
    let staticVao = true;
    gl.bindVertexArray(vaoGPU);
    if (index !== null) {
      const indexData = this.get(index);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU);
      key += ":" + indexData.id;
    }
    for (let i = 0; i < attributes.length; i++) {
      const attribute2 = attributes[i];
      const attributeData = this.get(attribute2);
      key += ":" + attributeData.id;
      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
      gl.enableVertexAttribArray(i);
      if (attribute2.isStorageBufferAttribute || attribute2.isStorageInstancedBufferAttribute) staticVao = false;
      let stride, offset;
      if (attribute2.isInterleavedBufferAttribute === true) {
        stride = attribute2.data.stride * attributeData.bytesPerElement;
        offset = attribute2.offset * attributeData.bytesPerElement;
      } else {
        stride = 0;
        offset = 0;
      }
      if (attributeData.isInteger) {
        gl.vertexAttribIPointer(i, attribute2.itemSize, attributeData.type, stride, offset);
      } else {
        gl.vertexAttribPointer(i, attribute2.itemSize, attributeData.type, attribute2.normalized, stride, offset);
      }
      if (attribute2.isInstancedBufferAttribute && !attribute2.isInterleavedBufferAttribute) {
        gl.vertexAttribDivisor(i, attribute2.meshPerAttribute);
      } else if (attribute2.isInterleavedBufferAttribute && attribute2.data.isInstancedInterleavedBuffer) {
        gl.vertexAttribDivisor(i, attribute2.data.meshPerAttribute);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    this.vaoCache[key] = vaoGPU;
    return { vaoGPU, staticVao };
  }
  _getTransformFeedback(transformBuffers) {
    let key = "";
    for (let i = 0; i < transformBuffers.length; i++) {
      key += ":" + transformBuffers[i].id;
    }
    let transformFeedbackGPU = this.transformFeedbackCache[key];
    if (transformFeedbackGPU !== void 0) {
      return transformFeedbackGPU;
    }
    const gl = this.gl;
    transformFeedbackGPU = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    for (let i = 0; i < transformBuffers.length; i++) {
      const attributeData = transformBuffers[i];
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    this.transformFeedbackCache[key] = transformFeedbackGPU;
    return transformFeedbackGPU;
  }
  _setupBindings(bindings, programGPU) {
    const gl = this.gl;
    for (const binding of bindings) {
      const bindingData = this.get(binding);
      const index = bindingData.index;
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const location = gl.getUniformBlockIndex(programGPU, binding.name);
        gl.uniformBlockBinding(programGPU, location, index);
      } else if (binding.isSampledTexture) {
        const location = gl.getUniformLocation(programGPU, binding.name);
        gl.uniform1i(location, index);
      }
    }
  }
  _bindUniforms(bindings) {
    const { gl, state } = this;
    for (const binding of bindings) {
      const bindingData = this.get(binding);
      const index = bindingData.index;
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);
      } else if (binding.isSampledTexture) {
        state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);
      }
    }
  }
};
var WebGLBackend_default = WebGLBackend;

// node_modules/three/examples/jsm/renderers/common/Sampler.js
var Sampler = class extends Binding_default {
  constructor(name, texture2) {
    super(name);
    this.texture = texture2;
    this.version = texture2 ? texture2.version : 0;
    this.isSampler = true;
  }
};
var Sampler_default = Sampler;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeSampler.js
var NodeSampler = class extends Sampler_default {
  constructor(name, textureNode) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
  }
  update() {
    this.texture = this.textureNode.value;
  }
};
var NodeSampler_default = NodeSampler;

// node_modules/three/examples/jsm/renderers/common/StorageBuffer.js
var StorageBuffer = class extends Buffer_default {
  constructor(name, attribute2) {
    super(name, attribute2 ? attribute2.array : null);
    this.attribute = attribute2;
    this.isStorageBuffer = true;
  }
};
var StorageBuffer_default = StorageBuffer;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeStorageBuffer.js
var _id4 = 0;
var NodeStorageBuffer = class extends StorageBuffer_default {
  constructor(nodeUniform) {
    super("StorageBuffer_" + _id4++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
  }
  get buffer() {
    return this.nodeUniform.value;
  }
};
var NodeStorageBuffer_default = NodeStorageBuffer;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTexturePassUtils.js
var WebGPUTexturePassUtils = class {
  constructor(device) {
    this.device = device;
    const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
    const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
    const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
    this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest });
    this.transferPipelines = {};
    this.flipYPipelines = {};
    this.mipmapVertexShaderModule = device.createShaderModule({
      label: "mipmapVertex",
      code: mipmapVertexSource
    });
    this.mipmapFragmentShaderModule = device.createShaderModule({
      label: "mipmapFragment",
      code: mipmapFragmentSource
    });
    this.flipYFragmentShaderModule = device.createShaderModule({
      label: "flipYFragment",
      code: flipYFragmentSource
    });
  }
  getTransferPipeline(format) {
    let pipeline = this.transferPipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.mipmapFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.transferPipelines[format] = pipeline;
    }
    return pipeline;
  }
  getFlipYPipeline(format) {
    let pipeline = this.flipYPipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.flipYFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.flipYPipelines[format] = pipeline;
    }
    return pipeline;
  }
  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const format = textureGPUDescriptor.format;
    const { width, height } = textureGPUDescriptor.size;
    const transferPipeline = this.getTransferPipeline(format);
    const flipYPipeline = this.getFlipYPipeline(format);
    const tempTexture = this.device.createTexture({
      size: { width, height, depthOrArrayLayers: 1 },
      format,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    const dstView = tempTexture.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer: 0
    });
    const commandEncoder = this.device.createCommandEncoder({});
    const pass2 = (pipeline, sourceView, destinationView) => {
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: sourceView
        }]
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: destinationView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    };
    pass2(transferPipeline, srcView, dstView);
    pass2(flipYPipeline, dstView, srcView);
    this.device.queue.submit([commandEncoder.finish()]);
    tempTexture.destroy();
  }
  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
    const commandEncoder = this.device.createCommandEncoder({});
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    let srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: srcView
        }]
      });
      const dstView = textureGPU.createView({
        baseMipLevel: i,
        mipLevelCount: 1,
        dimension: GPUTextureViewDimension.TwoD,
        baseArrayLayer
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: dstView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
      srcView = dstView;
    }
    this.device.queue.submit([commandEncoder.finish()]);
  }
};
var WebGPUTexturePassUtils_default = WebGPUTexturePassUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTextureUtils.js
var _compareToWebGPU = {
  [NeverCompare]: "never",
  [LessCompare]: "less",
  [EqualCompare]: "equal",
  [LessEqualCompare]: "less-equal",
  [GreaterCompare]: "greater",
  [GreaterEqualCompare]: "greater-equal",
  [AlwaysCompare]: "always",
  [NotEqualCompare]: "not-equal"
};
var _flipMap = [0, 1, 3, 2, 4, 5];
var WebGPUTextureUtils = class {
  constructor(backend) {
    this.backend = backend;
    this._passUtils = null;
    this.defaultTexture = {};
    this.defaultCubeTexture = {};
    this.colorBuffer = null;
    this.depthTexture = new DepthTexture();
    this.depthTexture.name = "depthBuffer";
  }
  createSampler(texture2) {
    const backend = this.backend;
    const device = backend.device;
    const textureGPU = backend.get(texture2);
    const samplerDescriptorGPU = {
      addressModeU: this._convertAddressMode(texture2.wrapS),
      addressModeV: this._convertAddressMode(texture2.wrapT),
      addressModeW: this._convertAddressMode(texture2.wrapR),
      magFilter: this._convertFilterMode(texture2.magFilter),
      minFilter: this._convertFilterMode(texture2.minFilter),
      mipmapFilter: this._convertFilterMode(texture2.minFilter),
      maxAnisotropy: texture2.anisotropy
    };
    if (texture2.isDepthTexture && texture2.compareFunction !== null) {
      samplerDescriptorGPU.compare = _compareToWebGPU[texture2.compareFunction];
    }
    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);
  }
  createDefaultTexture(texture2) {
    let textureGPU;
    const format = getFormat(texture2);
    if (texture2.isCubeTexture) {
      textureGPU = this._getDefaultCubeTextureGPU(format);
    } else {
      textureGPU = this._getDefaultTextureGPU(format);
    }
    this.backend.get(texture2).texture = textureGPU;
  }
  createTexture(texture2, options = {}) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    if (textureData.initialized) {
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    }
    if (options.needsMipmaps === void 0) options.needsMipmaps = false;
    if (options.levels === void 0) options.levels = 1;
    if (options.depth === void 0) options.depth = 1;
    const { width, height, depth: depth2, levels } = options;
    const dimension = this._getDimension(texture2);
    const format = texture2.internalFormat || options.format || getFormat(texture2, backend.device);
    let sampleCount = options.sampleCount !== void 0 ? options.sampleCount : 1;
    if (sampleCount > 1) {
      sampleCount = Math.pow(2, Math.floor(Math.log2(sampleCount)));
      if (sampleCount === 2) {
        sampleCount = 4;
      }
    }
    const primarySampleCount = texture2.isRenderTargetTexture ? 1 : sampleCount;
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    if (texture2.isStorageTexture === true) {
      usage |= GPUTextureUsage.STORAGE_BINDING;
    }
    if (texture2.isCompressedTexture !== true) {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    }
    const textureDescriptorGPU = {
      label: texture2.name,
      size: {
        width,
        height,
        depthOrArrayLayers: depth2
      },
      mipLevelCount: levels,
      sampleCount: primarySampleCount,
      dimension,
      format,
      usage
    };
    if (texture2.isVideoTexture) {
      const video = texture2.source.data;
      const videoFrame = new VideoFrame(video);
      textureDescriptorGPU.size.width = videoFrame.displayWidth;
      textureDescriptorGPU.size.height = videoFrame.displayHeight;
      videoFrame.close();
      textureData.externalTexture = video;
    } else {
      if (format === void 0) {
        console.warn("WebGPURenderer: Texture format not supported.");
        return this.createDefaultTexture(texture2);
      }
      textureData.texture = backend.device.createTexture(textureDescriptorGPU);
    }
    if (texture2.isRenderTargetTexture && sampleCount > 1) {
      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + "-msaa";
      msaaTextureDescriptorGPU.sampleCount = sampleCount;
      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
    }
    textureData.initialized = true;
    textureData.textureDescriptorGPU = textureDescriptorGPU;
  }
  destroyTexture(texture2) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    textureData.texture.destroy();
    if (textureData.msaaTexture !== void 0) textureData.msaaTexture.destroy();
    backend.delete(texture2);
  }
  destroySampler(texture2) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    delete textureData.sampler;
  }
  generateMipmaps(texture2) {
    const textureData = this.backend.get(texture2);
    if (texture2.isCubeTexture) {
      for (let i = 0; i < 6; i++) {
        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
      }
    } else {
      this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU);
    }
  }
  getColorBuffer() {
    if (this.colorBuffer) this.colorBuffer.destroy();
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    this.colorBuffer = backend.device.createTexture({
      label: "colorBuffer",
      size: {
        width,
        height,
        depthOrArrayLayers: 1
      },
      sampleCount: backend.parameters.sampleCount,
      format: GPUTextureFormat.BGRA8Unorm,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    });
    return this.colorBuffer;
  }
  getDepthBuffer(depth2 = true, stencil = false) {
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    const depthTexture2 = this.depthTexture;
    const depthTextureGPU = backend.get(depthTexture2).texture;
    let format, type;
    if (stencil) {
      format = DepthStencilFormat;
      type = UnsignedInt248Type;
    } else if (depth2) {
      format = DepthFormat;
      type = UnsignedIntType;
    }
    if (depthTextureGPU !== void 0) {
      if (depthTexture2.image.width === width && depthTexture2.image.height === height && depthTexture2.format === format && depthTexture2.type === type) {
        return depthTextureGPU;
      }
      this.destroyTexture(depthTexture2);
    }
    depthTexture2.name = "depthBuffer";
    depthTexture2.format = format;
    depthTexture2.type = type;
    depthTexture2.image.width = width;
    depthTexture2.image.height = height;
    this.createTexture(depthTexture2, { sampleCount: backend.parameters.sampleCount, width, height });
    return backend.get(depthTexture2).texture;
  }
  updateTexture(texture2, options) {
    const textureData = this.backend.get(texture2);
    const { textureDescriptorGPU } = textureData;
    if (texture2.isRenderTargetTexture || textureDescriptorGPU === void 0)
      return;
    if (texture2.isDataTexture) {
      this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture2.flipY);
    } else if (texture2.isDataArrayTexture || texture2.isData3DTexture) {
      for (let i = 0; i < options.image.depth; i++) {
        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture2.flipY, i);
      }
    } else if (texture2.isCompressedTexture) {
      this._copyCompressedBufferToTexture(texture2.mipmaps, textureData.texture, textureDescriptorGPU);
    } else if (texture2.isCubeTexture) {
      this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture2.flipY);
    } else if (texture2.isVideoTexture) {
      const video = texture2.source.data;
      textureData.externalTexture = video;
    } else {
      this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture2.flipY);
    }
    textureData.version = texture2.version;
    if (texture2.onUpdate) texture2.onUpdate(texture2);
  }
  async copyTextureToBuffer(texture2, x, y, width, height) {
    const device = this.backend.device;
    const textureData = this.backend.get(texture2);
    const textureGPU = textureData.texture;
    const format = textureData.textureDescriptorGPU.format;
    const bytesPerTexel = this._getBytesPerTexel(format);
    let bytesPerRow = width * bytesPerTexel;
    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
    const readBuffer = device.createBuffer(
      {
        size: width * height * bytesPerTexel,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    );
    const encoder = device.createCommandEncoder();
    encoder.copyTextureToBuffer(
      {
        texture: textureGPU,
        origin: { x, y }
      },
      {
        buffer: readBuffer,
        bytesPerRow
      },
      {
        width,
        height
      }
    );
    const typedArrayType = this._getTypedArrayType(format);
    device.queue.submit([encoder.finish()]);
    await readBuffer.mapAsync(GPUMapMode.READ);
    const buffer2 = readBuffer.getMappedRange();
    return new typedArrayType(buffer2);
  }
  _isEnvironmentTexture(texture2) {
    const mapping = texture2.mapping;
    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
  }
  _getDefaultTextureGPU(format) {
    let defaultTexture = this.defaultTexture[format];
    if (defaultTexture === void 0) {
      const texture2 = new Texture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, format });
      this.defaultTexture[format] = defaultTexture = texture2;
    }
    return this.backend.get(defaultTexture).texture;
  }
  _getDefaultCubeTextureGPU(format) {
    let defaultCubeTexture = this.defaultTexture[format];
    if (defaultCubeTexture === void 0) {
      const texture2 = new CubeTexture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, depth: 6 });
      this.defaultCubeTexture[format] = defaultCubeTexture = texture2;
    }
    return this.backend.get(defaultCubeTexture).texture;
  }
  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {
    for (let i = 0; i < 6; i++) {
      const image = images[i];
      const flipIndex = flipY === true ? _flipMap[i] : i;
      if (image.isDataTexture) {
        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
      } else {
        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
      }
    }
  }
  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {
    const device = this.backend.device;
    device.queue.copyExternalImageToTexture(
      {
        source: image
      },
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth }
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  _getPassUtils() {
    let passUtils = this._passUtils;
    if (passUtils === null) {
      this._passUtils = passUtils = new WebGPUTexturePassUtils_default(this.backend.device);
    }
    return passUtils;
  }
  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {
    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);
  }
  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
  }
  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth2 = 0) {
    const device = this.backend.device;
    const data = image.data;
    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
    const bytesPerRow = image.width * bytesPerTexel;
    device.queue.writeTexture(
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth }
      },
      data,
      {
        offset: image.width * image.height * bytesPerTexel * depth2,
        bytesPerRow
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
    const device = this.backend.device;
    const blockData = this._getBlockData(textureDescriptorGPU.format);
    for (let i = 0; i < mipmaps.length; i++) {
      const mipmap = mipmaps[i];
      const width = mipmap.width;
      const height = mipmap.height;
      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
      device.queue.writeTexture(
        {
          texture: textureGPU,
          mipLevel: i
        },
        mipmap.data,
        {
          offset: 0,
          bytesPerRow
        },
        {
          width: Math.ceil(width / blockData.width) * blockData.width,
          height: Math.ceil(height / blockData.width) * blockData.width,
          depthOrArrayLayers: 1
        }
      );
    }
  }
  _getBlockData(format) {
    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm) return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  _convertAddressMode(value) {
    let addressMode = GPUAddressMode.ClampToEdge;
    if (value === RepeatWrapping) {
      addressMode = GPUAddressMode.Repeat;
    } else if (value === MirroredRepeatWrapping) {
      addressMode = GPUAddressMode.MirrorRepeat;
    }
    return addressMode;
  }
  _convertFilterMode(value) {
    let filterMode = GPUFilterMode.Linear;
    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {
      filterMode = GPUFilterMode.Nearest;
    }
    return filterMode;
  }
  _getBytesPerTexel(format) {
    if (format === GPUTextureFormat.R8Unorm || format === GPUTextureFormat.R8Snorm || format === GPUTextureFormat.R8Uint || format === GPUTextureFormat.R8Sint) return 1;
    if (format === GPUTextureFormat.R16Uint || format === GPUTextureFormat.R16Sint || format === GPUTextureFormat.R16Float || format === GPUTextureFormat.RG8Unorm || format === GPUTextureFormat.RG8Snorm || format === GPUTextureFormat.RG8Uint || format === GPUTextureFormat.RG8Sint) return 2;
    if (format === GPUTextureFormat.R32Uint || format === GPUTextureFormat.R32Sint || format === GPUTextureFormat.R32Float || format === GPUTextureFormat.RG16Uint || format === GPUTextureFormat.RG16Sint || format === GPUTextureFormat.RG16Float || format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB || format === GPUTextureFormat.RGBA8Snorm || format === GPUTextureFormat.RGBA8Uint || format === GPUTextureFormat.RGBA8Sint || format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB || // Packed 32-bit formats
    format === GPUTextureFormat.RGB9E5UFloat || format === GPUTextureFormat.RGB10A2Unorm || format === GPUTextureFormat.RG11B10UFloat || format === GPUTextureFormat.Depth32Float || format === GPUTextureFormat.Depth24Plus || format === GPUTextureFormat.Depth24PlusStencil8 || format === GPUTextureFormat.Depth32FloatStencil8) return 4;
    if (format === GPUTextureFormat.RG32Uint || format === GPUTextureFormat.RG32Sint || format === GPUTextureFormat.RG32Float || format === GPUTextureFormat.RGBA16Uint || format === GPUTextureFormat.RGBA16Sint || format === GPUTextureFormat.RGBA16Float) return 8;
    if (format === GPUTextureFormat.RGBA32Uint || format === GPUTextureFormat.RGBA32Sint || format === GPUTextureFormat.RGBA32Float) return 16;
  }
  _getTypedArrayType(format) {
    if (format === GPUTextureFormat.R8Uint) return Uint8Array;
    if (format === GPUTextureFormat.R8Sint) return Int8Array;
    if (format === GPUTextureFormat.R8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.R8Snorm) return Int8Array;
    if (format === GPUTextureFormat.RG8Uint) return Uint8Array;
    if (format === GPUTextureFormat.RG8Sint) return Int8Array;
    if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.RG8Snorm) return Int8Array;
    if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;
    if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;
    if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;
    if (format === GPUTextureFormat.R16Uint) return Uint16Array;
    if (format === GPUTextureFormat.R16Sint) return Int16Array;
    if (format === GPUTextureFormat.RG16Uint) return Uint16Array;
    if (format === GPUTextureFormat.RG16Sint) return Int16Array;
    if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;
    if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;
    if (format === GPUTextureFormat.R16Float) return Float32Array;
    if (format === GPUTextureFormat.RG16Float) return Float32Array;
    if (format === GPUTextureFormat.RGBA16Float) return Float32Array;
    if (format === GPUTextureFormat.R32Uint) return Uint32Array;
    if (format === GPUTextureFormat.R32Sint) return Int32Array;
    if (format === GPUTextureFormat.R32Float) return Float32Array;
    if (format === GPUTextureFormat.RG32Uint) return Uint32Array;
    if (format === GPUTextureFormat.RG32Sint) return Int32Array;
    if (format === GPUTextureFormat.RG32Float) return Float32Array;
    if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;
    if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;
    if (format === GPUTextureFormat.RGBA32Float) return Float32Array;
    if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;
    if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
    if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
    if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
    if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
    if (format === GPUTextureFormat.Depth32Float) return Float32Array;
    if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;
    if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
    if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
  }
  _getDimension(texture2) {
    let dimension;
    if (texture2.isData3DTexture) {
      dimension = GPUTextureDimension.ThreeD;
    } else {
      dimension = GPUTextureDimension.TwoD;
    }
    return dimension;
  }
};
function getFormat(texture2, device = null) {
  const format = texture2.format;
  const type = texture2.type;
  const colorSpace = texture2.colorSpace;
  let formatGPU;
  if (texture2.isFramebufferTexture === true && texture2.type === UnsignedByteType) {
    formatGPU = GPUTextureFormat.BGRA8Unorm;
  } else if (texture2.isCompressedTexture === true) {
    switch (format) {
      case RGBA_S3TC_DXT1_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
        break;
      case RGBA_S3TC_DXT3_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
        break;
      case RGBA_S3TC_DXT5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
        break;
      case RGB_ETC2_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
        break;
      case RGBA_ETC2_EAC_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
        break;
      case RGBA_ASTC_4x4_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
        break;
      case RGBA_ASTC_5x4_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
        break;
      case RGBA_ASTC_5x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
        break;
      case RGBA_ASTC_6x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
        break;
      case RGBA_ASTC_6x6_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
        break;
      case RGBA_ASTC_8x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
        break;
      case RGBA_ASTC_8x6_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
        break;
      case RGBA_ASTC_8x8_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
        break;
      case RGBA_ASTC_10x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
        break;
      case RGBA_ASTC_10x6_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
        break;
      case RGBA_ASTC_10x8_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
        break;
      case RGBA_ASTC_10x10_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
        break;
      case RGBA_ASTC_12x10_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
        break;
      case RGBA_ASTC_12x12_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format);
    }
  } else {
    switch (format) {
      case RGBAFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RGBA8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RGBA16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RGBA16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedByteType:
            formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RGBA16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", type);
        }
        break;
      case RGBFormat:
        switch (type) {
          case UnsignedInt5999Type:
            formatGPU = GPUTextureFormat.RGB9E5UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", type);
        }
        break;
      case RedFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.R8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.R16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.R16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.R8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.R16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", type);
        }
        break;
      case RGFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RG8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RG16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RG16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.RG8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RG16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", type);
        }
        break;
      case DepthFormat:
        switch (type) {
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.Depth16Unorm;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.Depth24Plus;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", type);
        }
        break;
      case DepthStencilFormat:
        switch (type) {
          case UnsignedInt248Type:
            formatGPU = GPUTextureFormat.Depth24PlusStencil8;
            break;
          case FloatType:
            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
            }
            formatGPU = GPUTextureFormat.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", type);
        }
        break;
      case RedIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", type);
        }
        break;
      case RGIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", type);
        }
        break;
      case RGBAIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", type);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format);
    }
  }
  return formatGPU;
}
var WebGPUTextureUtils_default = WebGPUTextureUtils;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeFunction.js
var declarationRegexp2 = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i;
var propertiesRegexp2 = /[a-z_0-9]+|<(.*?)>+/ig;
var wgslTypeLib = {
  f32: "float"
};
var parse2 = (source) => {
  source = source.trim();
  const declaration = source.match(declarationRegexp2);
  if (declaration !== null && declaration.length === 4) {
    const inputsCode = declaration[2];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp2.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const name2 = propsMatches[i++][0];
      let type2 = propsMatches[i++][0];
      type2 = wgslTypeLib[type2] || type2;
      if (i < propsMatches.length && propsMatches[i][0].startsWith("<") === true)
        i++;
      inputs.push(new NodeFunctionInput_default(type2, name2));
    }
    const blockCode = source.substring(declaration[0].length);
    const name = declaration[1] !== void 0 ? declaration[1] : "";
    const type = declaration[3] || "void";
    return {
      type,
      inputs,
      name,
      inputsCode,
      blockCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a WGSL code.");
  }
};
var WGSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, inputsCode, blockCode } = parse2(source);
    super(type, inputs, name);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
  }
  getCode(name = this.name) {
    const type = this.type !== "void" ? "-> " + this.type : "";
    return `fn ${name} ( ${this.inputsCode.trim()} ) ${type}` + this.blockCode;
  }
};
var WGSLNodeFunction_default = WGSLNodeFunction;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeParser.js
var WGSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new WGSLNodeFunction_default(source);
  }
};
var WGSLNodeParser_default = WGSLNodeParser;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeBuilder.js
var GPUShaderStage = self.GPUShaderStage;
var gpuShaderStageLib = {
  "vertex": GPUShaderStage ? GPUShaderStage.VERTEX : 1,
  "fragment": GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
  "compute": GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};
var supports2 = {
  instance: true,
  storageBuffer: true
};
var wgslFnOpLib = {
  "^^": "threejs_xor"
};
var wgslTypeLib2 = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  imat2: "mat2x2<i32>",
  umat2: "mat2x2<u32>",
  bmat2: "mat2x2<bool>",
  mat3: "mat3x3<f32>",
  imat3: "mat3x3<i32>",
  umat3: "mat3x3<u32>",
  bmat3: "mat3x3<bool>",
  mat4: "mat4x4<f32>",
  imat4: "mat4x4<i32>",
  umat4: "mat4x4<u32>",
  bmat4: "mat4x4<bool>"
};
var wgslMethods = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "threejs_mod_float",
  mod_vec2: "threejs_mod_vec2",
  mod_vec3: "threejs_mod_vec3",
  mod_vec4: "threejs_mod_vec4",
  equals_bool: "threejs_equals_bool",
  equals_bvec2: "threejs_equals_bvec2",
  equals_bvec3: "threejs_equals_bvec3",
  equals_bvec4: "threejs_equals_bvec4",
  lessThanEqual: "threejs_lessThanEqual",
  greaterThan: "threejs_greaterThan",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
var wgslPolyfill = {
  threejs_xor: new CodeNode_default(`
fn threejs_xor( a : bool, b : bool ) -> bool {

	return ( a || b ) && !( a && b );

}
`),
  lessThanEqual: new CodeNode_default(`
fn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );

}
`),
  greaterThan: new CodeNode_default(`
fn threejs_greaterThan( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x > b.x, a.y > b.y, a.z > b.z );

}
`),
  mod_float: new CodeNode_default("fn threejs_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new CodeNode_default("fn threejs_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new CodeNode_default("fn threejs_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new CodeNode_default("fn threejs_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new CodeNode_default("fn threejs_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new CodeNode_default("fn threejs_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new CodeNode_default("fn threejs_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new CodeNode_default("fn threejs_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping: new CodeNode_default(`
fn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`)
};
var WGSLNodeBuilder = class extends NodeBuilder_default {
  constructor(object, renderer, scene = null) {
    super(object, renderer, new WGSLNodeParser_default(), scene);
    this.uniformGroups = {};
    this.builtins = {};
  }
  needsColorSpaceToLinear(texture2) {
    return texture2.isVideoTexture === true && texture2.colorSpace !== NoColorSpace;
  }
  _generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
      } else {
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
      }
    } else {
      return this.generateTextureLod(texture2, textureProperty, uvSnippet);
    }
  }
  _generateVideoSample(textureProperty, uvSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;
    } else {
      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);
    }
  }
  _generateTextureSampleLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment" && this.isUnfilterable(texture2) === false) {
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else {
      return this.generateTextureLod(texture2, textureProperty, uvSnippet, levelSnippet);
    }
  }
  generateTextureLod(texture2, textureProperty, uvSnippet, levelSnippet = "0") {
    this._include("repeatWrapping");
    const dimension = `textureDimensions( ${textureProperty}, 0 )`;
    return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${levelSnippet} ) )`;
  }
  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = "0u") {
    if (depthSnippet) {
      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${levelSnippet} )`;
    } else {
      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
    }
  }
  generateTextureStore(texture2, textureProperty, uvIndexSnippet, valueSnippet) {
    return `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
  }
  isUnfilterable(texture2) {
    return this.getComponentTypeFromTexture(texture2) !== "float" || texture2.isDataTexture === true && texture2.type === FloatType;
  }
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (texture2.isVideoTexture === true) {
      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);
    } else if (this.isUnfilterable(texture2)) {
      snippet = this.generateTextureLod(texture2, textureProperty, uvSnippet, "0", depthSnippet, shaderStage);
    } else {
      snippet = this._generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, shaderStage);
    }
    return snippet;
  }
  generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
    } else {
      console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);
    }
  }
  generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
    } else {
      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (texture2.isVideoTexture === true) {
      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);
    } else {
      snippet = this._generateTextureSampleLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage);
    }
    return snippet;
  }
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeVarying === true && node.needsInterpolation === true) {
      if (shaderStage === "vertex") {
        return `varyings.${node.name}`;
      }
    } else if (node.isNodeUniform === true) {
      const name = node.name;
      const type = node.type;
      if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") {
        return name;
      } else if (type === "buffer" || type === "storageBuffer") {
        return `NodeBuffer_${node.id}.${name}`;
      } else {
        return node.groupNode.name + "." + name;
      }
    }
    return super.getPropertyName(node);
  }
  getOutputStructName() {
    return "output";
  }
  _getUniformGroupCount(shaderStage) {
    return Object.keys(this.uniforms[shaderStage]).length;
  }
  getFunctionOperator(op) {
    const fnOp = wgslFnOpLib[op];
    if (fnOp !== void 0) {
      this._include(fnOp);
      return fnOp;
    }
    return null;
  }
  getStorageAccess(node) {
    if (node.isStorageTextureNode) {
      switch (node.access) {
        case GPUStorageTextureAccess.ReadOnly: {
          return "read";
        }
        case GPUStorageTextureAccess.WriteOnly: {
          return "write";
        }
        default: {
          return "read_write";
        }
      }
    } else {
      return "read_write";
    }
  }
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    if (nodeData.uniformGPU === void 0) {
      let uniformGPU;
      const bindings = this.bindings[shaderStage];
      if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") {
        let texture2 = null;
        if (type === "texture" || type === "storageTexture") {
          texture2 = new NodeSampledTexture(uniformNode.name, uniformNode.node, node.access ? node.access : null);
        } else if (type === "cubeTexture") {
          texture2 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, node.access ? node.access : null);
        } else if (type === "texture3D") {
          texture2 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, node.access ? node.access : null);
        }
        texture2.store = node.isStorageTextureNode === true;
        texture2.setVisibility(gpuShaderStageLib[shaderStage]);
        if (shaderStage === "fragment" && this.isUnfilterable(node.value) === false && texture2.store === false) {
          const sampler2 = new NodeSampler_default(`${uniformNode.name}_sampler`, uniformNode.node);
          sampler2.setVisibility(gpuShaderStageLib[shaderStage]);
          bindings.push(sampler2, texture2);
          uniformGPU = [sampler2, texture2];
        } else {
          bindings.push(texture2);
          uniformGPU = [texture2];
        }
      } else if (type === "buffer" || type === "storageBuffer") {
        const bufferClass = type === "storageBuffer" ? NodeStorageBuffer_default : NodeUniformBuffer_default;
        const buffer2 = new bufferClass(node);
        buffer2.setVisibility(gpuShaderStageLib[shaderStage]);
        bindings.push(buffer2);
        uniformGPU = buffer2;
      } else {
        const group = node.groupNode;
        const groupName = group.name;
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup_default(groupName, group);
          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
      if (shaderStage === "vertex") {
        this.bindingsOffset["fragment"] = bindings.length;
      }
    }
    return uniformNode;
  }
  isReference(type) {
    return super.isReference(type) || type === "texture_2d" || type === "texture_cube" || type === "texture_depth_2d" || type === "texture_storage_2d" || type === "texture_3d";
  }
  getBuiltin(name, property2, type, shaderStage = this.shaderStage) {
    const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = /* @__PURE__ */ new Map());
    if (map.has(name) === false) {
      map.set(name, {
        name,
        property: property2,
        type
      });
    }
    return property2;
  }
  getVertexIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute");
    }
    return "vertexIndex";
  }
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(input.name + " : " + this.getType(input.type));
    }
    const code2 = `fn ${layout.name}( ${parameters.join(", ")} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
	return ${flowData.result};

}`;
    return code2;
  }
  getInstanceIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute");
    }
    return "instanceIndex";
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xyz";
  }
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  isFlipY() {
    return false;
  }
  getBuiltins(shaderStage) {
    const snippets = [];
    const builtins = this.builtins[shaderStage];
    if (builtins !== void 0) {
      for (const { name, property: property2, type } of builtins.values()) {
        snippets.push(`@builtin( ${name} ) ${property2} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  getAttributes(shaderStage) {
    const snippets = [];
    if (shaderStage === "compute") {
      this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute");
    }
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const builtins = this.getBuiltins("attribute");
      if (builtins) snippets.push(builtins);
      const attributes = this.getAttributesArray();
      for (let index = 0, length2 = attributes.length; index < length2; index++) {
        const attribute2 = attributes[index];
        const name = attribute2.name;
        const type = this.getType(attribute2.type);
        snippets.push(`@location( ${index} ) ${name} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  getStructMembers(struct) {
    const snippets = [];
    const members = struct.getMemberTypes();
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      snippets.push(`	@location( ${i} ) m${i} : ${member}<f32>`);
    }
    const builtins = this.getBuiltins("output");
    if (builtins) snippets.push(builtins);
    return snippets.join(",\n");
  }
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    for (let index = 0, length2 = structs.length; index < length2; index++) {
      const struct = structs[index];
      const name = struct.name;
      let snippet = `struct ${name} {
`;
      snippet += this.getStructMembers(struct);
      snippet += "\n}";
      snippets.push(snippet);
      snippets.push(`
var<private> output : ${name};

`);
    }
    return snippets.join("\n\n");
  }
  getVar(type, name) {
    return `var ${name} : ${this.getType(type)}`;
  }
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`	${this.getVar(variable.type, variable.name)};`);
      }
    }
    return `
${snippets.join("\n")}
`;
  }
  getVaryings(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
    }
    if (shaderStage === "vertex" || shaderStage === "fragment") {
      const varyings = this.varyings;
      const vars = this.vars[shaderStage];
      for (let index = 0; index < varyings.length; index++) {
        const varying2 = varyings[index];
        if (varying2.needsInterpolation) {
          let attributesSnippet = `@location( ${index} )`;
          if (/^(int|uint|ivec|uvec)/.test(varying2.type)) {
            attributesSnippet += " @interpolate( flat )";
          }
          snippets.push(`${attributesSnippet} ${varying2.name} : ${this.getType(varying2.type)}`);
        } else if (shaderStage === "vertex" && vars.includes(varying2) === false) {
          vars.push(varying2);
        }
      }
    }
    const builtins = this.getBuiltins(shaderStage);
    if (builtins) snippets.push(builtins);
    const code2 = snippets.join(",\n	");
    return shaderStage === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + code2) : code2;
  }
  getUniforms(shaderStage) {
    const uniforms2 = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const bufferSnippets = [];
    const structSnippets = [];
    const uniformGroups = {};
    let index = this.bindingsOffset[shaderStage];
    for (const uniform2 of uniforms2) {
      if (uniform2.type === "texture" || uniform2.type === "cubeTexture" || uniform2.type === "storageTexture" || uniform2.type === "texture3D") {
        const texture2 = uniform2.node.value;
        if (shaderStage === "fragment" && this.isUnfilterable(texture2) === false && uniform2.node.isStorageTextureNode !== true) {
          if (texture2.isDepthTexture === true && texture2.compareFunction !== null) {
            bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform2.name}_sampler : sampler_comparison;`);
          } else {
            bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform2.name}_sampler : sampler;`);
          }
        }
        let textureType;
        if (texture2.isCubeTexture === true) {
          textureType = "texture_cube<f32>";
        } else if (texture2.isDataArrayTexture === true) {
          textureType = "texture_2d_array<f32>";
        } else if (texture2.isDepthTexture === true) {
          textureType = "texture_depth_2d";
        } else if (texture2.isVideoTexture === true) {
          textureType = "texture_external";
        } else if (texture2.isData3DTexture === true) {
          textureType = "texture_3d<f32>";
        } else if (uniform2.node.isStorageTextureNode === true) {
          const format = getFormat(texture2);
          const access = this.getStorageAccess(uniform2.node);
          textureType = `texture_storage_2d<${format}, ${access}>`;
        } else {
          const componentPrefix = this.getComponentTypeFromTexture(texture2).charAt(0);
          textureType = `texture_2d<${componentPrefix}32>`;
        }
        bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform2.name} : ${textureType};`);
      } else if (uniform2.type === "buffer" || uniform2.type === "storageBuffer") {
        const bufferNode = uniform2.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? ", " + bufferCount : "";
        const bufferSnippet = `	${uniform2.name} : array< ${bufferType}${bufferCountSnippet} >
`;
        const bufferAccessMode = bufferNode.isStorageBufferNode ? "storage,read_write" : "uniform";
        bufferSnippets.push(this._getWGSLStructBinding("NodeBuffer_" + bufferNode.id, bufferSnippet, bufferAccessMode, index++));
      } else {
        const vectorType = this.getType(this.getVectorType(uniform2.type));
        const groupName = uniform2.groupNode.name;
        const group = uniformGroups[groupName] || (uniformGroups[groupName] = {
          index: index++,
          snippets: []
        });
        group.snippets.push(`	${uniform2.name} : ${vectorType}`);
      }
    }
    for (const name in uniformGroups) {
      const group = uniformGroups[name];
      structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(",\n"), "uniform", group.index));
    }
    let code2 = bindingSnippets.join("\n");
    code2 += bufferSnippets.join("\n");
    code2 += structSnippets.join("\n");
    return code2;
  }
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    for (const shaderStage in shadersData) {
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      const outputNode = mainNode.outputNode;
      const isOutputStruct = outputNode !== void 0 && outputNode.isOutputStructNode === true;
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0) flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n\n	";
          if (shaderStage === "vertex") {
            flow += `varyings.Vertex = ${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (isOutputStruct) {
              stageData.returnType = outputNode.nodeType;
              flow += `return ${flowSlotData.result};`;
            } else {
              let structSnippet = "	@location(0) color: vec4<f32>";
              const builtins = this.getBuiltins("output");
              if (builtins) structSnippet += ",\n	" + builtins;
              stageData.returnType = "OutputStruct";
              stageData.structs += this._getWGSLStruct("OutputStruct", structSnippet);
              stageData.structs += "\nvar<private> output : OutputStruct;\n\n";
              flow += `output.color = ${flowSlotData.result};

	return output;`;
            }
          }
        }
      }
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(", "));
    }
  }
  getMethod(method, output2 = null) {
    let wgslMethod;
    if (output2 !== null) {
      wgslMethod = this._getWGSLMethod(method + "_" + output2);
    }
    if (wgslMethod === void 0) {
      wgslMethod = this._getWGSLMethod(method);
    }
    return wgslMethod || method;
  }
  getType(type) {
    return wgslTypeLib2[type] || type;
  }
  isAvailable(name) {
    return supports2[name] === true;
  }
  _getWGSLMethod(method) {
    if (wgslPolyfill[method] !== void 0) {
      this._include(method);
    }
    return wgslMethods[method];
  }
  _include(name) {
    const codeNode = wgslPolyfill[name];
    codeNode.build(this);
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(codeNode);
    }
    return codeNode;
  }
  _getWGSLVertexCode(shaderData) {
    return `${this.getSignature()}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
  }
  _getWGSLFragmentCode(shaderData) {
    return `${this.getSignature()}

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  _getWGSLComputeCode(shaderData, workgroupSize) {
    return `${this.getSignature()}
// system
var<private> instanceIndex : u32;

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x;

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  _getWGSLStruct(name, vars) {
    return `
struct ${name} {
${vars}
};`;
  }
  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {
    const structName = name + "Struct";
    const structSnippet = this._getWGSLStruct(structName, vars);
    return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
  }
};
var WGSLNodeBuilder_default = WGSLNodeBuilder;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUUtils.js
var WebGPUUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  getCurrentDepthStencilFormat(renderContext) {
    let format;
    if (renderContext.depthTexture !== null) {
      format = this.getTextureFormatGPU(renderContext.depthTexture);
    } else if (renderContext.depth && renderContext.stencil) {
      format = GPUTextureFormat.Depth24PlusStencil8;
    } else if (renderContext.depth) {
      format = GPUTextureFormat.Depth24Plus;
    }
    return format;
  }
  getTextureFormatGPU(texture2) {
    return this.backend.get(texture2).texture.format;
  }
  getCurrentColorFormat(renderContext) {
    let format;
    if (renderContext.textures !== null) {
      format = this.getTextureFormatGPU(renderContext.textures[0]);
    } else {
      format = GPUTextureFormat.BGRA8Unorm;
    }
    return format;
  }
  getCurrentColorSpace(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.textures[0].colorSpace;
    }
    return this.backend.renderer.outputColorSpace;
  }
  getPrimitiveTopology(object, material) {
    if (object.isPoints) return GPUPrimitiveTopology.PointList;
    else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;
    else if (object.isLine) return GPUPrimitiveTopology.LineStrip;
    else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;
  }
  getSampleCount(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.sampleCount;
    }
    return this.backend.parameters.sampleCount;
  }
};
var WebGPUUtils_default = WebGPUUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUAttributeUtils.js
var typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
var typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Float16BufferAttribute, ["float16"]]
]);
var typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
var WebGPUAttributeUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createAttribute(attribute2, usage) {
    const bufferAttribute2 = this._getBufferAttribute(attribute2);
    const backend = this.backend;
    const bufferData = backend.get(bufferAttribute2);
    let buffer2 = bufferData.buffer;
    if (buffer2 === void 0) {
      const device = backend.device;
      let array = bufferAttribute2.array;
      if (attribute2.normalized === false && (array.constructor === Int16Array || array.constructor === Uint16Array)) {
        const tempArray = new Uint32Array(array.length);
        for (let i = 0; i < array.length; i++) {
          tempArray[i] = array[i];
        }
        array = tempArray;
      }
      bufferAttribute2.array = array;
      if ((bufferAttribute2.isStorageBufferAttribute || bufferAttribute2.isStorageInstancedBufferAttribute) && bufferAttribute2.itemSize === 3) {
        array = new array.constructor(bufferAttribute2.count * 4);
        for (let i = 0; i < bufferAttribute2.count; i++) {
          array.set(bufferAttribute2.array.subarray(i * 3, i * 3 + 3), i * 4);
        }
        bufferAttribute2.itemSize = 4;
        bufferAttribute2.array = array;
      }
      const size = array.byteLength + (4 - array.byteLength % 4) % 4;
      buffer2 = device.createBuffer({
        label: bufferAttribute2.name,
        size,
        usage,
        mappedAtCreation: true
      });
      new array.constructor(buffer2.getMappedRange()).set(array);
      buffer2.unmap();
      bufferData.buffer = buffer2;
    }
  }
  updateAttribute(attribute2) {
    const bufferAttribute2 = this._getBufferAttribute(attribute2);
    const backend = this.backend;
    const device = backend.device;
    const buffer2 = backend.get(bufferAttribute2).buffer;
    const array = bufferAttribute2.array;
    const updateRanges = bufferAttribute2.updateRanges;
    if (updateRanges.length === 0) {
      device.queue.writeBuffer(
        buffer2,
        0,
        array,
        0
      );
    } else {
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range2 = updateRanges[i];
        device.queue.writeBuffer(
          buffer2,
          0,
          array,
          range2.start * array.BYTES_PER_ELEMENT,
          range2.count * array.BYTES_PER_ELEMENT
        );
      }
      bufferAttribute2.clearUpdateRanges();
    }
  }
  createShaderVertexBuffers(renderObject) {
    const attributes = renderObject.getAttributes();
    const vertexBuffers = /* @__PURE__ */ new Map();
    for (let slot = 0; slot < attributes.length; slot++) {
      const geometryAttribute = attributes[slot];
      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
      const bufferAttribute2 = this._getBufferAttribute(geometryAttribute);
      let vertexBufferLayout = vertexBuffers.get(bufferAttribute2);
      if (vertexBufferLayout === void 0) {
        let arrayStride, stepMode;
        if (geometryAttribute.isInterleavedBufferAttribute === true) {
          arrayStride = geometryAttribute.data.stride * bytesPerElement;
          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        } else {
          arrayStride = geometryAttribute.itemSize * bytesPerElement;
          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        }
        if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {
          arrayStride = 4;
        }
        vertexBufferLayout = {
          arrayStride,
          attributes: [],
          stepMode
        };
        vertexBuffers.set(bufferAttribute2, vertexBufferLayout);
      }
      const format = this._getVertexFormat(geometryAttribute);
      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;
      vertexBufferLayout.attributes.push({
        shaderLocation: slot,
        offset,
        format
      });
    }
    return Array.from(vertexBuffers.values());
  }
  destroyAttribute(attribute2) {
    const backend = this.backend;
    const data = backend.get(this._getBufferAttribute(attribute2));
    data.buffer.destroy();
    backend.delete(attribute2);
  }
  async getArrayBufferAsync(attribute2) {
    const backend = this.backend;
    const device = backend.device;
    const data = backend.get(this._getBufferAttribute(attribute2));
    const bufferGPU = data.buffer;
    const size = bufferGPU.size;
    let readBufferGPU = data.readBuffer;
    let needsUnmap = true;
    if (readBufferGPU === void 0) {
      readBufferGPU = device.createBuffer({
        label: attribute2.name,
        size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      needsUnmap = false;
      data.readBuffer = readBufferGPU;
    }
    const cmdEncoder = device.createCommandEncoder({});
    cmdEncoder.copyBufferToBuffer(
      bufferGPU,
      0,
      readBufferGPU,
      0,
      size
    );
    if (needsUnmap) readBufferGPU.unmap();
    const gpuCommands = cmdEncoder.finish();
    device.queue.submit([gpuCommands]);
    await readBufferGPU.mapAsync(GPUMapMode.READ);
    const arrayBuffer = readBufferGPU.getMappedRange();
    return arrayBuffer;
  }
  _getVertexFormat(geometryAttribute) {
    const { itemSize, normalized } = geometryAttribute;
    const ArrayType = geometryAttribute.array.constructor;
    const AttributeType2 = geometryAttribute.constructor;
    let format;
    if (itemSize == 1) {
      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
    } else {
      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType2) || typedArraysToVertexFormatPrefix.get(ArrayType);
      const prefix = prefixOptions[normalized ? 1 : 0];
      if (prefix) {
        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
        if (paddedItemSize % 1) {
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        }
        format = `${prefix}x${paddedItemSize}`;
      }
    }
    if (!format) {
      console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet.");
    }
    return format;
  }
  _getBufferAttribute(attribute2) {
    if (attribute2.isInterleavedBufferAttribute) attribute2 = attribute2.data;
    return attribute2;
  }
};
var WebGPUAttributeUtils_default = WebGPUAttributeUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUBindingUtils.js
var WebGPUBindingUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createBindingsLayout(bindings) {
    const backend = this.backend;
    const device = backend.device;
    const entries = [];
    let index = 0;
    for (const binding of bindings) {
      const bindingGPU = {
        binding: index++,
        visibility: binding.visibility
      };
      if (binding.isUniformBuffer || binding.isStorageBuffer) {
        const buffer2 = {};
        if (binding.isStorageBuffer) {
          buffer2.type = GPUBufferBindingType.Storage;
        }
        bindingGPU.buffer = buffer2;
      } else if (binding.isSampler) {
        const sampler2 = {};
        if (binding.texture.isDepthTexture) {
          if (binding.texture.compareFunction !== null) {
            sampler2.type = "comparison";
          }
        }
        bindingGPU.sampler = sampler2;
      } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {
        bindingGPU.externalTexture = {};
      } else if (binding.isSampledTexture && binding.store) {
        const format = this.backend.get(binding.texture).texture.format;
        const access = binding.access;
        bindingGPU.storageTexture = { format, access };
      } else if (binding.isSampledTexture) {
        const texture2 = {};
        if (binding.texture.isDepthTexture) {
          texture2.sampleType = GPUTextureSampleType.Depth;
        } else if (binding.texture.isDataTexture) {
          const type = binding.texture.type;
          if (type === IntType) {
            texture2.sampleType = GPUTextureSampleType.SInt;
          } else if (type === UnsignedIntType) {
            texture2.sampleType = GPUTextureSampleType.UInt;
          } else if (type === FloatType) {
            texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
          }
        }
        if (binding.isSampledCubeTexture) {
          texture2.viewDimension = GPUTextureViewDimension.Cube;
        } else if (binding.texture.isDataArrayTexture) {
          texture2.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.isSampledTexture3D) {
          texture2.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.texture = texture2;
      } else {
        console.error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
      }
      entries.push(bindingGPU);
    }
    return device.createBindGroupLayout({ entries });
  }
  createBindings(bindings) {
    const backend = this.backend;
    const bindingsData = backend.get(bindings);
    const bindLayoutGPU = this.createBindingsLayout(bindings);
    const bindGroupGPU = this.createBindGroup(bindings, bindLayoutGPU);
    bindingsData.layout = bindLayoutGPU;
    bindingsData.group = bindGroupGPU;
    bindingsData.bindings = bindings;
  }
  updateBinding(binding) {
    const backend = this.backend;
    const device = backend.device;
    const buffer2 = binding.buffer;
    const bufferGPU = backend.get(binding).buffer;
    device.queue.writeBuffer(bufferGPU, 0, buffer2, 0);
  }
  createBindGroup(bindings, layoutGPU) {
    const backend = this.backend;
    const device = backend.device;
    let bindingPoint = 0;
    const entriesGPU = [];
    for (const binding of bindings) {
      if (binding.isUniformBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const byteLength = binding.byteLength;
          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
          const bufferGPU = device.createBuffer({
            label: "bindingBuffer_" + binding.name,
            size: byteLength,
            usage
          });
          bindingData.buffer = bufferGPU;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isStorageBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const attribute2 = binding.attribute;
          bindingData.buffer = backend.get(attribute2).buffer;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isSampler) {
        const textureGPU = backend.get(binding.texture);
        entriesGPU.push({ binding: bindingPoint, resource: textureGPU.sampler });
      } else if (binding.isSampledTexture) {
        const textureData = backend.get(binding.texture);
        let dimensionViewGPU;
        if (binding.isSampledCubeTexture) {
          dimensionViewGPU = GPUTextureViewDimension.Cube;
        } else if (binding.isSampledTexture3D) {
          dimensionViewGPU = GPUTextureViewDimension.ThreeD;
        } else if (binding.texture.isDataArrayTexture) {
          dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
        } else {
          dimensionViewGPU = GPUTextureViewDimension.TwoD;
        }
        let resourceGPU;
        if (textureData.externalTexture !== void 0) {
          resourceGPU = device.importExternalTexture({ source: textureData.externalTexture });
        } else {
          const aspectGPU = GPUTextureAspect.All;
          resourceGPU = textureData.texture.createView({ aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount: binding.store ? 1 : textureData.mipLevelCount });
        }
        entriesGPU.push({ binding: bindingPoint, resource: resourceGPU });
      }
      bindingPoint++;
    }
    return device.createBindGroup({
      layout: layoutGPU,
      entries: entriesGPU
    });
  }
};
var WebGPUBindingUtils_default = WebGPUBindingUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUPipelineUtils.js
var WebGPUPipelineUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  _getSampleCount(renderObjectContext) {
    let sampleCount = this.backend.utils.getSampleCount(renderObjectContext);
    if (sampleCount > 1) {
      sampleCount = Math.pow(2, Math.floor(Math.log2(sampleCount)));
      if (sampleCount === 2) {
        sampleCount = 4;
      }
    }
    return sampleCount;
  }
  createRenderPipeline(renderObject, promises) {
    const { object, material, geometry, pipeline } = renderObject;
    const { vertexProgram, fragmentProgram } = pipeline;
    const backend = this.backend;
    const device = backend.device;
    const utils = backend.utils;
    const pipelineData = backend.get(pipeline);
    const bindingsData = backend.get(renderObject.getBindings());
    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);
    let blending;
    if (material.transparent === true && material.blending !== NoBlending) {
      blending = this._getBlending(material);
    }
    let stencilFront = {};
    if (material.stencilWrite === true) {
      stencilFront = {
        compare: this._getStencilCompare(material),
        failOp: this._getStencilOperation(material.stencilFail),
        depthFailOp: this._getStencilOperation(material.stencilZFail),
        passOp: this._getStencilOperation(material.stencilZPass)
      };
    }
    const colorWriteMask = this._getColorWriteMask(material);
    const targets = [];
    if (renderObject.context.textures !== null) {
      const textures = renderObject.context.textures;
      for (let i = 0; i < textures.length; i++) {
        const colorFormat = utils.getTextureFormatGPU(textures[i]);
        targets.push({
          format: colorFormat,
          blend: blending,
          writeMask: colorWriteMask
        });
      }
    } else {
      const colorFormat = utils.getCurrentColorFormat(renderObject.context);
      targets.push({
        format: colorFormat,
        blend: blending,
        writeMask: colorWriteMask
      });
    }
    const vertexModule = backend.get(vertexProgram).module;
    const fragmentModule = backend.get(fragmentProgram).module;
    const primitiveState = this._getPrimitiveState(object, geometry, material);
    const depthCompare = this._getDepthCompare(material);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
    const sampleCount = this._getSampleCount(renderObject.context);
    const pipelineDescriptor = {
      label: "renderPipeline",
      vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
      fragment: Object.assign({}, fragmentModule, { targets }),
      primitive: primitiveState,
      depthStencil: {
        format: depthStencilFormat,
        depthWriteEnabled: material.depthWrite,
        depthCompare,
        stencilFront,
        stencilBack: {},
        // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
        stencilReadMask: material.stencilFuncMask,
        stencilWriteMask: material.stencilWriteMask
      },
      multisample: {
        count: sampleCount,
        alphaToCoverageEnabled: material.alphaToCoverage
      },
      layout: device.createPipelineLayout({
        bindGroupLayouts: [bindingsData.layout]
      })
    };
    if (promises === null) {
      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
    } else {
      const p = new Promise((resolve) => {
        device.createRenderPipelineAsync(pipelineDescriptor).then((pipeline2) => {
          pipelineData.pipeline = pipeline2;
          resolve();
        });
      });
      promises.push(p);
    }
  }
  createBundleEncoder(renderContext, renderObject) {
    const backend = this.backend;
    const { utils, device } = backend;
    const renderContextData = backend.get(renderContext);
    const renderObjectData = backend.get(renderObject);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);
    const colorFormat = utils.getCurrentColorFormat(renderContext);
    const sampleCount = this._getSampleCount(renderObject.context);
    const descriptor = {
      label: "renderBundleEncoder",
      colorFormats: [colorFormat],
      depthStencilFormat,
      sampleCount
    };
    const bundleEncoder = device.createRenderBundleEncoder(descriptor);
    renderObjectData.bundleEncoder = bundleEncoder;
    renderContextData.currentSets = { attributes: {} };
    renderContextData._renderBundleViewport = renderContext.width + "_" + renderContext.height;
    return bundleEncoder;
  }
  createComputePipeline(pipeline, bindings) {
    const backend = this.backend;
    const device = backend.device;
    const computeProgram = backend.get(pipeline.computeProgram).module;
    const pipelineGPU = backend.get(pipeline);
    const bindingsData = backend.get(bindings);
    pipelineGPU.pipeline = device.createComputePipeline({
      compute: computeProgram,
      layout: device.createPipelineLayout({
        bindGroupLayouts: [bindingsData.layout]
      })
    });
  }
  _getBlending(material) {
    let color2, alpha;
    const blending = material.blending;
    const blendSrc = material.blendSrc;
    const blendDst = material.blendDst;
    const blendEquation = material.blendEquation;
    if (blending === CustomBlending) {
      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;
      color2 = {
        srcFactor: this._getBlendFactor(blendSrc),
        dstFactor: this._getBlendFactor(blendDst),
        operation: this._getBlendOperation(blendEquation)
      };
      alpha = {
        srcFactor: this._getBlendFactor(blendSrcAlpha),
        dstFactor: this._getBlendFactor(blendDstAlpha),
        operation: this._getBlendOperation(blendEquationAlpha)
      };
    } else {
      const premultipliedAlpha = material.premultipliedAlpha;
      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
        color2 = {
          srcFactor: srcRGB,
          dstFactor: dstRGB,
          operation: GPUBlendOperation.Add
        };
        alpha = {
          srcFactor: srcAlpha,
          dstFactor: dstAlpha,
          operation: GPUBlendOperation.Add
        };
      };
      if (premultipliedAlpha) {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
          case MultiplyBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);
            break;
        }
      } else {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
          case MultiplyBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);
            break;
        }
      }
    }
    if (color2 !== void 0 && alpha !== void 0) {
      return { color: color2, alpha };
    } else {
      console.error("THREE.WebGPURenderer: Invalid blending: ", blending);
    }
  }
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case ZeroFactor:
        blendFactor = GPUBlendFactor.Zero;
        break;
      case OneFactor:
        blendFactor = GPUBlendFactor.One;
        break;
      case SrcColorFactor:
        blendFactor = GPUBlendFactor.Src;
        break;
      case OneMinusSrcColorFactor:
        blendFactor = GPUBlendFactor.OneMinusSrc;
        break;
      case SrcAlphaFactor:
        blendFactor = GPUBlendFactor.SrcAlpha;
        break;
      case OneMinusSrcAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case DstColorFactor:
        blendFactor = GPUBlendFactor.Dst;
        break;
      case OneMinusDstColorFactor:
        blendFactor = GPUBlendFactor.OneMinusDstColor;
        break;
      case DstAlphaFactor:
        blendFactor = GPUBlendFactor.DstAlpha;
        break;
      case OneMinusDstAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusDstAlpha;
        break;
      case SrcAlphaSaturateFactor:
        blendFactor = GPUBlendFactor.SrcAlphaSaturated;
        break;
      case BlendColorFactor:
        blendFactor = GPUBlendFactor.Constant;
        break;
      case OneMinusBlendColorFactor:
        blendFactor = GPUBlendFactor.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", blend);
    }
    return blendFactor;
  }
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case NeverStencilFunc:
        stencilCompare = GPUCompareFunction.Never;
        break;
      case AlwaysStencilFunc:
        stencilCompare = GPUCompareFunction.Always;
        break;
      case LessStencilFunc:
        stencilCompare = GPUCompareFunction.Less;
        break;
      case LessEqualStencilFunc:
        stencilCompare = GPUCompareFunction.LessEqual;
        break;
      case EqualStencilFunc:
        stencilCompare = GPUCompareFunction.Equal;
        break;
      case GreaterEqualStencilFunc:
        stencilCompare = GPUCompareFunction.GreaterEqual;
        break;
      case GreaterStencilFunc:
        stencilCompare = GPUCompareFunction.Greater;
        break;
      case NotEqualStencilFunc:
        stencilCompare = GPUCompareFunction.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", stencilFunc);
    }
    return stencilCompare;
  }
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case KeepStencilOp:
        stencilOperation = GPUStencilOperation.Keep;
        break;
      case ZeroStencilOp:
        stencilOperation = GPUStencilOperation.Zero;
        break;
      case ReplaceStencilOp:
        stencilOperation = GPUStencilOperation.Replace;
        break;
      case InvertStencilOp:
        stencilOperation = GPUStencilOperation.Invert;
        break;
      case IncrementStencilOp:
        stencilOperation = GPUStencilOperation.IncrementClamp;
        break;
      case DecrementStencilOp:
        stencilOperation = GPUStencilOperation.DecrementClamp;
        break;
      case IncrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.IncrementWrap;
        break;
      case DecrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", stencilOperation);
    }
    return stencilOperation;
  }
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case AddEquation:
        blendOperation = GPUBlendOperation.Add;
        break;
      case SubtractEquation:
        blendOperation = GPUBlendOperation.Subtract;
        break;
      case ReverseSubtractEquation:
        blendOperation = GPUBlendOperation.ReverseSubtract;
        break;
      case MinEquation:
        blendOperation = GPUBlendOperation.Min;
        break;
      case MaxEquation:
        blendOperation = GPUBlendOperation.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", blendEquation);
    }
    return blendOperation;
  }
  _getPrimitiveState(object, geometry, material) {
    const descriptor = {};
    const utils = this.backend.utils;
    descriptor.topology = utils.getPrimitiveTopology(object, material);
    if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {
      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
    }
    switch (material.side) {
      case FrontSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.Back;
        break;
      case BackSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.Front;
        break;
      case DoubleSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", material.side);
        break;
    }
    return descriptor;
  }
  _getColorWriteMask(material) {
    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
  }
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case NeverDepth:
          depthCompare = GPUCompareFunction.Never;
          break;
        case AlwaysDepth:
          depthCompare = GPUCompareFunction.Always;
          break;
        case LessDepth:
          depthCompare = GPUCompareFunction.Less;
          break;
        case LessEqualDepth:
          depthCompare = GPUCompareFunction.LessEqual;
          break;
        case EqualDepth:
          depthCompare = GPUCompareFunction.Equal;
          break;
        case GreaterEqualDepth:
          depthCompare = GPUCompareFunction.GreaterEqual;
          break;
        case GreaterDepth:
          depthCompare = GPUCompareFunction.Greater;
          break;
        case NotEqualDepth:
          depthCompare = GPUCompareFunction.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", depthFunc);
      }
    }
    return depthCompare;
  }
};
var WebGPUPipelineUtils_default = WebGPUPipelineUtils;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBackend.js
var WebGPUBackend = class extends Backend_default {
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGPUBackend = true;
    this.parameters.alpha = parameters.alpha === void 0 ? true : parameters.alpha;
    this.parameters.antialias = parameters.antialias === true;
    if (this.parameters.antialias === true) {
      this.parameters.sampleCount = parameters.sampleCount === void 0 ? 4 : parameters.sampleCount;
    } else {
      this.parameters.sampleCount = 1;
    }
    this.parameters.requiredLimits = parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
    this.trackTimestamp = parameters.trackTimestamp === true;
    this.device = null;
    this.context = null;
    this.colorBuffer = null;
    this.defaultRenderPassdescriptor = null;
    this.utils = new WebGPUUtils_default(this);
    this.attributeUtils = new WebGPUAttributeUtils_default(this);
    this.bindingUtils = new WebGPUBindingUtils_default(this);
    this.pipelineUtils = new WebGPUPipelineUtils_default(this);
    this.textureUtils = new WebGPUTextureUtils_default(this);
    this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  async init(renderer) {
    await super.init(renderer);
    const parameters = this.parameters;
    let device;
    if (parameters.device === void 0) {
      const adapterOptions = {
        powerPreference: parameters.powerPreference
      };
      const adapter = await navigator.gpu.requestAdapter(adapterOptions);
      if (adapter === null) {
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      }
      const features = Object.values(GPUFeatureName);
      const supportedFeatures = [];
      for (const name of features) {
        if (adapter.features.has(name)) {
          supportedFeatures.push(name);
        }
      }
      const deviceDescriptor = {
        requiredFeatures: supportedFeatures,
        requiredLimits: parameters.requiredLimits
      };
      device = await adapter.requestDevice(deviceDescriptor);
    } else {
      device = parameters.device;
    }
    const context2 = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgpu");
    this.device = device;
    this.context = context2;
    const alphaMode = parameters.alpha ? "premultiplied" : "opaque";
    this.context.configure({
      device: this.device,
      format: GPUTextureFormat.BGRA8Unorm,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode
    });
    this.updateSize();
  }
  get coordinateSystem() {
    return WebGPUCoordinateSystem;
  }
  async getArrayBufferAsync(attribute2) {
    return await this.attributeUtils.getArrayBufferAsync(attribute2);
  }
  getContext() {
    return this.context;
  }
  _getDefaultRenderPassDescriptor() {
    let descriptor = this.defaultRenderPassdescriptor;
    const antialias = this.parameters.antialias;
    if (descriptor === null) {
      const renderer = this.renderer;
      descriptor = {
        colorAttachments: [{
          view: null
        }],
        depthStencilAttachment: {
          view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()
        }
      };
      const colorAttachment2 = descriptor.colorAttachments[0];
      if (antialias === true) {
        colorAttachment2.view = this.colorBuffer.createView();
      } else {
        colorAttachment2.resolveTarget = void 0;
      }
      this.defaultRenderPassdescriptor = descriptor;
    }
    const colorAttachment = descriptor.colorAttachments[0];
    if (antialias === true) {
      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
    } else {
      colorAttachment.view = this.context.getCurrentTexture().createView();
    }
    return descriptor;
  }
  _getRenderPassDescriptor(renderContext) {
    const renderTarget = renderContext.renderTarget;
    const renderTargetData = this.get(renderTarget);
    let descriptors = renderTargetData.descriptors;
    if (descriptors === void 0) {
      descriptors = [];
      renderTargetData.descriptors = descriptors;
    }
    if (renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel || renderTargetData.samples !== renderTarget.samples) {
      descriptors.length = 0;
    }
    let descriptor = descriptors[renderContext.activeCubeFace];
    if (descriptor === void 0) {
      const textures = renderContext.textures;
      const colorAttachments = [];
      for (let i = 0; i < textures.length; i++) {
        const textureData = this.get(textures[i]);
        const textureView = textureData.texture.createView({
          baseMipLevel: renderContext.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: renderContext.activeCubeFace,
          dimension: GPUTextureViewDimension.TwoD
        });
        let view, resolveTarget;
        if (textureData.msaaTexture !== void 0) {
          view = textureData.msaaTexture.createView();
          resolveTarget = textureView;
        } else {
          view = textureView;
          resolveTarget = void 0;
        }
        colorAttachments.push({
          view,
          resolveTarget,
          loadOp: GPULoadOp.Load,
          storeOp: GPUStoreOp.Store
        });
      }
      const depthTextureData = this.get(renderContext.depthTexture);
      const depthStencilAttachment = {
        view: depthTextureData.texture.createView()
      };
      descriptor = {
        colorAttachments,
        depthStencilAttachment
      };
      descriptors[renderContext.activeCubeFace] = descriptor;
      renderTargetData.width = renderTarget.width;
      renderTargetData.height = renderTarget.height;
      renderTargetData.samples = renderTarget.samples;
      renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;
    }
    return descriptor;
  }
  beginRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const device = this.device;
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    let occlusionQuerySet;
    if (occlusionQueryCount > 0) {
      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();
      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();
      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      occlusionQuerySet = device.createQuerySet({ type: "occlusion", count: occlusionQueryCount });
      renderContextData.occlusionQuerySet = occlusionQuerySet;
      renderContextData.occlusionQueryIndex = 0;
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.lastOcclusionObject = null;
    }
    let descriptor;
    if (renderContext.textures === null) {
      descriptor = this._getDefaultRenderPassDescriptor();
    } else {
      descriptor = this._getRenderPassDescriptor(renderContext);
    }
    this.initTimestampQuery(renderContext, descriptor);
    descriptor.occlusionQuerySet = occlusionQuerySet;
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    if (renderContext.textures !== null) {
      const colorAttachments = descriptor.colorAttachments;
      for (let i = 0; i < colorAttachments.length; i++) {
        const colorAttachment = colorAttachments[i];
        if (renderContext.clearColor) {
          colorAttachment.clearValue = renderContext.clearColorValue;
          colorAttachment.loadOp = GPULoadOp.Clear;
          colorAttachment.storeOp = GPUStoreOp.Store;
        } else {
          colorAttachment.loadOp = GPULoadOp.Load;
          colorAttachment.storeOp = GPUStoreOp.Store;
        }
      }
    } else {
      const colorAttachment = descriptor.colorAttachments[0];
      if (renderContext.clearColor) {
        colorAttachment.clearValue = renderContext.clearColorValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      } else {
        colorAttachment.loadOp = GPULoadOp.Load;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
    }
    if (renderContext.depth) {
      if (renderContext.clearDepth) {
        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
    }
    if (renderContext.stencil) {
      if (renderContext.clearStencil) {
        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({ label: "renderContext_" + renderContext.id });
    const currentPass = encoder.beginRenderPass(descriptor);
    renderContextData.descriptor = descriptor;
    renderContextData.encoder = encoder;
    renderContextData.currentPass = currentPass;
    renderContextData.currentSets = { attributes: {} };
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    }
    if (renderContext.scissor) {
      const { x, y, width, height } = renderContext.scissorValue;
      currentPass.setScissorRect(x, renderContext.height - height - y, width, height);
    }
  }
  finishRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (renderContextData.renderBundles !== void 0 && renderContextData.renderBundles.length > 0) {
      renderContextData.registerBundlesPhase = false;
      renderContextData.currentPass.executeBundles(renderContextData.renderBundles);
    }
    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
      renderContextData.currentPass.endOcclusionQuery();
    }
    renderContextData.currentPass.end();
    if (occlusionQueryCount > 0) {
      const bufferSize = occlusionQueryCount * 8;
      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
      if (queryResolveBuffer === void 0) {
        queryResolveBuffer = this.device.createBuffer(
          {
            size: bufferSize,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
          }
        );
        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
      }
      const readBuffer = this.device.createBuffer(
        {
          size: bufferSize,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
      renderContextData.occlusionQueryBuffer = readBuffer;
      this.resolveOccludedAsync(renderContext);
    }
    this.prepareTimestampBuffer(renderContext, renderContextData.encoder);
    this.device.queue.submit([renderContextData.encoder.finish()]);
    if (renderContext.textures !== null) {
      const textures = renderContext.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture2 = textures[i];
        if (texture2.generateMipmaps === true) {
          this.textureUtils.generateMipmaps(texture2);
        }
      }
    }
  }
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  async resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueryBuffer = null;
      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
      const buffer2 = currentOcclusionQueryBuffer.getMappedRange();
      const results = new BigUint64Array(buffer2);
      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {
        if (results[i] !== 0n) {
          occluded.add(currentOcclusionQueryObjects[i]);
        }
      }
      currentOcclusionQueryBuffer.destroy();
      renderContextData.occluded = occluded;
    }
  }
  updateViewport(renderContext) {
    const { currentPass } = this.get(renderContext);
    const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
    currentPass.setViewport(x, renderContext.height - height - y, width, height, minDepth, maxDepth);
  }
  clear(color2, depth2, stencil, renderTargetData = null) {
    const device = this.device;
    const renderer = this.renderer;
    let colorAttachments = [];
    let depthStencilAttachment;
    let clearValue;
    let supportsDepth;
    let supportsStencil;
    if (color2) {
      const clearColor = this.getClearColor();
      clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };
    }
    if (renderTargetData === null) {
      supportsDepth = renderer.depth;
      supportsStencil = renderer.stencil;
      const descriptor = this._getDefaultRenderPassDescriptor();
      if (color2) {
        colorAttachments = descriptor.colorAttachments;
        const colorAttachment = colorAttachments[0];
        colorAttachment.clearValue = clearValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
      if (supportsDepth || supportsStencil) {
        depthStencilAttachment = descriptor.depthStencilAttachment;
      }
    } else {
      supportsDepth = renderTargetData.depth;
      supportsStencil = renderTargetData.stencil;
      if (color2) {
        for (const texture2 of renderTargetData.textures) {
          const textureData = this.get(texture2);
          const textureView = textureData.texture.createView();
          let view, resolveTarget;
          if (textureData.msaaTexture !== void 0) {
            view = textureData.msaaTexture.createView();
            resolveTarget = textureView;
          } else {
            view = textureView;
            resolveTarget = void 0;
          }
          colorAttachments.push({
            view,
            resolveTarget,
            clearValue,
            loadOp: GPULoadOp.Clear,
            storeOp: GPUStoreOp.Store
          });
        }
      }
      if (supportsDepth || supportsStencil) {
        const depthTextureData = this.get(renderTargetData.depthTexture);
        depthStencilAttachment = {
          view: depthTextureData.texture.createView()
        };
      }
    }
    if (supportsDepth) {
      if (depth2) {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthClearValue = renderer.getClearDepth();
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
    }
    if (supportsStencil) {
      if (stencil) {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({});
    const currentPass = encoder.beginRenderPass({
      colorAttachments,
      depthStencilAttachment
    });
    currentPass.end();
    device.queue.submit([encoder.finish()]);
  }
  // compute
  beginCompute(computeGroup) {
    const groupGPU = this.get(computeGroup);
    const descriptor = {};
    this.initTimestampQuery(computeGroup, descriptor);
    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();
    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
  }
  compute(computeGroup, computeNode, bindings, pipeline) {
    const { passEncoderGPU } = this.get(computeGroup);
    const pipelineGPU = this.get(pipeline).pipeline;
    passEncoderGPU.setPipeline(pipelineGPU);
    const bindGroupGPU = this.get(bindings).group;
    passEncoderGPU.setBindGroup(0, bindGroupGPU);
    passEncoderGPU.dispatchWorkgroups(computeNode.dispatchCount);
  }
  finishCompute(computeGroup) {
    const groupData = this.get(computeGroup);
    groupData.passEncoderGPU.end();
    this.prepareTimestampBuffer(computeGroup, groupData.cmdEncoderGPU);
    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
  }
  // render object
  draw(renderObject, info) {
    const { object, geometry, context: context2, pipeline } = renderObject;
    const bindingsData = this.get(renderObject.getBindings());
    const contextData = this.get(context2);
    const pipelineGPU = this.get(pipeline).pipeline;
    const currentSets = contextData.currentSets;
    const renderObjectData = this.get(renderObject);
    const { bundleEncoder, renderBundle, lastPipelineGPU } = renderObjectData;
    const renderContextData = this.get(context2);
    if (renderContextData.registerBundlesPhase === true && bundleEncoder !== void 0 && lastPipelineGPU === pipelineGPU) {
      renderContextData.renderBundles.push(renderBundle);
      return;
    }
    const passEncoderGPU = this.renderer._currentRenderBundle ? this.createBundleEncoder(context2, renderObject) : contextData.currentPass;
    if (currentSets.pipeline !== pipelineGPU) {
      passEncoderGPU.setPipeline(pipelineGPU);
      currentSets.pipeline = pipelineGPU;
    }
    const bindGroupGPU = bindingsData.group;
    passEncoderGPU.setBindGroup(0, bindGroupGPU);
    const index = renderObject.getIndex();
    const hasIndex = index !== null;
    if (hasIndex === true) {
      if (currentSets.index !== index) {
        const buffer2 = this.get(index).buffer;
        const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
        passEncoderGPU.setIndexBuffer(buffer2, indexFormat);
        currentSets.index = index;
      }
    }
    const vertexBuffers = renderObject.getVertexBuffers();
    for (let i = 0, l = vertexBuffers.length; i < l; i++) {
      const vertexBuffer = vertexBuffers[i];
      if (currentSets.attributes[i] !== vertexBuffer) {
        const buffer2 = this.get(vertexBuffer).buffer;
        passEncoderGPU.setVertexBuffer(i, buffer2);
        currentSets.attributes[i] = vertexBuffer;
      }
    }
    if (contextData.occlusionQuerySet !== void 0) {
      const lastObject = contextData.lastOcclusionObject;
      if (lastObject !== object) {
        if (lastObject !== null && lastObject.occlusionTest === true) {
          passEncoderGPU.endOcclusionQuery();
          contextData.occlusionQueryIndex++;
        }
        if (object.occlusionTest === true) {
          passEncoderGPU.beginOcclusionQuery(contextData.occlusionQueryIndex);
          contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
        }
        contextData.lastOcclusionObject = object;
      }
    }
    const drawRange = renderObject.drawRange;
    const firstVertex = drawRange.start;
    const instanceCount = this.getInstanceCount(renderObject);
    if (instanceCount === 0) return;
    if (hasIndex === true) {
      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;
      passEncoderGPU.drawIndexed(indexCount, instanceCount, firstVertex, 0, 0);
      info.update(object, indexCount, instanceCount);
    } else {
      const positionAttribute = geometry.attributes.position;
      const vertexCount = drawRange.count !== Infinity ? drawRange.count : positionAttribute.count;
      passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
      info.update(object, vertexCount, instanceCount);
    }
    if (this.renderer._currentRenderBundle) {
      const renderBundle2 = passEncoderGPU.finish();
      renderObjectData.lastPipelineGPU = pipelineGPU;
      renderObjectData.renderBundle = renderBundle2;
      renderObjectData.bundleEncoder = passEncoderGPU;
    }
  }
  // cache key
  needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    const { object, material } = renderObject;
    const utils = this.utils;
    const sampleCount = utils.getSampleCount(renderObject.context);
    const colorSpace = utils.getCurrentColorSpace(renderObject.context);
    const colorFormat = utils.getCurrentColorFormat(renderObject.context);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
    const primitiveTopology = utils.getPrimitiveTopology(object, material);
    let needsUpdate = false;
    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextVersion !== renderObject.clippingContextVersion) {
      data.material = material;
      data.materialVersion = material.version;
      data.transparent = material.transparent;
      data.blending = material.blending;
      data.premultipliedAlpha = material.premultipliedAlpha;
      data.blendSrc = material.blendSrc;
      data.blendDst = material.blendDst;
      data.blendEquation = material.blendEquation;
      data.blendSrcAlpha = material.blendSrcAlpha;
      data.blendDstAlpha = material.blendDstAlpha;
      data.blendEquationAlpha = material.blendEquationAlpha;
      data.colorWrite = material.colorWrite;
      data.depthWrite = material.depthWrite;
      data.depthTest = material.depthTest;
      data.depthFunc = material.depthFunc;
      data.stencilWrite = material.stencilWrite;
      data.stencilFunc = material.stencilFunc;
      data.stencilFail = material.stencilFail;
      data.stencilZFail = material.stencilZFail;
      data.stencilZPass = material.stencilZPass;
      data.stencilFuncMask = material.stencilFuncMask;
      data.stencilWriteMask = material.stencilWriteMask;
      data.side = material.side;
      data.alphaToCoverage = material.alphaToCoverage;
      data.sampleCount = sampleCount;
      data.colorSpace = colorSpace;
      data.colorFormat = colorFormat;
      data.depthStencilFormat = depthStencilFormat;
      data.primitiveTopology = primitiveTopology;
      data.clippingContextVersion = renderObject.clippingContextVersion;
      needsUpdate = true;
    }
    return needsUpdate;
  }
  getRenderCacheKey(renderObject) {
    const { object, material } = renderObject;
    const utils = this.utils;
    const renderContext = renderObject.context;
    return [
      material.transparent,
      material.blending,
      material.premultipliedAlpha,
      material.blendSrc,
      material.blendDst,
      material.blendEquation,
      material.blendSrcAlpha,
      material.blendDstAlpha,
      material.blendEquationAlpha,
      material.colorWrite,
      material.depthWrite,
      material.depthTest,
      material.depthFunc,
      material.stencilWrite,
      material.stencilFunc,
      material.stencilFail,
      material.stencilZFail,
      material.stencilZPass,
      material.stencilFuncMask,
      material.stencilWriteMask,
      material.side,
      utils.getSampleCount(renderContext),
      utils.getCurrentColorSpace(renderContext),
      utils.getCurrentColorFormat(renderContext),
      utils.getCurrentDepthStencilFormat(renderContext),
      utils.getPrimitiveTopology(object, material),
      renderObject.clippingContextVersion
    ].join();
  }
  // textures
  createSampler(texture2) {
    this.textureUtils.createSampler(texture2);
  }
  destroySampler(texture2) {
    this.textureUtils.destroySampler(texture2);
  }
  createDefaultTexture(texture2) {
    this.textureUtils.createDefaultTexture(texture2);
  }
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  destroyTexture(texture2) {
    this.textureUtils.destroyTexture(texture2);
  }
  copyTextureToBuffer(texture2, x, y, width, height) {
    return this.textureUtils.copyTextureToBuffer(texture2, x, y, width, height);
  }
  initTimestampQuery(renderContext, descriptor) {
    if (!this.hasFeature(GPUFeatureName.TimestampQuery) || !this.trackTimestamp) return;
    const renderContextData = this.get(renderContext);
    if (!renderContextData.timeStampQuerySet) {
      const timeStampQuerySet = this.device.createQuerySet({ type: "timestamp", count: 2 });
      const timestampWrites = {
        querySet: timeStampQuerySet,
        beginningOfPassWriteIndex: 0,
        // Write timestamp in index 0 when pass begins.
        endOfPassWriteIndex: 1
        // Write timestamp in index 1 when pass ends.
      };
      Object.assign(descriptor, {
        timestampWrites
      });
      renderContextData.timeStampQuerySet = timeStampQuerySet;
    }
  }
  // timestamp utils
  prepareTimestampBuffer(renderContext, encoder) {
    if (!this.hasFeature(GPUFeatureName.TimestampQuery) || !this.trackTimestamp) return;
    const renderContextData = this.get(renderContext);
    const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;
    const resolveBuffer = this.device.createBuffer({
      size,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    });
    const resultBuffer = this.device.createBuffer({
      size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    encoder.resolveQuerySet(renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0);
    encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, size);
    renderContextData.currentTimestampQueryBuffer = resultBuffer;
  }
  async resolveTimestampAsync(renderContext, type = "render") {
    if (!this.hasFeature(GPUFeatureName.TimestampQuery) || !this.trackTimestamp) return;
    const renderContextData = this.get(renderContext);
    const { currentTimestampQueryBuffer } = renderContextData;
    if (currentTimestampQueryBuffer === void 0) return;
    const buffer2 = currentTimestampQueryBuffer;
    try {
      await buffer2.mapAsync(GPUMapMode.READ);
      const times = new BigUint64Array(buffer2.getMappedRange());
      const duration = Number(times[1] - times[0]) / 1e6;
      this.renderer.info.updateTimestamp(type, duration);
    } catch (error) {
      console.error(`Error mapping buffer: ${error}`);
    } finally {
      buffer2.unmap();
    }
  }
  // node builder
  createNodeBuilder(object, renderer, scene = null) {
    return new WGSLNodeBuilder_default(object, renderer, scene);
  }
  // program
  createProgram(program) {
    const programGPU = this.get(program);
    programGPU.module = {
      module: this.device.createShaderModule({ code: program.code, label: program.stage }),
      entryPoint: "main"
    };
  }
  destroyProgram(program) {
    this.delete(program);
  }
  // pipelines
  createRenderPipeline(renderObject, promises) {
    this.pipelineUtils.createRenderPipeline(renderObject, promises);
  }
  createComputePipeline(computePipeline, bindings) {
    this.pipelineUtils.createComputePipeline(computePipeline, bindings);
  }
  createBundleEncoder(renderContext, renderObject) {
    return this.pipelineUtils.createBundleEncoder(renderContext, renderObject);
  }
  // bindings
  createBindings(bindings) {
    this.bindingUtils.createBindings(bindings);
  }
  updateBindings(bindings) {
    this.bindingUtils.createBindings(bindings);
  }
  updateBinding(binding) {
    this.bindingUtils.updateBinding(binding);
  }
  // attributes
  createIndexAttribute(attribute2) {
    this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createAttribute(attribute2) {
    this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createStorageAttribute(attribute2) {
    this.attributeUtils.createAttribute(attribute2, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  updateAttribute(attribute2) {
    this.attributeUtils.updateAttribute(attribute2);
  }
  destroyAttribute(attribute2) {
    this.attributeUtils.destroyAttribute(attribute2);
  }
  // canvas
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer();
    this.defaultRenderPassdescriptor = null;
  }
  // utils public
  getMaxAnisotropy() {
    return 16;
  }
  hasFeature(name) {
    return this.device.features.has(name);
  }
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
    let dstX = 0;
    let dstY = 0;
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
    }
    const encoder = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + srcTexture.id + "_" + dstTexture.id });
    const sourceGPU = this.get(srcTexture).texture;
    const destinationGPU = this.get(dstTexture).texture;
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        mipLevel: level,
        origin: { x: 0, y: 0, z: 0 }
      },
      {
        texture: destinationGPU,
        mipLevel: level,
        origin: { x: dstX, y: dstY, z: 0 }
      },
      [
        srcTexture.image.width,
        srcTexture.image.height
      ]
    );
    this.device.queue.submit([encoder.finish()]);
  }
  copyFramebufferToTexture(texture2, renderContext) {
    const renderContextData = this.get(renderContext);
    const { encoder, descriptor } = renderContextData;
    let sourceGPU = null;
    if (renderContext.renderTarget) {
      if (texture2.isDepthTexture) {
        sourceGPU = this.get(renderContext.depthTexture).texture;
      } else {
        sourceGPU = this.get(renderContext.textures[0]).texture;
      }
    } else {
      if (texture2.isDepthTexture) {
        sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
      } else {
        sourceGPU = this.context.getCurrentTexture();
      }
    }
    const destinationGPU = this.get(texture2).texture;
    if (sourceGPU.format !== destinationGPU.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", sourceGPU.format, destinationGPU.format);
      return;
    }
    renderContextData.currentPass.end();
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        origin: { x: 0, y: 0, z: 0 }
      },
      {
        texture: destinationGPU
      },
      [
        texture2.image.width,
        texture2.image.height
      ]
    );
    if (texture2.generateMipmaps) this.textureUtils.generateMipmaps(texture2);
    descriptor.colorAttachments[0].loadOp = GPULoadOp.Load;
    if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
    if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
    renderContextData.currentPass = encoder.beginRenderPass(descriptor);
    renderContextData.currentSets = { attributes: {} };
  }
};
var WebGPUBackend_default = WebGPUBackend;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderer.js
var WebGPURenderer = class extends Renderer_default {
  constructor(parameters = {}) {
    let BackendClass;
    if (parameters.forceWebGL) {
      BackendClass = WebGLBackend_default;
    } else if (WebGPU_default.isAvailable()) {
      BackendClass = WebGPUBackend_default;
    } else {
      BackendClass = WebGLBackend_default;
      console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.");
    }
    const backend = new BackendClass(parameters);
    super(backend, parameters);
    this.isWebGPURenderer = true;
  }
};
var WebGPURenderer_default = WebGPURenderer;
export {
  WebGPURenderer_default as default
};
//# sourceMappingURL=three_addons_renderers_webgpu_WebGPURenderer__js.js.map
